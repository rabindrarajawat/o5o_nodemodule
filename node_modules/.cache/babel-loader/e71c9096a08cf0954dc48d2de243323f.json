{"ast":null,"code":"import { PublicKey } from '@solana/web3.js';\nimport { parseCandyMachineV2Account, parseCandyMachineV2CollectionAccount } from '../accounts.mjs';\nimport { findCandyMachineV2CollectionPda } from '../pdas.mjs';\nimport { CandyMachineV2Program } from '../program.mjs';\nimport { UnreachableCaseError } from '../../../errors/SdkError.mjs';\nimport { zipMap } from '../../../utils/common.mjs';\nimport { useOperation } from '../../../types/Operation.mjs';\nimport { toMint } from '../../tokenModule/models/Mint.mjs';\nimport { toMintAccount } from '../../tokenModule/accounts.mjs';\nimport { toCandyMachineV2 } from '../models/CandyMachineV2.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindCandyMachinesV2ByPublicKeyOperation';\n/**\n * Find all Candy Machines matching by a given `publicKey` or a given `type`.\n *\n * The following two types are supported.\n *\n * `authority`: Find Candy Machines whose authority is the given `publicKey`.\n * ```ts\n * const someAuthority = new PublicKey('...');\n * const candyMachines = await metaplex\n *   .candyMachinesV2()\n *   .findAllBy({ type: 'authority', someAuthority });\n * ```\n *\n * `wallet`: Find Candy Machines whose wallet address is the given `publicKey`.\n * ```ts\n * const someWallet = new PublicKey('...');\n * const candyMachines = await metaplex\n *   .candyMachinesV2()\n *   .findAllBy({ type: 'wallet', someWallet });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst findCandyMachinesV2ByPublicKeyFieldOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst findCandyMachinesV2ByPublicKeyFieldOperationHandler = {\n  handle: async (operation, metaplex, scope) => {\n    const {\n      commitment\n    } = scope;\n    const {\n      type,\n      publicKey\n    } = operation.input;\n    const accounts = CandyMachineV2Program.accounts(metaplex).mergeConfig({\n      commitment\n    });\n    let candyMachineQuery;\n\n    switch (type) {\n      case 'authority':\n        candyMachineQuery = accounts.candyMachineAccountsForAuthority(publicKey);\n        break;\n\n      case 'wallet':\n        candyMachineQuery = accounts.candyMachineAccountsForWallet(publicKey);\n        break;\n\n      default:\n        throw new UnreachableCaseError(type);\n    }\n\n    const unparsedAccounts = await candyMachineQuery.get();\n    scope.throwIfCanceled();\n    const collectionPdas = unparsedAccounts.map(unparsedAccount => findCandyMachineV2CollectionPda(unparsedAccount.publicKey)); // Find mint details for all unique SPL tokens used\n    // in candy machines that have non-null `tokenMint`\n\n    const parsedAccounts = Object.fromEntries(unparsedAccounts.map(unparsedAccount => [unparsedAccount.publicKey.toString(), parseCandyMachineV2Account(unparsedAccount)]));\n    const tokenMints = [...new Set(Object.values(parsedAccounts).map(account => account.data.tokenMint?.toString()).filter(tokenMint => tokenMint !== undefined))].map(address => new PublicKey(address));\n    const result = await metaplex.rpc().getMultipleAccounts(tokenMints.concat(collectionPdas), commitment);\n    scope.throwIfCanceled();\n    const unparsedMintAccounts = result.slice(0, tokenMints.length);\n    const unparsedCollectionAccounts = result.slice(-collectionPdas.length);\n    const mints = Object.fromEntries(unparsedMintAccounts.map(account => [account.publicKey.toString(), toMint(toMintAccount(account))]));\n    return zipMap(unparsedAccounts, unparsedCollectionAccounts, (unparsedAccount, unparsedCollectionAccount) => {\n      const parsedAccount = parsedAccounts[unparsedAccount.publicKey.toString()];\n      const collectionAccount = unparsedCollectionAccount ? parseCandyMachineV2CollectionAccount(unparsedCollectionAccount) : null;\n      const tokenMintAddress = parsedAccount.data.tokenMint?.toString();\n      return toCandyMachineV2(parsedAccount, unparsedAccount, collectionAccount, tokenMintAddress ? mints[tokenMintAddress] : null);\n    });\n  }\n};\nexport { findCandyMachinesV2ByPublicKeyFieldOperation, findCandyMachinesV2ByPublicKeyFieldOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineV2Module/operations/findCandyMachinesV2ByPublicKeyField.ts"],"names":["Key","findCandyMachinesV2ByPublicKeyFieldOperation","useOperation","findCandyMachinesV2ByPublicKeyFieldOperationHandler","handle","operation","metaplex","scope","commitment","type","publicKey","input","accounts","CandyMachineV2Program","mergeConfig","candyMachineQuery","candyMachineAccountsForAuthority","candyMachineAccountsForWallet","UnreachableCaseError","unparsedAccounts","get","throwIfCanceled","collectionPdas","map","unparsedAccount","findCandyMachineV2CollectionPda","parsedAccounts","Object","fromEntries","toString","parseCandyMachineV2Account","tokenMints","Set","values","account","data","tokenMint","filter","undefined","address","PublicKey","result","rpc","getMultipleAccounts","concat","unparsedMintAccounts","slice","length","unparsedCollectionAccounts","mints","toMint","toMintAccount","zipMap","unparsedCollectionAccount","parsedAccount","collectionAccount","parseCandyMachineV2CollectionAccount","tokenMintAddress","toCandyMachineV2"],"mappings":"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","sourcesContent":["import { PublicKey } from '@solana/web3.js';\nimport {\n  CandyMachineV2Account,\n  parseCandyMachineV2Account,\n  parseCandyMachineV2CollectionAccount,\n} from '../accounts';\nimport { CandyMachineV2GpaBuilder } from '../gpaBuilders';\nimport { CandyMachineV2, toCandyMachineV2 } from '../models';\nimport { findCandyMachineV2CollectionPda } from '../pdas';\nimport { CandyMachineV2Program } from '../program';\nimport { zipMap } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Mint, toMint, toMintAccount } from '@/plugins/tokenModule';\nimport { Metaplex } from '@/Metaplex';\nimport { UnreachableCaseError } from '@/errors';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindCandyMachinesV2ByPublicKeyOperation' as const;\n\n/**\n * Find all Candy Machines matching by a given `publicKey` or a given `type`.\n *\n * The following two types are supported.\n *\n * `authority`: Find Candy Machines whose authority is the given `publicKey`.\n * ```ts\n * const someAuthority = new PublicKey('...');\n * const candyMachines = await metaplex\n *   .candyMachinesV2()\n *   .findAllBy({ type: 'authority', someAuthority });\n * ```\n *\n * `wallet`: Find Candy Machines whose wallet address is the given `publicKey`.\n * ```ts\n * const someWallet = new PublicKey('...');\n * const candyMachines = await metaplex\n *   .candyMachinesV2()\n *   .findAllBy({ type: 'wallet', someWallet });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findCandyMachinesV2ByPublicKeyFieldOperation =\n  useOperation<FindCandyMachinesV2ByPublicKeyFieldOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindCandyMachinesV2ByPublicKeyFieldOperation = Operation<\n  typeof Key,\n  FindCandyMachinesV2ByPublicKeyFieldInput,\n  CandyMachineV2[]\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindCandyMachinesV2ByPublicKeyFieldInput = {\n  /** Defines which type of account the `publicKey` field refers to.  */\n  type: 'authority' | 'wallet';\n\n  /** The publicKey to filter Candy Machine by. */\n  publicKey: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findCandyMachinesV2ByPublicKeyFieldOperationHandler: OperationHandler<FindCandyMachinesV2ByPublicKeyFieldOperation> =\n  {\n    handle: async (\n      operation: FindCandyMachinesV2ByPublicKeyFieldOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CandyMachineV2[]> => {\n      const { commitment } = scope;\n      const { type, publicKey } = operation.input;\n      const accounts = CandyMachineV2Program.accounts(metaplex).mergeConfig({\n        commitment,\n      });\n\n      let candyMachineQuery: CandyMachineV2GpaBuilder;\n      switch (type) {\n        case 'authority':\n          candyMachineQuery =\n            accounts.candyMachineAccountsForAuthority(publicKey);\n          break;\n        case 'wallet':\n          candyMachineQuery = accounts.candyMachineAccountsForWallet(publicKey);\n          break;\n        default:\n          throw new UnreachableCaseError(type);\n      }\n\n      const unparsedAccounts = await candyMachineQuery.get();\n      scope.throwIfCanceled();\n\n      const collectionPdas = unparsedAccounts.map((unparsedAccount) =>\n        findCandyMachineV2CollectionPda(unparsedAccount.publicKey)\n      );\n\n      // Find mint details for all unique SPL tokens used\n      // in candy machines that have non-null `tokenMint`\n\n      const parsedAccounts: Record<string, CandyMachineV2Account> =\n        Object.fromEntries(\n          unparsedAccounts.map((unparsedAccount) => [\n            unparsedAccount.publicKey.toString(),\n            parseCandyMachineV2Account(unparsedAccount),\n          ])\n        );\n\n      const tokenMints = [\n        ...new Set(\n          Object.values(parsedAccounts)\n            .map((account) => account.data.tokenMint?.toString())\n            .filter((tokenMint): tokenMint is string => tokenMint !== undefined)\n        ),\n      ].map((address) => new PublicKey(address));\n\n      const result = await metaplex\n        .rpc()\n        .getMultipleAccounts(tokenMints.concat(collectionPdas), commitment);\n      scope.throwIfCanceled();\n\n      const unparsedMintAccounts = result.slice(0, tokenMints.length);\n      const unparsedCollectionAccounts = result.slice(-collectionPdas.length);\n\n      const mints: Record<string, Mint> = Object.fromEntries(\n        unparsedMintAccounts.map((account) => [\n          account.publicKey.toString(),\n          toMint(toMintAccount(account)),\n        ])\n      );\n\n      return zipMap(\n        unparsedAccounts,\n        unparsedCollectionAccounts,\n        (unparsedAccount, unparsedCollectionAccount) => {\n          const parsedAccount =\n            parsedAccounts[unparsedAccount.publicKey.toString()];\n          const collectionAccount = unparsedCollectionAccount\n            ? parseCandyMachineV2CollectionAccount(unparsedCollectionAccount)\n            : null;\n          const tokenMintAddress = parsedAccount.data.tokenMint?.toString();\n\n          return toCandyMachineV2(\n            parsedAccount,\n            unparsedAccount,\n            collectionAccount,\n            tokenMintAddress ? mints[tokenMintAddress] : null\n          );\n        }\n      );\n    },\n  };\n"]},"metadata":{},"sourceType":"module"}