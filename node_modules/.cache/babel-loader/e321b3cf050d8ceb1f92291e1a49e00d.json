{"ast":null,"code":"import { BEET_TYPE_ARG_LEN } from '../types';\nimport { strict as assert } from 'assert';\nimport { u32 } from './numbers';\nimport { BEET_PACKAGE } from '../types';\nimport { logTrace } from '../utils';\nimport { fixBeetFromData, fixBeetFromValue } from '../beet.fixable';\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element type\n * @param len the number of elements in the array\n * @param lenPrefix if `true` a 4 byte number indicating the size of the array\n * will be included before serialized array data\n *\n * @category beet/collection\n */\n\nexport function uniformFixedSizeArray(element, len) {\n  let lenPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const arraySize = element.byteSize * len;\n  const byteSize = lenPrefix ? 4 + arraySize : arraySize;\n  return {\n    write: function (buf, offset, value) {\n      assert.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n\n      if (lenPrefix) {\n        u32.write(buf, offset, len);\n        offset += 4;\n      }\n\n      for (let i = 0; i < len; i++) {\n        element.write(buf, offset + i * element.byteSize, value[i]);\n      }\n    },\n    read: function (buf, offset) {\n      if (lenPrefix) {\n        const size = u32.read(buf, offset);\n        assert.equal(size, len, 'invalid byte size');\n        offset += 4;\n      }\n\n      const arr = new Array(len);\n\n      for (let i = 0; i < len; i++) {\n        arr[i] = element.read(buf, offset + i * element.byteSize);\n      }\n\n      return arr;\n    },\n    byteSize,\n    length: len,\n    elementByteSize: element.byteSize,\n    lenPrefixByteSize: 4,\n    description: `Array<${element.description}>(${len})`\n  };\n}\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which do not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param elements the De/Serializers for the element types\n * @param elementsByteSize size of all elements in the array combined\n *\n * @category beet/collection\n */\n\nexport function fixedSizeArray(elements, elementsByteSize) {\n  const len = elements.length;\n  const firstElement = len === 0 ? '<EMPTY>' : elements[0].description;\n  return {\n    write: function (buf, offset, value) {\n      assert.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n      u32.write(buf, offset, len);\n      let cursor = offset + 4;\n\n      for (let i = 0; i < len; i++) {\n        const element = elements[i];\n        element.write(buf, cursor, value[i]);\n        cursor += element.byteSize;\n      }\n    },\n    read: function (buf, offset) {\n      const size = u32.read(buf, offset);\n      assert.equal(size, len, 'invalid byte size');\n      let cursor = offset + 4;\n      const arr = new Array(len);\n\n      for (let i = 0; i < len; i++) {\n        const element = elements[i];\n        arr[i] = element.read(buf, cursor);\n        cursor += element.byteSize;\n      }\n\n      return arr;\n    },\n    byteSize: 4 + elementsByteSize,\n    length: len,\n    description: `Array<${firstElement}>(${len})[ 4 + ${elementsByteSize} ]`\n  };\n}\n/**\n * Wraps an array De/Serializer with with elements of type {@link T} which do\n * not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element types\n *\n * @category beet/collection\n */\n\nexport function array(element) {\n  return {\n    toFixedFromData(buf, offset) {\n      const len = u32.read(buf, offset);\n      logTrace(`${this.description}[${len}]`);\n      const cursorStart = offset + 4;\n      let cursor = cursorStart;\n      const fixedElements = new Array(len);\n\n      for (let i = 0; i < len; i++) {\n        const fixedElement = fixBeetFromData(element, buf, cursor);\n        fixedElements[i] = fixedElement;\n        cursor += fixedElement.byteSize;\n      }\n\n      return fixedSizeArray(fixedElements, cursor - cursorStart);\n    },\n\n    toFixedFromValue(vals) {\n      assert(Array.isArray(vals), `${vals} should be an array`);\n      let elementsSize = 0;\n      const fixedElements = new Array(vals.length);\n\n      for (let i = 0; i < vals.length; i++) {\n        const fixedElement = fixBeetFromValue(element, vals[i]);\n        fixedElements[i] = fixedElement;\n        elementsSize += fixedElement.byteSize;\n      }\n\n      return fixedSizeArray(fixedElements, elementsSize);\n    },\n\n    description: `array`\n  };\n}\n/**\n * A De/Serializer for raw {@link Buffer}s that just copies/reads the buffer bytes\n * to/from the provided buffer.\n *\n * @param bytes the byte size of the buffer to de/serialize\n * @category beet/collection\n */\n\nexport function fixedSizeBuffer(bytes) {\n  return {\n    write: function (buf, offset, value) {\n      value.copy(buf, offset, 0, bytes);\n    },\n    read: function (buf, offset) {\n      return buf.slice(offset, offset + bytes);\n    },\n    byteSize: bytes,\n    description: `Buffer(${bytes})`\n  };\n}\n/**\n * A De/Serializer for {@link Uint8Array}s of known size that just copies/reads\n * the array bytes to/from the provided buffer.\n *\n * @category beet/collection\n */\n\nexport function fixedSizeUint8Array(len) {\n  let lenPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const arrayBufferBeet = fixedSizeBuffer(len);\n  const byteSize = lenPrefix ? len + 4 : len;\n  return {\n    write: function (buf, offset, value) {\n      assert.equal(value.byteLength, len, `Uint8Array length ${value.byteLength} should match len ${len}`);\n\n      if (lenPrefix) {\n        u32.write(buf, offset, len);\n        offset += 4;\n      }\n\n      const valueBuf = Buffer.from(value);\n      arrayBufferBeet.write(buf, offset, valueBuf);\n    },\n    read: function (buf, offset) {\n      if (lenPrefix) {\n        const size = u32.read(buf, offset);\n        assert.equal(size, len, 'invalid byte size');\n        offset += 4;\n      }\n\n      const arrayBuffer = arrayBufferBeet.read(buf, offset);\n      return Uint8Array.from(arrayBuffer);\n    },\n    byteSize,\n    description: `Uint8Array(${len})`\n  };\n}\n/**\n * A De/Serializer for {@link Uint8Array}s that just copies/reads the array bytes\n * to/from the provided buffer.\n *\n * @category beet/collection\n */\n\nexport const uint8Array = {\n  toFixedFromData(buf, offset) {\n    const len = u32.read(buf, offset);\n    logTrace(`${this.description}[${len}]`);\n    return fixedSizeUint8Array(len, true);\n  },\n\n  toFixedFromValue(val) {\n    const len = val.byteLength;\n    return fixedSizeUint8Array(len, true);\n  },\n\n  description: `Uint8Array`\n};\n/**\n * Maps collections beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexport const collectionsTypeMap = {\n  Array: {\n    beet: 'array',\n    isFixable: true,\n    sourcePack: BEET_PACKAGE,\n    ts: 'Array',\n    arg: BEET_TYPE_ARG_LEN\n  },\n  FixedSizeArray: {\n    beet: 'fixedSizeArray',\n    isFixable: false,\n    sourcePack: BEET_PACKAGE,\n    ts: 'Array',\n    arg: BEET_TYPE_ARG_LEN\n  },\n  UniformFixedSizeArray: {\n    beet: 'uniformFixedSizeArray',\n    isFixable: false,\n    sourcePack: BEET_PACKAGE,\n    ts: 'Array',\n    arg: BEET_TYPE_ARG_LEN\n  },\n  Buffer: {\n    beet: 'fixedSizeBuffer',\n    isFixable: false,\n    sourcePack: BEET_PACKAGE,\n    ts: 'Buffer',\n    arg: BEET_TYPE_ARG_LEN\n  },\n  FixedSizeUint8Array: {\n    beet: 'fixedSizeUint8Array',\n    isFixable: false,\n    sourcePack: BEET_PACKAGE,\n    ts: 'Uint8Array',\n    arg: BEET_TYPE_ARG_LEN\n  },\n  Uint8Array: {\n    beet: 'uint8Array',\n    isFixable: true,\n    sourcePack: BEET_PACKAGE,\n    ts: 'Uint8Array',\n    arg: BEET_TYPE_ARG_LEN\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/collections.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BEET_TYPE_ARG_LEN, } from '../types';\nimport { strict as assert } from 'assert';\nimport { u32 } from './numbers';\nimport { BEET_PACKAGE } from '../types';\nimport { logTrace } from '../utils';\nimport { fixBeetFromData, fixBeetFromValue } from '../beet.fixable';\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element type\n * @param len the number of elements in the array\n * @param lenPrefix if `true` a 4 byte number indicating the size of the array\n * will be included before serialized array data\n *\n * @category beet/collection\n */\nexport function uniformFixedSizeArray(element, len, lenPrefix = false) {\n    const arraySize = element.byteSize * len;\n    const byteSize = lenPrefix ? 4 + arraySize : arraySize;\n    return {\n        write: function (buf, offset, value) {\n            assert.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n            if (lenPrefix) {\n                u32.write(buf, offset, len);\n                offset += 4;\n            }\n            for (let i = 0; i < len; i++) {\n                element.write(buf, offset + i * element.byteSize, value[i]);\n            }\n        },\n        read: function (buf, offset) {\n            if (lenPrefix) {\n                const size = u32.read(buf, offset);\n                assert.equal(size, len, 'invalid byte size');\n                offset += 4;\n            }\n            const arr = new Array(len);\n            for (let i = 0; i < len; i++) {\n                arr[i] = element.read(buf, offset + i * element.byteSize);\n            }\n            return arr;\n        },\n        byteSize,\n        length: len,\n        elementByteSize: element.byteSize,\n        lenPrefixByteSize: 4,\n        description: `Array<${element.description}>(${len})`,\n    };\n}\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which do not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param elements the De/Serializers for the element types\n * @param elementsByteSize size of all elements in the array combined\n *\n * @category beet/collection\n */\nexport function fixedSizeArray(elements, elementsByteSize) {\n    const len = elements.length;\n    const firstElement = len === 0 ? '<EMPTY>' : elements[0].description;\n    return {\n        write: function (buf, offset, value) {\n            assert.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n            u32.write(buf, offset, len);\n            let cursor = offset + 4;\n            for (let i = 0; i < len; i++) {\n                const element = elements[i];\n                element.write(buf, cursor, value[i]);\n                cursor += element.byteSize;\n            }\n        },\n        read: function (buf, offset) {\n            const size = u32.read(buf, offset);\n            assert.equal(size, len, 'invalid byte size');\n            let cursor = offset + 4;\n            const arr = new Array(len);\n            for (let i = 0; i < len; i++) {\n                const element = elements[i];\n                arr[i] = element.read(buf, cursor);\n                cursor += element.byteSize;\n            }\n            return arr;\n        },\n        byteSize: 4 + elementsByteSize,\n        length: len,\n        description: `Array<${firstElement}>(${len})[ 4 + ${elementsByteSize} ]`,\n    };\n}\n/**\n * Wraps an array De/Serializer with with elements of type {@link T} which do\n * not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element types\n *\n * @category beet/collection\n */\nexport function array(element) {\n    return {\n        toFixedFromData(buf, offset) {\n            const len = u32.read(buf, offset);\n            logTrace(`${this.description}[${len}]`);\n            const cursorStart = offset + 4;\n            let cursor = cursorStart;\n            const fixedElements = new Array(len);\n            for (let i = 0; i < len; i++) {\n                const fixedElement = fixBeetFromData(element, buf, cursor);\n                fixedElements[i] = fixedElement;\n                cursor += fixedElement.byteSize;\n            }\n            return fixedSizeArray(fixedElements, cursor - cursorStart);\n        },\n        toFixedFromValue(vals) {\n            assert(Array.isArray(vals), `${vals} should be an array`);\n            let elementsSize = 0;\n            const fixedElements = new Array(vals.length);\n            for (let i = 0; i < vals.length; i++) {\n                const fixedElement = fixBeetFromValue(element, vals[i]);\n                fixedElements[i] = fixedElement;\n                elementsSize += fixedElement.byteSize;\n            }\n            return fixedSizeArray(fixedElements, elementsSize);\n        },\n        description: `array`,\n    };\n}\n/**\n * A De/Serializer for raw {@link Buffer}s that just copies/reads the buffer bytes\n * to/from the provided buffer.\n *\n * @param bytes the byte size of the buffer to de/serialize\n * @category beet/collection\n */\nexport function fixedSizeBuffer(bytes) {\n    return {\n        write: function (buf, offset, value) {\n            value.copy(buf, offset, 0, bytes);\n        },\n        read: function (buf, offset) {\n            return buf.slice(offset, offset + bytes);\n        },\n        byteSize: bytes,\n        description: `Buffer(${bytes})`,\n    };\n}\n/**\n * A De/Serializer for {@link Uint8Array}s of known size that just copies/reads\n * the array bytes to/from the provided buffer.\n *\n * @category beet/collection\n */\nexport function fixedSizeUint8Array(len, lenPrefix = false) {\n    const arrayBufferBeet = fixedSizeBuffer(len);\n    const byteSize = lenPrefix ? len + 4 : len;\n    return {\n        write: function (buf, offset, value) {\n            assert.equal(value.byteLength, len, `Uint8Array length ${value.byteLength} should match len ${len}`);\n            if (lenPrefix) {\n                u32.write(buf, offset, len);\n                offset += 4;\n            }\n            const valueBuf = Buffer.from(value);\n            arrayBufferBeet.write(buf, offset, valueBuf);\n        },\n        read: function (buf, offset) {\n            if (lenPrefix) {\n                const size = u32.read(buf, offset);\n                assert.equal(size, len, 'invalid byte size');\n                offset += 4;\n            }\n            const arrayBuffer = arrayBufferBeet.read(buf, offset);\n            return Uint8Array.from(arrayBuffer);\n        },\n        byteSize,\n        description: `Uint8Array(${len})`,\n    };\n}\n/**\n * A De/Serializer for {@link Uint8Array}s that just copies/reads the array bytes\n * to/from the provided buffer.\n *\n * @category beet/collection\n */\nexport const uint8Array = {\n    toFixedFromData(buf, offset) {\n        const len = u32.read(buf, offset);\n        logTrace(`${this.description}[${len}]`);\n        return fixedSizeUint8Array(len, true);\n    },\n    toFixedFromValue(val) {\n        const len = val.byteLength;\n        return fixedSizeUint8Array(len, true);\n    },\n    description: `Uint8Array`,\n};\n/**\n * Maps collections beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexport const collectionsTypeMap = {\n    Array: {\n        beet: 'array',\n        isFixable: true,\n        sourcePack: BEET_PACKAGE,\n        ts: 'Array',\n        arg: BEET_TYPE_ARG_LEN,\n    },\n    FixedSizeArray: {\n        beet: 'fixedSizeArray',\n        isFixable: false,\n        sourcePack: BEET_PACKAGE,\n        ts: 'Array',\n        arg: BEET_TYPE_ARG_LEN,\n    },\n    UniformFixedSizeArray: {\n        beet: 'uniformFixedSizeArray',\n        isFixable: false,\n        sourcePack: BEET_PACKAGE,\n        ts: 'Array',\n        arg: BEET_TYPE_ARG_LEN,\n    },\n    Buffer: {\n        beet: 'fixedSizeBuffer',\n        isFixable: false,\n        sourcePack: BEET_PACKAGE,\n        ts: 'Buffer',\n        arg: BEET_TYPE_ARG_LEN,\n    },\n    FixedSizeUint8Array: {\n        beet: 'fixedSizeUint8Array',\n        isFixable: false,\n        sourcePack: BEET_PACKAGE,\n        ts: 'Uint8Array',\n        arg: BEET_TYPE_ARG_LEN,\n    },\n    Uint8Array: {\n        beet: 'uint8Array',\n        isFixable: true,\n        sourcePack: BEET_PACKAGE,\n        ts: 'Uint8Array',\n        arg: BEET_TYPE_ARG_LEN,\n    },\n};\n//# sourceMappingURL=collections.js.map"]},"metadata":{},"sourceType":"module"}