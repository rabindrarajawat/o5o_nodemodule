{"ast":null,"code":"import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport { getAccountLen } from '../extensions/extensionType.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n/** Token account state as stored by the program */\n\nexport var AccountState;\n\n(function (AccountState) {\n  AccountState[AccountState[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  AccountState[AccountState[\"Initialized\"] = 1] = \"Initialized\";\n  AccountState[AccountState[\"Frozen\"] = 2] = \"Frozen\";\n})(AccountState || (AccountState = {}));\n/** Buffer layout for de/serializing a token account */\n\n\nexport const AccountLayout = struct([publicKey('mint'), publicKey('owner'), u64('amount'), u32('delegateOption'), publicKey('delegate'), u8('state'), u32('isNativeOption'), u64('isNative'), u64('delegatedAmount'), u32('closeAuthorityOption'), publicKey('closeAuthority')]);\n/** Byte length of a token account */\n\nexport const ACCOUNT_SIZE = AccountLayout.span;\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\n\nexport async function getAccount(connection, address, commitment) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_PROGRAM_ID;\n  const info = await connection.getAccountInfo(address, commitment);\n  return unpackAccount(address, info, programId);\n}\n/**\n * Retrieve information about multiple token accounts in a single RPC call\n *\n * @param connection Connection to use\n * @param addresses  Token accounts\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\n\nexport async function getMultipleAccounts(connection, addresses, commitment) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_PROGRAM_ID;\n  const infos = await connection.getMultipleAccountsInfo(addresses, commitment);\n  return addresses.map((address, i) => unpackAccount(address, infos[i], programId));\n}\n/** Get the minimum lamport balance for a base token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nexport async function getMinimumBalanceForRentExemptAccount(connection, commitment) {\n  return await getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\n}\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nexport async function getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {\n  const accountLen = getAccountLen(extensions);\n  return await connection.getMinimumBalanceForRentExemption(accountLen, commitment);\n}\n/**\n * Unpack a token account\n *\n * @param address   Token account\n * @param info      Token account data\n * @param programId SPL Token program account\n *\n * @return Unpacked token account\n */\n\nexport function unpackAccount(address, info) {\n  let programId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TOKEN_PROGRAM_ID;\n  if (!info) throw new TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n  if (info.data.length < ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n  const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));\n  let tlvData = Buffer.alloc(0);\n\n  if (info.data.length > ACCOUNT_SIZE) {\n    if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n    if (info.data[ACCOUNT_SIZE] != AccountType.Account) throw new TokenInvalidAccountError();\n    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n  }\n\n  return {\n    address: address,\n    mint: rawAccount.mint,\n    owner: rawAccount.owner,\n    amount: rawAccount.amount,\n    delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n    delegatedAmount: rawAccount.delegatedAmount,\n    isInitialized: rawAccount.state !== AccountState.Uninitialized,\n    isFrozen: rawAccount.state === AccountState.Frozen,\n    isNative: !!rawAccount.isNativeOption,\n    rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n    closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n    tlvData: tlvData\n  };\n}","map":{"version":3,"sources":["../../../src/state/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError, } from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport { getAccountLen } from '../extensions/extensionType.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n/** Token account state as stored by the program */\nexport var AccountState;\n(function (AccountState) {\n    AccountState[AccountState[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    AccountState[AccountState[\"Initialized\"] = 1] = \"Initialized\";\n    AccountState[AccountState[\"Frozen\"] = 2] = \"Frozen\";\n})(AccountState || (AccountState = {}));\n/** Buffer layout for de/serializing a token account */\nexport const AccountLayout = struct([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    u32('delegateOption'),\n    publicKey('delegate'),\n    u8('state'),\n    u32('isNativeOption'),\n    u64('isNative'),\n    u64('delegatedAmount'),\n    u32('closeAuthorityOption'),\n    publicKey('closeAuthority'),\n]);\n/** Byte length of a token account */\nexport const ACCOUNT_SIZE = AccountLayout.span;\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getAccount(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackAccount(address, info, programId);\n}\n/**\n * Retrieve information about multiple token accounts in a single RPC call\n *\n * @param connection Connection to use\n * @param addresses  Token accounts\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getMultipleAccounts(connection, addresses, commitment, programId = TOKEN_PROGRAM_ID) {\n    const infos = await connection.getMultipleAccountsInfo(addresses, commitment);\n    return addresses.map((address, i) => unpackAccount(address, infos[i], programId));\n}\n/** Get the minimum lamport balance for a base token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccount(connection, commitment) {\n    return await getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\n}\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {\n    const accountLen = getAccountLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(accountLen, commitment);\n}\n/**\n * Unpack a token account\n *\n * @param address   Token account\n * @param info      Token account data\n * @param programId SPL Token program account\n *\n * @return Unpacked token account\n */\nexport function unpackAccount(address, info, programId = TOKEN_PROGRAM_ID) {\n    if (!info)\n        throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId))\n        throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < ACCOUNT_SIZE)\n        throw new TokenInvalidAccountSizeError();\n    const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > ACCOUNT_SIZE) {\n        if (info.data.length === MULTISIG_SIZE)\n            throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Account)\n            throw new TokenInvalidAccountError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n    return {\n        address,\n        mint: rawAccount.mint,\n        owner: rawAccount.owner,\n        amount: rawAccount.amount,\n        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n        delegatedAmount: rawAccount.delegatedAmount,\n        isInitialized: rawAccount.state !== AccountState.Uninitialized,\n        isFrozen: rawAccount.state === AccountState.Frozen,\n        isNative: !!rawAccount.isNativeOption,\n        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n        tlvData,\n    };\n}\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"module"}