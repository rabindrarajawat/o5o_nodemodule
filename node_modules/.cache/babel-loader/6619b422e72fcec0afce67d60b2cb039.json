{"ast":null,"code":"import { BEET_PACKAGE } from '../types';\nimport { strict as assert } from 'assert';\nimport { fixBeetFromData, fixBeetFromValue } from '../beet.fixable'; // Tuples are a special kind of composite which can be understood as\n// fixed length arrays where each tuple element can have a different data type.\n// Since the Tuple type itself dictates the length, and buffer layout, no extra\n// information is included in the serialized data.\n\n/**\n * De/Serializes a tuple with all fixed size tuple elements .\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n *\n * @category beet/composite\n */\n\nexport function fixedSizeTuple(elements) {\n  const len = elements.length;\n  const elDescs = elements.map(x => x.description);\n  const byteSizes = elements.map(x => x.byteSize);\n  const byteSize = byteSizes.reduce((acc, x) => acc + x, 0);\n  return {\n    write: function (buf, offset, value) {\n      assert.equal(value.length, len, `tuple value element size ${value.length} should match len ${len}`);\n      let cursor = offset;\n\n      for (let i = 0; i < len; i++) {\n        const v = value[i];\n        const beetEl = elements[i];\n        beetEl.write(buf, cursor, v);\n        cursor += beetEl.byteSize;\n      }\n    },\n    read: function (buf, offset) {\n      const els = [];\n      let cursor = offset;\n\n      for (let i = 0; i < len; i++) {\n        const elBeet = elements[i];\n        els[i] = elBeet.read(buf, cursor);\n        cursor += elBeet.byteSize;\n      }\n\n      return els;\n    },\n    byteSize,\n    length: len,\n    description: `FixedSizeTuple<${elDescs.join(',')}>[ ${byteSizes.join(', ')} ]`\n  };\n}\n/**\n * De/Serializes a tuple which contains some non-fixed size tuple elements.\n *\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n * @category beet/composite\n */\n\nexport function tuple(elements) {\n  const len = elements.length;\n  const elDescs = elements.map(x => x.description);\n  return {\n    toFixedFromData(buf, offset) {\n      let cursor = offset;\n      const fixedElements = new Array(len);\n\n      for (let i = 0; i < len; i++) {\n        const fixedElement = fixBeetFromData(elements[i], buf, cursor);\n        fixedElements[i] = fixedElement;\n        cursor += fixedElement.byteSize;\n      }\n\n      return fixedSizeTuple(fixedElements);\n    },\n\n    toFixedFromValue(vals) {\n      assert(Array.isArray(vals), `${vals} should be an array of tuple values`);\n      assert.equal(vals.length, len, `There should be ${len} tuple values, but there are ${vals.length}`);\n      const fixedElements = new Array(len);\n\n      for (let i = 0; i < vals.length; i++) {\n        const fixedElement = fixBeetFromValue(elements[i], vals[i]);\n        fixedElements[i] = fixedElement;\n      }\n\n      return fixedSizeTuple(fixedElements);\n    },\n\n    description: `Tuple<${elDescs.join(',')}>`\n  };\n}\n/**\n * Maps tuples beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexport const tuplesTypeMap = {\n  Tuple: {\n    beet: 'tuple',\n    isFixable: true,\n    sourcePack: BEET_PACKAGE,\n    ts: '[__tuple_elements__]'\n  },\n  FixedSizeTuple: {\n    beet: 'fixedSizeTuple',\n    isFixable: false,\n    sourcePack: BEET_PACKAGE,\n    ts: '[__tuple_elements__]'\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/tuples.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BEET_PACKAGE, } from '../types';\nimport { strict as assert } from 'assert';\nimport { fixBeetFromData, fixBeetFromValue } from '../beet.fixable';\n// Tuples are a special kind of composite which can be understood as\n// fixed length arrays where each tuple element can have a different data type.\n// Since the Tuple type itself dictates the length, and buffer layout, no extra\n// information is included in the serialized data.\n/**\n * De/Serializes a tuple with all fixed size tuple elements .\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n *\n * @category beet/composite\n */\nexport function fixedSizeTuple(elements) {\n    const len = elements.length;\n    const elDescs = elements.map((x) => x.description);\n    const byteSizes = elements.map((x) => x.byteSize);\n    const byteSize = byteSizes.reduce((acc, x) => acc + x, 0);\n    return {\n        write: function (buf, offset, value) {\n            assert.equal(value.length, len, `tuple value element size ${value.length} should match len ${len}`);\n            let cursor = offset;\n            for (let i = 0; i < len; i++) {\n                const v = value[i];\n                const beetEl = elements[i];\n                beetEl.write(buf, cursor, v);\n                cursor += beetEl.byteSize;\n            }\n        },\n        read: function (buf, offset) {\n            const els = [];\n            let cursor = offset;\n            for (let i = 0; i < len; i++) {\n                const elBeet = elements[i];\n                els[i] = elBeet.read(buf, cursor);\n                cursor += elBeet.byteSize;\n            }\n            return els;\n        },\n        byteSize,\n        length: len,\n        description: `FixedSizeTuple<${elDescs.join(',')}>[ ${byteSizes.join(', ')} ]`,\n    };\n}\n/**\n * De/Serializes a tuple which contains some non-fixed size tuple elements.\n *\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n * @category beet/composite\n */\nexport function tuple(elements) {\n    const len = elements.length;\n    const elDescs = elements.map((x) => x.description);\n    return {\n        toFixedFromData(buf, offset) {\n            let cursor = offset;\n            const fixedElements = new Array(len);\n            for (let i = 0; i < len; i++) {\n                const fixedElement = fixBeetFromData(elements[i], buf, cursor);\n                fixedElements[i] = fixedElement;\n                cursor += fixedElement.byteSize;\n            }\n            return fixedSizeTuple(fixedElements);\n        },\n        toFixedFromValue(vals) {\n            assert(Array.isArray(vals), `${vals} should be an array of tuple values`);\n            assert.equal(vals.length, len, `There should be ${len} tuple values, but there are ${vals.length}`);\n            const fixedElements = new Array(len);\n            for (let i = 0; i < vals.length; i++) {\n                const fixedElement = fixBeetFromValue(elements[i], vals[i]);\n                fixedElements[i] = fixedElement;\n            }\n            return fixedSizeTuple(fixedElements);\n        },\n        description: `Tuple<${elDescs.join(',')}>`,\n    };\n}\n/**\n * Maps tuples beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexport const tuplesTypeMap = {\n    Tuple: {\n        beet: 'tuple',\n        isFixable: true,\n        sourcePack: BEET_PACKAGE,\n        ts: '[__tuple_elements__]',\n    },\n    FixedSizeTuple: {\n        beet: 'fixedSizeTuple',\n        isFixable: false,\n        sourcePack: BEET_PACKAGE,\n        ts: '[__tuple_elements__]',\n    },\n};\n//# sourceMappingURL=tuples.js.map"]},"metadata":{},"sourceType":"module"}