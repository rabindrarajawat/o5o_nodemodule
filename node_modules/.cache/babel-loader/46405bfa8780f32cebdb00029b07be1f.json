{"ast":null,"code":"import { getSignerHistogram } from '../../types/Signer.mjs';\nimport { FailedToConfirmTransactionError, FailedToConfirmTransactionWithResponseError, FailedToSendTransactionError } from '../../errors/RpcError.mjs';\nimport { lamports, assertSol } from '../../types/Amount.mjs';\nimport { isErrorWithLogs } from '../../types/Program.mjs';\nimport { UnknownProgramError, ParsedProgramError } from '../../errors/ProgramError.mjs';\nimport { zipMap } from '../../utils/common.mjs';\n/**\n * @group Modules\n */\n\nclass RpcClient {\n  constructor(metaplex) {\n    this.metaplex = metaplex;\n  }\n\n  async prepareTransaction(transaction, signers) {\n    let blockhashWithExpiryBlockHeight;\n\n    if (!('records' in transaction) && transaction.recentBlockhash && transaction.lastValidBlockHeight) {\n      blockhashWithExpiryBlockHeight = {\n        blockhash: transaction.recentBlockhash,\n        lastValidBlockHeight: transaction.lastValidBlockHeight\n      };\n    } else {\n      blockhashWithExpiryBlockHeight = await this.getLatestBlockhash();\n    }\n\n    if ('records' in transaction) {\n      signers = [...transaction.getSigners(), ...signers];\n      transaction = transaction.toTransaction(blockhashWithExpiryBlockHeight);\n    }\n\n    return {\n      transaction,\n      signers,\n      blockhashWithExpiryBlockHeight\n    };\n  }\n\n  async signTransaction(transaction, signers) {\n    const {\n      keypairs,\n      identities\n    } = getSignerHistogram(signers); // Keypair signers.\n\n    if (keypairs.length > 0) {\n      transaction.partialSign(...keypairs);\n    } // Identity signers.\n\n\n    for (let i = 0; i < identities.length; i++) {\n      transaction = await identities[i].signTransaction(transaction);\n    }\n\n    return transaction;\n  }\n\n  async sendTransaction(transaction) {\n    let sendOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let signers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    const prepared = await this.prepareTransaction(transaction, signers);\n    transaction = prepared.transaction;\n    signers = prepared.signers;\n    const defaultFeePayer = this.getDefaultFeePayer();\n\n    if (!transaction.feePayer && defaultFeePayer) {\n      transaction.feePayer = defaultFeePayer.publicKey;\n      signers = [defaultFeePayer, ...signers];\n    }\n\n    transaction = await this.signTransaction(transaction, signers);\n    const rawTransaction = transaction.serialize();\n\n    try {\n      return await this.metaplex.connection.sendRawTransaction(rawTransaction, sendOptions);\n    } catch (error) {\n      throw this.parseProgramError(error, transaction);\n    }\n  }\n\n  async confirmTransaction(signature, blockhashWithExpiryBlockHeight, commitment) {\n    let rpcResponse;\n\n    try {\n      rpcResponse = await this.metaplex.connection.confirmTransaction({\n        signature,\n        ...blockhashWithExpiryBlockHeight\n      }, commitment);\n    } catch (error) {\n      throw new FailedToConfirmTransactionError(error);\n    }\n\n    if (rpcResponse.value.err) {\n      throw new FailedToConfirmTransactionWithResponseError(rpcResponse);\n    }\n\n    return rpcResponse;\n  }\n\n  async sendAndConfirmTransaction(transaction, confirmOptions) {\n    let signers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    const prepared = await this.prepareTransaction(transaction, signers);\n    const {\n      blockhashWithExpiryBlockHeight\n    } = prepared;\n    transaction = prepared.transaction;\n    signers = prepared.signers;\n    const signature = await this.sendTransaction(transaction, confirmOptions, signers);\n    const confirmResponse = await this.confirmTransaction(signature, blockhashWithExpiryBlockHeight, confirmOptions?.commitment);\n    return {\n      signature,\n      confirmResponse,\n      ...blockhashWithExpiryBlockHeight\n    };\n  }\n\n  async getAccount(publicKey, commitment) {\n    const accountInfo = await this.metaplex.connection.getAccountInfo(publicKey, commitment);\n    return this.getUnparsedMaybeAccount(publicKey, accountInfo);\n  }\n\n  async accountExists(publicKey, commitment) {\n    const balance = await this.metaplex.connection.getBalance(publicKey, commitment);\n    return balance > 0;\n  }\n\n  async getMultipleAccounts(publicKeys, commitment) {\n    const accountInfos = await this.metaplex.connection.getMultipleAccountsInfo(publicKeys, commitment);\n    return zipMap(publicKeys, accountInfos, (publicKey, accountInfo) => {\n      return this.getUnparsedMaybeAccount(publicKey, accountInfo);\n    });\n  }\n\n  async getProgramAccounts(programId, configOrCommitment) {\n    const accounts = await this.metaplex.connection.getProgramAccounts(programId, configOrCommitment);\n    return accounts.map(_ref => {\n      let {\n        pubkey,\n        account\n      } = _ref;\n      return { ...account,\n        publicKey: pubkey,\n        lamports: lamports(account.lamports)\n      };\n    });\n  }\n\n  async airdrop(publicKey, amount, commitment) {\n    assertSol(amount);\n    const signature = await this.metaplex.connection.requestAirdrop(publicKey, amount.basisPoints.toNumber());\n    const blockhashWithExpiryBlockHeight = await this.getLatestBlockhash();\n    const confirmResponse = await this.confirmTransaction(signature, blockhashWithExpiryBlockHeight, commitment);\n    return {\n      signature,\n      confirmResponse,\n      ...blockhashWithExpiryBlockHeight\n    };\n  }\n\n  async getBalance(publicKey, commitment) {\n    const balance = await this.metaplex.connection.getBalance(publicKey, commitment);\n    return lamports(balance);\n  }\n\n  async getRent(bytes, commitment) {\n    const rent = await this.metaplex.connection.getMinimumBalanceForRentExemption(bytes, commitment);\n    return lamports(rent);\n  }\n\n  async getLatestBlockhash() {\n    let commitmentOrConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'finalized';\n    return this.metaplex.connection.getLatestBlockhash(commitmentOrConfig);\n  }\n\n  getSolanaExporerUrl(signature) {\n    let clusterParam = '';\n\n    switch (this.metaplex.cluster) {\n      case 'devnet':\n        clusterParam = '?cluster=devnet';\n        break;\n\n      case 'testnet':\n        clusterParam = '?cluster=testnet';\n        break;\n\n      case 'localnet':\n      case 'custom':\n        const url = encodeURIComponent(this.metaplex.connection.rpcEndpoint);\n        clusterParam = `?cluster=custom&customUrl=${url}`;\n        break;\n    }\n\n    return `https://explorer.solana.com/tx/${signature}${clusterParam}`;\n  }\n\n  setDefaultFeePayer(payer) {\n    this.defaultFeePayer = payer;\n    return this;\n  }\n\n  getDefaultFeePayer() {\n    return this.defaultFeePayer ? this.defaultFeePayer : this.metaplex.identity();\n  }\n\n  getUnparsedMaybeAccount(publicKey, accountInfo) {\n    if (!accountInfo) {\n      return {\n        publicKey,\n        exists: false\n      };\n    }\n\n    return { ...accountInfo,\n      publicKey,\n      exists: true,\n      lamports: lamports(accountInfo.lamports)\n    };\n  }\n\n  parseProgramError(error, transaction) {\n    // Ensure the error as logs.\n    if (!isErrorWithLogs(error)) {\n      return new FailedToSendTransactionError(error);\n    } // Parse the instruction number.\n\n\n    const regex = /Error processing Instruction (\\d+):/;\n    const instruction = error.message.match(regex)?.[1] ?? null; // Ensure there is an instruction number given to find the program.\n\n    if (!instruction) {\n      return new FailedToSendTransactionError(error);\n    } // Get the program ID from the instruction in the transaction.\n\n\n    const instructionNumber = parseInt(instruction, 10);\n    const programId = transaction.instructions?.[instructionNumber]?.programId ?? null; // Ensure we were able to find a program ID for the instruction.\n\n    if (!programId) {\n      return new FailedToSendTransactionError(error);\n    } // Find a registered program if any.\n\n\n    let program;\n\n    try {\n      program = this.metaplex.programs().get(programId);\n    } catch (_programNotFoundError) {\n      return new FailedToSendTransactionError(error);\n    } // Ensure an error resolver exists on the program.\n\n\n    if (!program.errorResolver) {\n      return new UnknownProgramError(program, error);\n    } // Finally, resolve the error.\n\n\n    const resolvedError = program.errorResolver(error);\n    return resolvedError ? new ParsedProgramError(program, resolvedError, error.logs) : new UnknownProgramError(program, error);\n  }\n\n}\n\nexport { RpcClient };","map":{"version":3,"sources":["../../../../src/plugins/rpcModule/RpcClient.ts"],"names":["RpcClient","constructor","metaplex","prepareTransaction","transaction","signers","blockhashWithExpiryBlockHeight","recentBlockhash","lastValidBlockHeight","blockhash","getLatestBlockhash","getSigners","toTransaction","signTransaction","keypairs","identities","getSignerHistogram","length","partialSign","i","sendTransaction","sendOptions","prepared","defaultFeePayer","getDefaultFeePayer","feePayer","publicKey","rawTransaction","serialize","connection","sendRawTransaction","error","parseProgramError","confirmTransaction","signature","commitment","rpcResponse","FailedToConfirmTransactionError","value","err","FailedToConfirmTransactionWithResponseError","sendAndConfirmTransaction","confirmOptions","confirmResponse","getAccount","accountInfo","getAccountInfo","getUnparsedMaybeAccount","accountExists","balance","getBalance","getMultipleAccounts","publicKeys","accountInfos","getMultipleAccountsInfo","zipMap","getProgramAccounts","programId","configOrCommitment","accounts","map","pubkey","account","lamports","airdrop","amount","assertSol","requestAirdrop","basisPoints","toNumber","getRent","bytes","rent","getMinimumBalanceForRentExemption","commitmentOrConfig","getSolanaExporerUrl","clusterParam","cluster","url","encodeURIComponent","rpcEndpoint","setDefaultFeePayer","payer","identity","exists","isErrorWithLogs","FailedToSendTransactionError","regex","instruction","message","match","instructionNumber","parseInt","instructions","program","programs","get","_programNotFoundError","errorResolver","UnknownProgramError","resolvedError","ParsedProgramError","logs"],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\nimport {\n  AccountInfo,\n  Blockhash,\n  BlockhashWithExpiryBlockHeight,\n  Commitment,\n  ConfirmOptions,\n  GetLatestBlockhashConfig,\n  GetProgramAccountsConfig,\n  PublicKey,\n  RpcResponseAndContext,\n  SendOptions,\n  SignatureResult,\n  Transaction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport {\n  FailedToConfirmTransactionError,\n  FailedToConfirmTransactionWithResponseError,\n  FailedToSendTransactionError,\n  MetaplexError,\n  ParsedProgramError,\n  UnknownProgramError,\n} from '@/errors';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  assertSol,\n  getSignerHistogram,\n  isErrorWithLogs,\n  lamports,\n  Program,\n  Signer,\n  SolAmount,\n  UnparsedAccount,\n  UnparsedMaybeAccount,\n} from '@/types';\nimport { TransactionBuilder, zipMap } from '@/utils';\n\nexport type ConfirmTransactionResponse = RpcResponseAndContext<SignatureResult>;\nexport type SendAndConfirmTransactionResponse = {\n  signature: TransactionSignature;\n  confirmResponse: ConfirmTransactionResponse;\n  blockhash: Blockhash;\n  lastValidBlockHeight: number;\n};\n\n/**\n * @group Modules\n */\nexport class RpcClient {\n  protected defaultFeePayer?: Signer;\n\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  protected async prepareTransaction(\n    transaction: Transaction | TransactionBuilder,\n    signers: Signer[]\n  ): Promise<{\n    transaction: Transaction;\n    signers: Signer[];\n    blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight;\n  }> {\n    let blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight;\n    if (\n      !('records' in transaction) &&\n      transaction.recentBlockhash &&\n      transaction.lastValidBlockHeight\n    ) {\n      blockhashWithExpiryBlockHeight = {\n        blockhash: transaction.recentBlockhash,\n        lastValidBlockHeight: transaction.lastValidBlockHeight,\n      };\n    } else {\n      blockhashWithExpiryBlockHeight = await this.getLatestBlockhash();\n    }\n\n    if ('records' in transaction) {\n      signers = [...transaction.getSigners(), ...signers];\n      transaction = transaction.toTransaction(blockhashWithExpiryBlockHeight);\n    }\n\n    return { transaction, signers, blockhashWithExpiryBlockHeight };\n  }\n\n  async signTransaction(\n    transaction: Transaction,\n    signers: Signer[]\n  ): Promise<Transaction> {\n    const { keypairs, identities } = getSignerHistogram(signers);\n\n    // Keypair signers.\n    if (keypairs.length > 0) {\n      transaction.partialSign(...keypairs);\n    }\n\n    // Identity signers.\n    for (let i = 0; i < identities.length; i++) {\n      transaction = await identities[i].signTransaction(transaction);\n    }\n\n    return transaction;\n  }\n\n  async sendTransaction(\n    transaction: Transaction | TransactionBuilder,\n    sendOptions: SendOptions = {},\n    signers: Signer[] = []\n  ): Promise<TransactionSignature> {\n    const prepared = await this.prepareTransaction(transaction, signers);\n    transaction = prepared.transaction;\n    signers = prepared.signers;\n\n    const defaultFeePayer = this.getDefaultFeePayer();\n    if (!transaction.feePayer && defaultFeePayer) {\n      transaction.feePayer = defaultFeePayer.publicKey;\n      signers = [defaultFeePayer, ...signers];\n    }\n\n    transaction = await this.signTransaction(transaction, signers);\n    const rawTransaction = transaction.serialize();\n\n    try {\n      return await this.metaplex.connection.sendRawTransaction(\n        rawTransaction,\n        sendOptions\n      );\n    } catch (error) {\n      throw this.parseProgramError(error, transaction);\n    }\n  }\n\n  async confirmTransaction(\n    signature: TransactionSignature,\n    blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight,\n    commitment?: Commitment\n  ): Promise<ConfirmTransactionResponse> {\n    let rpcResponse: ConfirmTransactionResponse;\n    try {\n      rpcResponse = await this.metaplex.connection.confirmTransaction(\n        { signature, ...blockhashWithExpiryBlockHeight },\n        commitment\n      );\n    } catch (error) {\n      throw new FailedToConfirmTransactionError(error as Error);\n    }\n\n    if (rpcResponse.value.err) {\n      throw new FailedToConfirmTransactionWithResponseError(rpcResponse);\n    }\n\n    return rpcResponse;\n  }\n\n  async sendAndConfirmTransaction(\n    transaction: Transaction | TransactionBuilder,\n    confirmOptions?: ConfirmOptions,\n    signers: Signer[] = []\n  ): Promise<SendAndConfirmTransactionResponse> {\n    const prepared = await this.prepareTransaction(transaction, signers);\n    const { blockhashWithExpiryBlockHeight } = prepared;\n    transaction = prepared.transaction;\n    signers = prepared.signers;\n\n    const signature = await this.sendTransaction(\n      transaction,\n      confirmOptions,\n      signers\n    );\n\n    const confirmResponse = await this.confirmTransaction(\n      signature,\n      blockhashWithExpiryBlockHeight,\n      confirmOptions?.commitment\n    );\n\n    return { signature, confirmResponse, ...blockhashWithExpiryBlockHeight };\n  }\n\n  async getAccount(publicKey: PublicKey, commitment?: Commitment) {\n    const accountInfo = await this.metaplex.connection.getAccountInfo(\n      publicKey,\n      commitment\n    );\n\n    return this.getUnparsedMaybeAccount(publicKey, accountInfo);\n  }\n\n  async accountExists(publicKey: PublicKey, commitment?: Commitment) {\n    const balance = await this.metaplex.connection.getBalance(\n      publicKey,\n      commitment\n    );\n\n    return balance > 0;\n  }\n\n  async getMultipleAccounts(publicKeys: PublicKey[], commitment?: Commitment) {\n    const accountInfos = await this.metaplex.connection.getMultipleAccountsInfo(\n      publicKeys,\n      commitment\n    );\n\n    return zipMap(publicKeys, accountInfos, (publicKey, accountInfo) => {\n      return this.getUnparsedMaybeAccount(publicKey, accountInfo);\n    });\n  }\n\n  async getProgramAccounts(\n    programId: PublicKey,\n    configOrCommitment?: GetProgramAccountsConfig | Commitment\n  ): Promise<UnparsedAccount[]> {\n    const accounts = await this.metaplex.connection.getProgramAccounts(\n      programId,\n      configOrCommitment\n    );\n\n    return accounts.map(({ pubkey, account }) => ({\n      ...account,\n      publicKey: pubkey,\n      lamports: lamports(account.lamports),\n    }));\n  }\n\n  async airdrop(\n    publicKey: PublicKey,\n    amount: SolAmount,\n    commitment?: Commitment\n  ): Promise<SendAndConfirmTransactionResponse> {\n    assertSol(amount);\n\n    const signature = await this.metaplex.connection.requestAirdrop(\n      publicKey,\n      amount.basisPoints.toNumber()\n    );\n\n    const blockhashWithExpiryBlockHeight = await this.getLatestBlockhash();\n    const confirmResponse = await this.confirmTransaction(\n      signature,\n      blockhashWithExpiryBlockHeight,\n      commitment\n    );\n\n    return { signature, confirmResponse, ...blockhashWithExpiryBlockHeight };\n  }\n\n  async getBalance(\n    publicKey: PublicKey,\n    commitment?: Commitment\n  ): Promise<SolAmount> {\n    const balance = await this.metaplex.connection.getBalance(\n      publicKey,\n      commitment\n    );\n\n    return lamports(balance);\n  }\n\n  async getRent(bytes: number, commitment?: Commitment): Promise<SolAmount> {\n    const rent =\n      await this.metaplex.connection.getMinimumBalanceForRentExemption(\n        bytes,\n        commitment\n      );\n\n    return lamports(rent);\n  }\n\n  async getLatestBlockhash(\n    commitmentOrConfig: Commitment | GetLatestBlockhashConfig = 'finalized'\n  ): Promise<BlockhashWithExpiryBlockHeight> {\n    return this.metaplex.connection.getLatestBlockhash(commitmentOrConfig);\n  }\n\n  getSolanaExporerUrl(signature: string): string {\n    let clusterParam = '';\n    switch (this.metaplex.cluster) {\n      case 'devnet':\n        clusterParam = '?cluster=devnet';\n        break;\n      case 'testnet':\n        clusterParam = '?cluster=testnet';\n        break;\n      case 'localnet':\n      case 'custom':\n        const url = encodeURIComponent(this.metaplex.connection.rpcEndpoint);\n        clusterParam = `?cluster=custom&customUrl=${url}`;\n        break;\n    }\n\n    return `https://explorer.solana.com/tx/${signature}${clusterParam}`;\n  }\n\n  setDefaultFeePayer(payer: Signer) {\n    this.defaultFeePayer = payer;\n\n    return this;\n  }\n\n  getDefaultFeePayer(): Signer {\n    return this.defaultFeePayer\n      ? this.defaultFeePayer\n      : this.metaplex.identity();\n  }\n\n  protected getUnparsedMaybeAccount(\n    publicKey: PublicKey,\n    accountInfo: AccountInfo<Buffer> | null\n  ): UnparsedMaybeAccount {\n    if (!accountInfo) {\n      return { publicKey, exists: false };\n    }\n\n    return {\n      ...accountInfo,\n      publicKey,\n      exists: true,\n      lamports: lamports(accountInfo.lamports),\n    };\n  }\n\n  protected parseProgramError(\n    error: unknown,\n    transaction: Transaction\n  ): MetaplexError {\n    // Ensure the error as logs.\n    if (!isErrorWithLogs(error)) {\n      return new FailedToSendTransactionError(error as Error);\n    }\n\n    // Parse the instruction number.\n    const regex = /Error processing Instruction (\\d+):/;\n    const instruction: string | null = error.message.match(regex)?.[1] ?? null;\n\n    // Ensure there is an instruction number given to find the program.\n    if (!instruction) {\n      return new FailedToSendTransactionError(error);\n    }\n\n    // Get the program ID from the instruction in the transaction.\n    const instructionNumber: number = parseInt(instruction, 10);\n    const programId: PublicKey | null =\n      transaction.instructions?.[instructionNumber]?.programId ?? null;\n\n    // Ensure we were able to find a program ID for the instruction.\n    if (!programId) {\n      return new FailedToSendTransactionError(error);\n    }\n\n    // Find a registered program if any.\n    let program: Program;\n    try {\n      program = this.metaplex.programs().get(programId);\n    } catch (_programNotFoundError) {\n      return new FailedToSendTransactionError(error);\n    }\n\n    // Ensure an error resolver exists on the program.\n    if (!program.errorResolver) {\n      return new UnknownProgramError(program, error);\n    }\n\n    // Finally, resolve the error.\n    const resolvedError = program.errorResolver(error);\n\n    return resolvedError\n      ? new ParsedProgramError(program, resolvedError, error.logs)\n      : new UnknownProgramError(program, error);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}