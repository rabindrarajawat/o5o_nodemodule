{"ast":null,"code":"import { Transaction } from '@solana/web3.js';\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\nexport const getErrorForTransaction = async (connection, txid) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n  const errors = [];\n\n  if (tx !== null && tx !== void 0 && tx.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\nexport let SequenceType;\n\n(function (SequenceType) {\n  SequenceType[SequenceType[\"Sequential\"] = 0] = \"Sequential\";\n  SequenceType[SequenceType[\"Parallel\"] = 1] = \"Parallel\";\n  SequenceType[SequenceType[\"StopOnFailure\"] = 2] = \"StopOnFailure\";\n})(SequenceType || (SequenceType = {}));\n\nexport const sendTransactions = async function (connection, wallet, instructionSet, signersSet) {\n  let sequenceType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : SequenceType.Parallel;\n  let commitment = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'singleGossip';\n  let block = arguments.length > 6 ? arguments[6] : undefined;\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  const unsignedTxns = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n  const pendingTxns = [];\n  let breakEarlyObject = {\n    breakEarly: false,\n    i: 0\n  };\n  console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);\n  const txIds = [];\n\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection: connection,\n      signedTransaction: signedTxns[i]\n    });\n\n    try {\n      const {\n        txid: txid\n      } = await signedTxnPromise;\n      txIds.push(txid);\n    } catch (error) {\n      console.error(error); // @ts-ignore\n\n      failCallback(signedTxns[i], i);\n\n      if (sequenceType === SequenceType.StopOnFailure) {\n        breakEarlyObject.breakEarly = true;\n        breakEarlyObject.i = i;\n      }\n    }\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log('Caught failure', e);\n\n        if (breakEarlyObject.breakEarly) {\n          console.log('Died on ', breakEarlyObject.i);\n          return breakEarlyObject.i; // Return the txn we failed on by index\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    await Promise.all(pendingTxns);\n  }\n\n  return txIds;\n};\nexport const sendTransaction = async function (connection, wallet, instructions, signers) {\n  let awaitConfirmation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  let commitment = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'singleGossip';\n  let includesFeePayer = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  let block = arguments.length > 7 ? arguments[7] : undefined;\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment: commitment\n  };\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, DEFAULT_TIMEOUT, connection, commitment);\n    if (!confirmation) throw new Error('Timed out awaiting confirmation on transaction');\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n\n    if (confirmation !== null && confirmation !== void 0 && confirmation.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return {\n    txid: txid,\n    slot: slot\n  };\n};\nexport const sendTransactionWithRetry = async function (connection, wallet, instructions, signers) {\n  let commitment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'singleGossip';\n  let includesFeePayer = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let block = arguments.length > 6 ? arguments[6] : undefined;\n  let beforeSend = arguments.length > 7 ? arguments[7] : undefined;\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const {\n    txid: txid,\n    slot: slot\n  } = await sendSignedTransaction({\n    connection: connection,\n    signedTransaction: transaction\n  });\n  return {\n    txid: txid,\n    slot: slot\n  };\n};\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\nconst DEFAULT_TIMEOUT = 15000;\nexport async function sendSignedTransaction(_ref) {\n  let {\n    signedTransaction: signedTransaction,\n    connection: connection,\n    timeout = DEFAULT_TIMEOUT\n  } = _ref;\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true\n  });\n  console.log('Started awaiting confirmation for', txid);\n  let done = false;\n\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true\n      });\n      await sleep(500);\n    }\n  })();\n\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, timeout, connection, 'recent', true);\n    if (!confirmation) throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n  } catch (err) {\n    console.error('Timeout Error caught', err);\n\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n\n    let simulateResult = null;\n\n    try {\n      simulateResult = (await simulateTransaction(connection, signedTransaction, 'single')).value;\n    } catch (e) {}\n\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n\n          if (line.startsWith('Program log: ')) {\n            throw new Error('Transaction failed: ' + line.slice('Program log: '.length));\n          }\n        }\n      }\n\n      throw new Error(JSON.stringify(simulateResult.err));\n    } // throw new Error('Transaction failed');\n\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return {\n    txid: txid,\n    slot: slot\n  };\n}\n\nasync function simulateTransaction(connection, transaction, commitment) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash( // @ts-ignore\n  connection._disableBlockhashCaching);\n  const signData = transaction.serializeMessage(); // @ts-ignore\n\n  const wireTransaction = transaction._serialize(signData);\n\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config = {\n    encoding: 'base64',\n    commitment: commitment\n  };\n  const args = [encodedTransaction, config]; // @ts-ignore\n\n  const res = await connection._rpcRequest('simulateTransaction', args);\n\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(txid, timeout, connection) {\n  let commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'recent';\n  let queryStatus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({\n        timeout: true\n      });\n    }, timeout);\n\n    try {\n      subId = connection.onSignature(txid, (result, context) => {\n        done = true;\n        status = {\n          err: result.err,\n          slot: context.slot,\n          confirmations: 0\n        };\n\n        if (result.err) {\n          console.log('Rejected via websocket', result.err);\n          reject(status);\n        } else {\n          console.log('Resolved via websocket', result);\n          resolve(status);\n        }\n      }, commitment);\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n\n      await sleep(2000);\n    }\n  }); //@ts-ignore\n\n  if (connection._signatureSubscriptions[subId]) connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\n\nexport function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nexport function printLog(log) {\n  console.log(\"[dev-log]--->\", log);\n}","map":{"version":3,"names":["Transaction","WalletNotConnectedError","getErrorForTransaction","connection","txid","confirmTransaction","tx","getParsedConfirmedTransaction","errors","meta","logMessages","forEach","log","regex","m","exec","index","lastIndex","length","push","SequenceType","sendTransactions","wallet","instructionSet","signersSet","sequenceType","Parallel","commitment","block","publicKey","unsignedTxns","getRecentBlockhash","i","instructions","signers","transaction","instruction","add","recentBlockhash","blockhash","setSigners","map","s","partialSign","signedTxns","signAllTransactions","pendingTxns","breakEarlyObject","breakEarly","console","txIds","signedTxnPromise","sendSignedTransaction","signedTransaction","error","failCallback","StopOnFailure","e","Promise","all","sendTransaction","awaitConfirmation","includesFeePayer","signTransaction","rawTransaction","serialize","options","skipPreflight","sendRawTransaction","slot","confirmation","awaitTransactionSignatureConfirmation","DEFAULT_TIMEOUT","Error","err","sendTransactionWithRetry","beforeSend","getUnixTs","Date","getTime","timeout","startTime","done","sleep","simulateResult","simulateTransaction","value","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","encoding","args","res","_rpcRequest","message","result","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","signatureStatuses","getSignatureStatuses","_signatureSubscriptions","removeSignatureListener","ms","printLog"],"sources":["D:/software/o5o BNB/o5o-staking-frontend/src/utils/utility.ts"],"sourcesContent":["import {\r\n  Keypair,\r\n  Commitment,\r\n  Connection,\r\n  RpcResponseAndContext,\r\n  SignatureStatus,\r\n  SimulatedTransactionResponse,\r\n  Transaction,\r\n  TransactionInstruction,\r\n  TransactionSignature,\r\n  Blockhash,\r\n  FeeCalculator,\r\n} from '@solana/web3.js';\r\n\r\nimport {\r\n  WalletNotConnectedError,\r\n} from '@solana/wallet-adapter-base';\r\n\r\ninterface BlockhashAndFeeCalculator {\r\n  blockhash: Blockhash;\r\n  feeCalculator: FeeCalculator;\r\n}\r\n\r\nexport const getErrorForTransaction = async (\r\n  connection: Connection,\r\n  txid: string,\r\n) => {\r\n  // wait for all confirmation before geting transaction\r\n  await connection.confirmTransaction(txid, 'max');\r\n\r\n  const tx = await connection.getParsedConfirmedTransaction(txid);\r\n\r\n  const errors: string[] = [];\r\n  if (tx?.meta && tx.meta.logMessages) {\r\n    tx.meta.logMessages.forEach(log => {\r\n      const regex = /Error: (.*)/gm;\r\n      let m;\r\n      while ((m = regex.exec(log)) !== null) {\r\n        // This is necessary to avoid infinite loops with zero-width matches\r\n        if (m.index === regex.lastIndex) {\r\n          regex.lastIndex++;\r\n        }\r\n\r\n        if (m.length > 1) {\r\n          errors.push(m[1]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  return errors;\r\n};\r\n\r\nexport enum SequenceType {\r\n  Sequential,\r\n  Parallel,\r\n  StopOnFailure,\r\n}\r\n\r\nexport const sendTransactions = async (\r\n  connection: Connection,\r\n  wallet: any,\r\n  instructionSet: TransactionInstruction[][],\r\n  signersSet: Keypair[][],\r\n  sequenceType: SequenceType = SequenceType.Parallel,\r\n  commitment: Commitment = 'singleGossip',\r\n  block?: BlockhashAndFeeCalculator,\r\n): Promise<string[] | number> => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  const unsignedTxns: Transaction[] = [];\r\n\r\n  if (!block) {\r\n    block = await connection.getRecentBlockhash(commitment);\r\n  }\r\n\r\n  for (let i = 0; i < instructionSet.length; i++) {\r\n    const instructions = instructionSet[i];\r\n    const signers = signersSet[i];\r\n\r\n    if (instructions.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    let transaction = new Transaction();\r\n    instructions.forEach(instruction => transaction.add(instruction));\r\n    transaction.recentBlockhash = block.blockhash;\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map(s => s.publicKey),\r\n    );\r\n\r\n    if (signers.length > 0) {\r\n      transaction.partialSign(...signers);\r\n    }\r\n\r\n    unsignedTxns.push(transaction);\r\n  }\r\n\r\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\r\n\r\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\r\n\r\n  let breakEarlyObject = { breakEarly: false, i: 0 };\r\n  console.log(\r\n    'Signed txns length',\r\n    signedTxns.length,\r\n    'vs handed in length',\r\n    instructionSet.length,\r\n  );\r\n\r\n  const txIds = []\r\n  for (let i = 0; i < signedTxns.length; i++) {\r\n    const signedTxnPromise = sendSignedTransaction({\r\n      connection,\r\n      signedTransaction: signedTxns[i],\r\n    });\r\n\r\n    try {\r\n      const { txid } = await signedTxnPromise\r\n      txIds.push(txid)\r\n    } catch (error) {\r\n      console.error(error)\r\n      // @ts-ignore\r\n      failCallback(signedTxns[i], i);\r\n      if (sequenceType === SequenceType.StopOnFailure) {\r\n        breakEarlyObject.breakEarly = true;\r\n        breakEarlyObject.i = i;\r\n      }\r\n    }\r\n\r\n    if (sequenceType !== SequenceType.Parallel) {\r\n      try {\r\n        await signedTxnPromise;\r\n      } catch (e) {\r\n        console.log('Caught failure', e);\r\n        if (breakEarlyObject.breakEarly) {\r\n          console.log('Died on ', breakEarlyObject.i);\r\n          return breakEarlyObject.i; // Return the txn we failed on by index\r\n        }\r\n      }\r\n    } else {\r\n      pendingTxns.push(signedTxnPromise);\r\n    }\r\n  }\r\n\r\n  if (sequenceType !== SequenceType.Parallel) {\r\n    await Promise.all(pendingTxns);\r\n  }\r\n\r\n  return txIds;\r\n};\r\n\r\nexport const sendTransaction = async (\r\n  connection: Connection,\r\n  wallet: any,\r\n  instructions: TransactionInstruction[],\r\n  signers: Keypair[],\r\n  awaitConfirmation = true,\r\n  commitment: Commitment = 'singleGossip',\r\n  includesFeePayer: boolean = false,\r\n  block?: BlockhashAndFeeCalculator,\r\n) => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  let transaction = new Transaction();\r\n  instructions.forEach(instruction => transaction.add(instruction));\r\n  transaction.recentBlockhash = (\r\n    block || (await connection.getRecentBlockhash(commitment))\r\n  ).blockhash;\r\n\r\n  if (includesFeePayer) {\r\n    transaction.setSigners(...signers.map(s => s.publicKey));\r\n  } else {\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map(s => s.publicKey),\r\n    );\r\n  }\r\n\r\n  if (signers.length > 0) {\r\n    transaction.partialSign(...signers);\r\n  }\r\n  if (!includesFeePayer) {\r\n    transaction = await wallet.signTransaction(transaction);\r\n  }\r\n\r\n  const rawTransaction = transaction.serialize();\r\n  let options = {\r\n    skipPreflight: true,\r\n    commitment,\r\n  };\r\n\r\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\r\n  let slot = 0;\r\n\r\n  if (awaitConfirmation) {\r\n    const confirmation = await awaitTransactionSignatureConfirmation(\r\n      txid,\r\n      DEFAULT_TIMEOUT,\r\n      connection,\r\n      commitment,\r\n    );\r\n\r\n    if (!confirmation)\r\n      throw new Error('Timed out awaiting confirmation on transaction');\r\n    slot = confirmation?.slot || 0;\r\n\r\n    if (confirmation?.err) {\r\n      const errors = await getErrorForTransaction(connection, txid);\r\n\r\n      console.log(errors);\r\n      throw new Error(`Raw transaction ${txid} failed`);\r\n    }\r\n  }\r\n\r\n  return { txid, slot };\r\n};\r\n\r\nexport const sendTransactionWithRetry = async (\r\n  connection: Connection,\r\n  wallet: any,\r\n  instructions: TransactionInstruction[],\r\n  signers: Keypair[],\r\n  commitment: Commitment = 'singleGossip',\r\n  includesFeePayer: boolean = false,\r\n  block?: BlockhashAndFeeCalculator,\r\n  beforeSend?: () => void,\r\n) => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  let transaction = new Transaction();\r\n  instructions.forEach(instruction => transaction.add(instruction));\r\n  transaction.recentBlockhash = (\r\n    block || (await connection.getRecentBlockhash(commitment))\r\n  ).blockhash;\r\n\r\n  if (includesFeePayer) {\r\n    transaction.setSigners(...signers.map(s => s.publicKey));\r\n  } else {\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map(s => s.publicKey),\r\n    );\r\n  }\r\n\r\n  if (signers.length > 0) {\r\n    transaction.partialSign(...signers);\r\n  }\r\n  if (!includesFeePayer) {\r\n    transaction = await wallet.signTransaction(transaction);\r\n  }\r\n\r\n  if (beforeSend) {\r\n    beforeSend();\r\n  }\r\n\r\n  const { txid, slot } = await sendSignedTransaction({\r\n    connection,\r\n    signedTransaction: transaction,\r\n  });\r\n\r\n  return { txid, slot };\r\n};\r\n\r\nexport const getUnixTs = () => {\r\n  return new Date().getTime() / 1000;\r\n};\r\n\r\nconst DEFAULT_TIMEOUT = 15000;\r\n\r\nexport async function sendSignedTransaction({\r\n  signedTransaction,\r\n  connection,\r\n  timeout = DEFAULT_TIMEOUT,\r\n}: {\r\n  signedTransaction: Transaction;\r\n  connection: Connection;\r\n  sendingMessage?: string;\r\n  sentMessage?: string;\r\n  successMessage?: string;\r\n  timeout?: number;\r\n}): Promise<{ txid: string; slot: number }> {\r\n  const rawTransaction = signedTransaction.serialize();\r\n  const startTime = getUnixTs();\r\n  let slot = 0;\r\n  const txid: TransactionSignature = await connection.sendRawTransaction(\r\n    rawTransaction,\r\n    {\r\n      skipPreflight: true,\r\n    },\r\n  );\r\n\r\n  console.log('Started awaiting confirmation for', txid);\r\n\r\n  let done = false;\r\n  (async () => {\r\n    while (!done && getUnixTs() - startTime < timeout) {\r\n      connection.sendRawTransaction(rawTransaction, {\r\n        skipPreflight: true,\r\n      });\r\n      await sleep(500);\r\n    }\r\n  })();\r\n  try {\r\n    const confirmation = await awaitTransactionSignatureConfirmation(\r\n      txid,\r\n      timeout,\r\n      connection,\r\n      'recent',\r\n      true,\r\n    );\r\n\r\n    if (!confirmation)\r\n      throw new Error('Timed out awaiting confirmation on transaction');\r\n\r\n    if (confirmation.err) {\r\n      console.error(confirmation.err);\r\n      throw new Error('Transaction failed: Custom instruction error');\r\n    }\r\n\r\n    slot = confirmation?.slot || 0;\r\n  } catch (err: any) {\r\n    console.error('Timeout Error caught', err);\r\n    if (err.timeout) {\r\n      throw new Error('Timed out awaiting confirmation on transaction');\r\n    }\r\n    let simulateResult: SimulatedTransactionResponse | null = null;\r\n    try {\r\n      simulateResult = (\r\n        await simulateTransaction(connection, signedTransaction, 'single')\r\n      ).value;\r\n    } catch (e) { }\r\n    if (simulateResult && simulateResult.err) {\r\n      if (simulateResult.logs) {\r\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\r\n          const line = simulateResult.logs[i];\r\n          if (line.startsWith('Program log: ')) {\r\n            throw new Error(\r\n              'Transaction failed: ' + line.slice('Program log: '.length),\r\n            );\r\n          }\r\n        }\r\n      }\r\n      throw new Error(JSON.stringify(simulateResult.err));\r\n    }\r\n    // throw new Error('Transaction failed');\r\n  } finally {\r\n    done = true;\r\n  }\r\n\r\n  console.log('Latency', txid, getUnixTs() - startTime);\r\n  return { txid, slot };\r\n}\r\n\r\nasync function simulateTransaction(\r\n  connection: Connection,\r\n  transaction: Transaction,\r\n  commitment: Commitment,\r\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\r\n  // @ts-ignore\r\n  transaction.recentBlockhash = await connection._recentBlockhash(\r\n    // @ts-ignore\r\n    connection._disableBlockhashCaching,\r\n  );\r\n\r\n  const signData = transaction.serializeMessage();\r\n  // @ts-ignore\r\n  const wireTransaction = transaction._serialize(signData);\r\n  const encodedTransaction = wireTransaction.toString('base64');\r\n  const config: any = { encoding: 'base64', commitment };\r\n  const args = [encodedTransaction, config];\r\n\r\n  // @ts-ignore\r\n  const res = await connection._rpcRequest('simulateTransaction', args);\r\n  if (res.error) {\r\n    throw new Error('failed to simulate transaction: ' + res.error.message);\r\n  }\r\n  return res.result;\r\n}\r\n\r\nasync function awaitTransactionSignatureConfirmation(\r\n  txid: TransactionSignature,\r\n  timeout: number,\r\n  connection: Connection,\r\n  commitment: Commitment = 'recent',\r\n  queryStatus = false,\r\n): Promise<SignatureStatus | null | void> {\r\n  let done = false;\r\n  let status: SignatureStatus | null | void = {\r\n    slot: 0,\r\n    confirmations: 0,\r\n    err: null,\r\n  };\r\n  let subId = 0;\r\n  status = await new Promise(async (resolve, reject) => {\r\n    setTimeout(() => {\r\n      if (done) {\r\n        return;\r\n      }\r\n      done = true;\r\n      console.log('Rejecting for timeout...');\r\n      reject({ timeout: true });\r\n    }, timeout);\r\n    try {\r\n      subId = connection.onSignature(\r\n        txid,\r\n        (result, context) => {\r\n          done = true;\r\n          status = {\r\n            err: result.err,\r\n            slot: context.slot,\r\n            confirmations: 0,\r\n          };\r\n          if (result.err) {\r\n            console.log('Rejected via websocket', result.err);\r\n            reject(status);\r\n          } else {\r\n            console.log('Resolved via websocket', result);\r\n            resolve(status);\r\n          }\r\n        },\r\n        commitment,\r\n      );\r\n    } catch (e) {\r\n      done = true;\r\n      console.error('WS error in setup', txid, e);\r\n    }\r\n    while (!done && queryStatus) {\r\n      // eslint-disable-next-line no-loop-func\r\n      (async () => {\r\n        try {\r\n          const signatureStatuses = await connection.getSignatureStatuses([\r\n            txid,\r\n          ]);\r\n          status = signatureStatuses && signatureStatuses.value[0];\r\n          if (!done) {\r\n            if (!status) {\r\n              console.log('REST null result for', txid, status);\r\n            } else if (status.err) {\r\n              console.log('REST error for', txid, status);\r\n              done = true;\r\n              reject(status.err);\r\n            } else if (!status.confirmations) {\r\n              console.log('REST no confirmations for', txid, status);\r\n            } else {\r\n              console.log('REST confirmation for', txid, status);\r\n              done = true;\r\n              resolve(status);\r\n            }\r\n          }\r\n        } catch (e) {\r\n          if (!done) {\r\n            console.log('REST connection error: txid', txid, e);\r\n          }\r\n        }\r\n      })();\r\n      await sleep(2000);\r\n    }\r\n  });\r\n\r\n  //@ts-ignore\r\n  if (connection._signatureSubscriptions[subId])\r\n    connection.removeSignatureListener(subId);\r\n  done = true;\r\n  console.log('Returning status', status);\r\n  return status;\r\n}\r\nexport function sleep(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nexport function printLog(log: string) {\r\n  console.log(\"[dev-log]--->\", log)\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}