{"ast":null,"code":"import { Keypair } from '@solana/web3.js';\nimport { MintAuthorityMustBeSignerToMintInitialSupplyError } from '../errors.mjs';\nimport { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { toPublicKey } from '../../../types/PublicKey.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs';\nimport { isSigner } from '../../../types/Signer.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateTokenWithMintOperation';\n/**\n * Creates both mint and token accounts in the same transaction.\n *\n * ```ts\n * const { token } = await metaplex.tokens().createTokenWithMint();\n * const mint = token.mint;\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst createTokenWithMintOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst createTokenWithMintOperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const builder = await createTokenWithMintBuilder(metaplex, operation.input, scope);\n    scope.throwIfCanceled();\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n    const token = await metaplex.tokens().findTokenWithMintByMint({\n      mint: output.mintSigner.publicKey,\n      address: output.tokenAddress,\n      addressType: 'token'\n    }, scope);\n    return { ...output,\n      token\n    };\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Creates both mint and token accounts in the same transaction.\n *\n * ```ts\n * const transactionBuilder = await metaplex.tokens().builders().createTokenWithMint();\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst createTokenWithMintBuilder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    decimals = 0,\n    initialSupply,\n    mint = Keypair.generate(),\n    mintAuthority = metaplex.identity(),\n    freezeAuthority = metaplex.identity().publicKey,\n    owner = metaplex.identity().publicKey,\n    token\n  } = params;\n  const createMintBuilder = await metaplex.tokens().builders().createMint({\n    decimals,\n    mint,\n    mintAuthority: toPublicKey(mintAuthority),\n    freezeAuthority,\n    createAccountInstructionKey: params.createMintAccountInstructionKey ?? 'createMintAccount',\n    initializeMintInstructionKey: params.initializeMintInstructionKey ?? 'initializeMint'\n  }, {\n    programs,\n    payer\n  });\n  const createTokenBuilder = await metaplex.tokens().builders().createToken({\n    mint: mint.publicKey,\n    owner,\n    token,\n    createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey ?? 'createAssociatedTokenAccount',\n    createAccountInstructionKey: params.createTokenAccountInstructionKey ?? 'createTokenAccount',\n    initializeTokenInstructionKey: params.initializeTokenInstructionKey ?? 'initializeToken'\n  }, {\n    payer,\n    programs\n  });\n  const {\n    tokenAddress\n  } = createTokenBuilder.getContext();\n  const builder = TransactionBuilder.make().setFeePayer(payer).setContext({\n    mintSigner: mint,\n    tokenAddress\n  }) // Create the Mint account.\n  .add(createMintBuilder) // Create the Token account.\n  .add(createTokenBuilder); // Potentially mint the initial supply to the token account.\n\n  if (!!initialSupply) {\n    if (!isSigner(mintAuthority)) {\n      throw new MintAuthorityMustBeSignerToMintInitialSupplyError();\n    }\n\n    builder.add(await metaplex.tokens().builders().mint({\n      mintAddress: mint.publicKey,\n      toToken: tokenAddress,\n      amount: initialSupply,\n      mintAuthority,\n      mintTokensInstructionKey: params.mintTokensInstructionKey ?? 'mintTokens'\n    }, {\n      payer,\n      programs\n    }));\n  }\n\n  return builder;\n};\n\nexport { createTokenWithMintBuilder, createTokenWithMintOperation, createTokenWithMintOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/tokenModule/operations/createTokenWithMint.ts"],"names":["Key","createTokenWithMintOperation","useOperation","createTokenWithMintOperationHandler","handle","operation","metaplex","scope","builder","createTokenWithMintBuilder","input","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","token","tokens","findTokenWithMintByMint","mint","mintSigner","publicKey","address","tokenAddress","addressType","params","options","programs","payer","rpc","getDefaultFeePayer","decimals","initialSupply","Keypair","generate","mintAuthority","identity","freezeAuthority","owner","createMintBuilder","builders","createMint","toPublicKey","createAccountInstructionKey","createMintAccountInstructionKey","initializeMintInstructionKey","createTokenBuilder","createToken","createAssociatedTokenAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","getContext","TransactionBuilder","make","setFeePayer","setContext","add","isSigner","MintAuthorityMustBeSignerToMintInitialSupplyError","mintAddress","toToken","amount","mintTokensInstructionKey"],"mappings":"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","sourcesContent":["import { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { MintAuthorityMustBeSignerToMintInitialSupplyError } from '../errors';\nimport { TokenWithMint } from '../models/Token';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateTokenWithMintOperation' as const;\n\n/**\n * Creates both mint and token accounts in the same transaction.\n *\n * ```ts\n * const { token } = await metaplex.tokens().createTokenWithMint();\n * const mint = token.mint;\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createTokenWithMintOperation =\n  useOperation<CreateTokenWithMintOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateTokenWithMintOperation = Operation<\n  typeof Key,\n  CreateTokenWithMintInput,\n  CreateTokenWithMintOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateTokenWithMintInput = {\n  /**\n   * The number of decimal points used to define token amounts.\n   *\n   * @defaultValue `0`\n   */\n  decimals?: number;\n\n  /**\n   * The initial amount of tokens to mint to the new token account.\n   *\n   * @defaultValue `0`\n   */\n  initialSupply?: SplTokenAmount;\n\n  /**\n   * The address of the new mint account as a Signer.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  mint?: Signer;\n\n  /**\n   * The address of the authority that is allowed\n   * to mint new tokens to token accounts.\n   *\n   * It may be required as a Signer in order to\n   * mint the initial supply.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: Signer | PublicKey;\n\n  /**\n   * The address of the authority that is allowed\n   * to freeze token accounts.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  freezeAuthority?: Option<PublicKey>;\n\n  /**\n   * The address of the owner of the new token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  owner?: PublicKey;\n\n  /**\n   * The token account as a Signer if we want to create\n   * a new token account with a specific address instead of\n   * creating a new associated token account.\n   *\n   * @defaultValue Defaults to creating a new associated token account\n   * using the `mint` and `owner` parameters.\n   */\n  token?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateTokenWithMintOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The new mint account as a Signer. */\n  mintSigner: Signer;\n\n  /**\n   * A model representing the newly created token\n   * account and its associated mint account.\n   */\n  token: TokenWithMint;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createTokenWithMintOperationHandler: OperationHandler<CreateTokenWithMintOperation> =\n  {\n    async handle(\n      operation: CreateTokenWithMintOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateTokenWithMintOutput> {\n      const builder = await createTokenWithMintBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const token = await metaplex.tokens().findTokenWithMintByMint(\n        {\n          mint: output.mintSigner.publicKey,\n          address: output.tokenAddress,\n          addressType: 'token',\n        },\n        scope\n      );\n\n      return { ...output, token };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateTokenWithMintBuilderParams = Omit<\n  CreateTokenWithMintInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associates token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens to the token account. */\n  mintTokensInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateTokenWithMintBuilderContext = {\n  /** The mint account to create as a Signer. */\n  mintSigner: Signer;\n\n  /** The computed address of the token account to create. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * Creates both mint and token accounts in the same transaction.\n *\n * ```ts\n * const transactionBuilder = await metaplex.tokens().builders().createTokenWithMint();\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createTokenWithMintBuilder = async (\n  metaplex: Metaplex,\n  params: CreateTokenWithMintBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateTokenWithMintBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    decimals = 0,\n    initialSupply,\n    mint = Keypair.generate(),\n    mintAuthority = metaplex.identity(),\n    freezeAuthority = metaplex.identity().publicKey,\n    owner = metaplex.identity().publicKey,\n    token,\n  } = params;\n\n  const createMintBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createMint(\n      {\n        decimals,\n        mint,\n        mintAuthority: toPublicKey(mintAuthority),\n        freezeAuthority,\n        createAccountInstructionKey:\n          params.createMintAccountInstructionKey ?? 'createMintAccount',\n        initializeMintInstructionKey:\n          params.initializeMintInstructionKey ?? 'initializeMint',\n      },\n      { programs, payer }\n    );\n\n  const createTokenBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createToken(\n      {\n        mint: mint.publicKey,\n        owner,\n        token,\n        createAssociatedTokenAccountInstructionKey:\n          params.createAssociatedTokenAccountInstructionKey ??\n          'createAssociatedTokenAccount',\n        createAccountInstructionKey:\n          params.createTokenAccountInstructionKey ?? 'createTokenAccount',\n        initializeTokenInstructionKey:\n          params.initializeTokenInstructionKey ?? 'initializeToken',\n      },\n      { payer, programs }\n    );\n\n  const { tokenAddress } = createTokenBuilder.getContext();\n\n  const builder = TransactionBuilder.make<CreateTokenWithMintBuilderContext>()\n    .setFeePayer(payer)\n    .setContext({ mintSigner: mint, tokenAddress })\n\n    // Create the Mint account.\n    .add(createMintBuilder)\n\n    // Create the Token account.\n    .add(createTokenBuilder);\n\n  // Potentially mint the initial supply to the token account.\n  if (!!initialSupply) {\n    if (!isSigner(mintAuthority)) {\n      throw new MintAuthorityMustBeSignerToMintInitialSupplyError();\n    }\n\n    builder.add(\n      await metaplex\n        .tokens()\n        .builders()\n        .mint(\n          {\n            mintAddress: mint.publicKey,\n            toToken: tokenAddress,\n            amount: initialSupply,\n            mintAuthority,\n            mintTokensInstructionKey:\n              params.mintTokensInstructionKey ?? 'mintTokens',\n          },\n          { payer, programs }\n        )\n    );\n  }\n\n  return builder;\n};\n"]},"metadata":{},"sourceType":"module"}