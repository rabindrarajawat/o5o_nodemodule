{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nconst R = __importStar(require(\"ramda\"));\n\nconst react_1 = require(\"react\");\n\nconst utils_1 = require(\"../useReducer/utils\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst types_1 = require(\"../types\");\n\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED\n        });\n      }\n\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.COMPLETED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          refreshTimeoutId: undefined,\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: types_1.GatewayStatus.CHECKING\n        });\n      }\n\n    case 'refresh_clear_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: undefined\n      });\n\n    case 'refresh_set_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: action.refreshTimeoutId\n      });\n\n    case 'refresh_token_success':\n      return Object.assign(Object.assign({}, state), {\n        refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nconst useRefresh = (_ref, state, dispatch) => {\n  let {\n    stage: stage,\n    gatekeeperClient: gatekeeperClient,\n    networkConfig: networkConfig\n  } = _ref;\n  const {\n    refreshTimeoutId: refreshTimeoutId,\n    gatewayToken: gatewayToken,\n    gatekeeperNetworkAddress: gatekeeperNetworkAddress,\n    ownerSigns: ownerSigns,\n    walletAddress: walletAddress\n  } = state;\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(`[useRefresh] ${message}`, obj);\n  };\n\n  const setTimeoutForRefresh = (0, react_1.useRef)(null);\n  /**\n   * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n   * event, triggering the refreshFlow\n   */\n\n  const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {\n    logDebug('Checking if refresh required', refreshTimeoutId);\n    dispatch({\n      type: 'refresh_status_check'\n    });\n\n    if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n      const {\n        tokenExpirationMarginSeconds: tokenExpirationMarginSeconds\n      } = networkConfig;\n      const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n      const timeoutId = setTimeout(() => {\n        const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({\n          gatewayToken: gatewayToken,\n          tokenExpirationMarginSeconds: tokenExpirationMarginSeconds\n        });\n\n        if (shouldRefresh) {\n          logDebug('Refreshing Gateway Token');\n          dispatch({\n            type: 'refresh_start'\n          });\n          dispatch({\n            type: 'civicPass_check_token_status'\n          });\n          return;\n        }\n\n        logDebug('Skipping refresh', {\n          gatewayToken: gatewayToken,\n          tokenExpirationMarginSeconds: tokenExpirationMarginSeconds\n        });\n        dispatch({\n          type: 'refresh_complete'\n        });\n      }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n\n      logDebug('Setting token refresh timeout', {\n        expiring: gatewayToken.expiryTime,\n        checkForExpirationIntervalMilliseconds: checkForExpirationIntervalMilliseconds,\n        margin: tokenExpirationMarginSeconds\n      });\n      dispatch({\n        type: 'refresh_set_timeout',\n        refreshTimeoutId: timeoutId\n      });\n    }\n  }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  const refreshToken = (0, react_1.useCallback)(useWallet => async _ref2 => {\n    let {\n      proof: proof,\n      payload: payload\n    } = _ref2;\n    logDebug('Refresh token', {\n      payload: payload,\n      proof: proof\n    });\n    dispatch({\n      type: 'refresh_with_powo_in_progress'\n    });\n    const refreshResult = await gatekeeperClient().refreshToken({\n      wallet: useWallet,\n      payload: payload,\n      proof: proof,\n      ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false\n    }); // fail for 4XX errors\n\n    if (refreshResult.status >= 400 && refreshResult.status < 500) {\n      throw new Error(`Error ${refreshResult.status} from refresh gatekeeper token request`);\n    } // Fail if client sends and no transaction is returned\n\n\n    if (ownerSigns && (R.isNil(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction) || R.isEmpty(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction))) {\n      throw new Error(`Error ${refreshResult.status} no transaction returned from owner signs gatekeeper refresh request`);\n    }\n\n    return refreshResult.transaction;\n  }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n  /**\n   * wait until a gateway token exists in state before resolving the promise\n   */\n\n  const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n    return new Promise((resolve, reject) => {\n      const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n      logDebug('waitForUnexpiredGatewayToken: Waiting for unexpired token', {\n        gatewayToken: gatewayToken,\n        currentRefreshTimeoutId: setTimeoutForRefresh.current,\n        isExpired: isExpired\n      });\n\n      if (setTimeoutForRefresh.current) {\n        logDebug('waitForUnexpiredGatewayToken: Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n        clearTimeout(setTimeoutForRefresh.current);\n        setTimeoutForRefresh.current = null;\n      }\n\n      if (!isExpired) {\n        logDebug('waitForUnexpiredGatewayToken: Gateway token is unexpired', gatewayToken);\n        resolve();\n        return;\n      }\n\n      setTimeoutForRefresh.current = setTimeout(() => {\n        reject(new Error('Gateway token refresh has not been updated onChain'));\n      }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n      logDebug('waitForUnexpiredGatewayToken: Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n\n      if (ownerSigns) {\n        logDebug('waitForUnexpiredGatewayToken: emitting awaiting owner transaction'); // show the awaiting owner transaction UI if this is ownersigns\n\n        dispatch({\n          type: 'civicPass_awaiting_owner_transaction'\n        });\n      }\n    });\n  }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, gatekeeperNetworkAddress]);\n  return {\n    checkForRefreshWithTimeout: checkForRefreshWithTimeout,\n    refreshToken: refreshToken,\n    waitForUnexpiredGatewayToken: waitForUnexpiredGatewayToken\n  };\n};\n\nexports.default = useRefresh;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","reducer","R","require","react_1","utils_1","logger_1","types_1","tokenUtils_1","state","action","type","assign","walletPowoInProgress","powoFinished","powoRequested","refreshInProgress","gatewayStatus","GatewayStatus","REFRESH_TOKEN_REQUIRED","refreshTokenState","RefreshTokenState","IN_PROGRESS","COMPLETED","statusFromToken","gatewayToken","refreshTimeoutId","civicPass","responsePayload","renderIframe","iframeMinimized","CHECKING","WAIT_FOR_ON_CHAIN","useRefresh","dispatch","stage","gatekeeperClient","networkConfig","gatekeeperNetworkAddress","ownerSigns","walletAddress","logDebug","message","obj","default","debug","setTimeoutForRefresh","useRef","checkForRefreshWithTimeout","useCallback","expiryTime","tokenExpirationMarginSeconds","checkForExpirationIntervalMilliseconds","getTokenRefreshIntervalMilliseconds","timeoutId","setTimeout","shouldRefresh","isTokenRefreshRequired","expiring","margin","refreshToken","useWallet","proof","payload","refreshResult","wallet","status","Error","isNil","transaction","isEmpty","waitForUnexpiredGatewayToken","Promise","resolve","reject","isExpired","hasExpired","currentRefreshTimeoutId","current","clearTimeout","waitForTokenRefreshTimoutMilliseconds"],"sources":["D:/software/o5o BNB/o5o-staking-frontend/node_modules/@civic/common-gateway-react/dist/esm/useHooks/useRefresh.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst R = __importStar(require(\"ramda\"));\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"../useReducer/utils\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED });\n        }\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), refreshTimeoutId: undefined, civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.CHECKING });\n        }\n        case 'refresh_clear_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: undefined });\n        case 'refresh_set_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: action.refreshTimeoutId });\n        case 'refresh_token_success':\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useRefresh = ({ stage, gatekeeperClient, networkConfig, }, state, dispatch) => {\n    const { refreshTimeoutId, gatewayToken, gatekeeperNetworkAddress, ownerSigns, walletAddress } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);\n    const setTimeoutForRefresh = (0, react_1.useRef)(null);\n    /**\n     * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n     * event, triggering the refreshFlow\n     */\n    const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {\n        logDebug('Checking if refresh required', refreshTimeoutId);\n        dispatch({ type: 'refresh_status_check' });\n        if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n            const { tokenExpirationMarginSeconds } = networkConfig;\n            const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n            const timeoutId = setTimeout(() => {\n                const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({ gatewayToken, tokenExpirationMarginSeconds });\n                if (shouldRefresh) {\n                    logDebug('Refreshing Gateway Token');\n                    dispatch({ type: 'refresh_start' });\n                    dispatch({ type: 'civicPass_check_token_status' });\n                    return;\n                }\n                logDebug('Skipping refresh', { gatewayToken, tokenExpirationMarginSeconds });\n                dispatch({ type: 'refresh_complete' });\n            }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n            logDebug('Setting token refresh timeout', {\n                expiring: gatewayToken.expiryTime,\n                checkForExpirationIntervalMilliseconds,\n                margin: tokenExpirationMarginSeconds,\n            });\n            dispatch({\n                type: 'refresh_set_timeout',\n                refreshTimeoutId: timeoutId,\n            });\n        }\n    }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshToken = (0, react_1.useCallback)((useWallet) => async ({ proof, payload }) => {\n        logDebug('Refresh token', { payload, proof });\n        dispatch({ type: 'refresh_with_powo_in_progress' });\n        const refreshResult = await gatekeeperClient().refreshToken({\n            wallet: useWallet,\n            payload,\n            proof,\n            ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false,\n        });\n        // fail for 4XX errors\n        if (refreshResult.status >= 400 && refreshResult.status < 500) {\n            throw new Error(`Error ${refreshResult.status} from refresh gatekeeper token request`);\n        }\n        // Fail if client sends and no transaction is returned\n        if (ownerSigns && (R.isNil(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction) || R.isEmpty(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction))) {\n            throw new Error(`Error ${refreshResult.status} no transaction returned from owner signs gatekeeper refresh request`);\n        }\n        return refreshResult.transaction;\n    }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n    /**\n     * wait until a gateway token exists in state before resolving the promise\n     */\n    const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n        return new Promise((resolve, reject) => {\n            const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n            logDebug('waitForUnexpiredGatewayToken: Waiting for unexpired token', {\n                gatewayToken,\n                currentRefreshTimeoutId: setTimeoutForRefresh.current,\n                isExpired,\n            });\n            if (setTimeoutForRefresh.current) {\n                logDebug('waitForUnexpiredGatewayToken: Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n                clearTimeout(setTimeoutForRefresh.current);\n                setTimeoutForRefresh.current = null;\n            }\n            if (!isExpired) {\n                logDebug('waitForUnexpiredGatewayToken: Gateway token is unexpired', gatewayToken);\n                resolve();\n                return;\n            }\n            setTimeoutForRefresh.current = setTimeout(() => {\n                reject(new Error('Gateway token refresh has not been updated onChain'));\n            }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n            logDebug('waitForUnexpiredGatewayToken: Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n            if (ownerSigns) {\n                logDebug('waitForUnexpiredGatewayToken: emitting awaiting owner transaction');\n                // show the awaiting owner transaction UI if this is ownersigns\n                dispatch({ type: 'civicPass_awaiting_owner_transaction' });\n            }\n        });\n    }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, gatekeeperNetworkAddress]);\n    return {\n        checkForRefreshWithTimeout,\n        refreshToken,\n        waitForUnexpiredGatewayToken,\n    };\n};\nexports.default = useRefresh;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}