{"ast":null,"code":"import { createSerializerFromSolitaType, deserializeAccount } from './Serializer.mjs';\nimport { AccountNotFoundError } from '../errors/SdkError.mjs';\n\nfunction getAccountParsingFunction(parser) {\n  function parse(account) {\n    if ('exists' in account && !account.exists) {\n      return account;\n    }\n\n    const serializer = createSerializerFromSolitaType(parser);\n    return deserializeAccount(account, serializer);\n  }\n\n  return parse;\n}\n\nfunction getAccountParsingAndAssertingFunction(parser) {\n  const parse = getAccountParsingFunction(parser);\n  return (unparsedAccount, solution) => {\n    if ('exists' in unparsedAccount) {\n      assertAccountExists(unparsedAccount, parser.name, solution);\n    }\n\n    return parse(unparsedAccount);\n  };\n}\n\nfunction assertAccountExists(account, name, solution) {\n  if (!account.exists) {\n    throw new AccountNotFoundError(account.publicKey, name, solution);\n  }\n}\n\nconst toAccountInfo = account => {\n  const {\n    executable,\n    owner,\n    lamports,\n    rentEpoch\n  } = account;\n  return {\n    executable,\n    owner,\n    lamports,\n    rentEpoch\n  };\n};\n\nexport { assertAccountExists, getAccountParsingAndAssertingFunction, getAccountParsingFunction, toAccountInfo };","map":{"version":3,"sources":["../../../src/types/Account.ts"],"names":["getAccountParsingFunction","parser","parse","account","exists","serializer","createSerializerFromSolitaType","deserializeAccount","getAccountParsingAndAssertingFunction","unparsedAccount","solution","assertAccountExists","name","AccountNotFoundError","publicKey","toAccountInfo","executable","owner","lamports","rentEpoch"],"mappings":";;;AAuCO,SAASA,yBAAT,CACLC,MADK,EAEsB;EAG3B,SAASC,KAAT,CACEC,OADF,EAEgC;IAC9B,IAAI,YAAYA,OAAZ,IAAuB,CAACA,OAAO,CAACC,MAApC,EAA4C;MAC1C,OAAOD,OAAP;IACF;;IAEA,MAAME,UAAU,GAAGC,8BAA8B,CAACL,MAAD,CAAjD;IACA,OAAOM,kBAAkB,CAACJ,OAAD,EAAUE,UAAV,CAAzB;EACF;;EAEA,OAAOH,KAAP;AACF;;AAEO,SAASM,qCAAT,CACLP,MADK,EAEkC;EACvC,MAAMC,KAAK,GAAGF,yBAAyB,CAACC,MAAD,CAAvC;EAEA,OAAO,CACLQ,eADK,EAELC,QAFK,KAGF;IACH,IAAI,YAAYD,eAAhB,EAAiC;MAC/BE,mBAAmB,CAACF,eAAD,EAAkBR,MAAM,CAACW,IAAzB,EAA+BF,QAA/B,CAAnBC;IACF;;IAEA,OAAOT,KAAK,CAACO,eAAD,CAAZ;EACD,CATD;AAUF;;AAEO,SAASE,mBAAT,CACLR,OADK,EAELS,IAFK,EAGLF,QAHK,EAI6C;EAClD,IAAI,CAACP,OAAO,CAACC,MAAb,EAAqB;IACnB,MAAM,IAAIS,oBAAJ,CAAyBV,OAAO,CAACW,SAAjC,EAA4CF,IAA5C,EAAkDF,QAAlD,CAAN;EACF;AACF;;AAEaK,MAAAA,aAAa,GAAIZ,OAAwB,IAAkB;EACtE,MAAM;IAAEa,UAAF;IAAcC,KAAd;IAAqBC,QAArB;IAA+BC;EAA/B,IAA6ChB,OAAnD;EACA,OAAO;IAAEa,UAAF;IAAcC,KAAd;IAAqBC,QAArB;IAA+BC;EAA/B,CAAP;AACF,CAHaJ","sourcesContent":["import { Buffer } from 'buffer';\nimport { PublicKey } from '@solana/web3.js';\nimport { SolAmount } from './Amount';\nimport {\n  createSerializerFromSolitaType,\n  deserializeAccount,\n  SolitaType,\n} from './Serializer';\nimport { AccountNotFoundError } from '@/errors';\n\nexport type AccountInfo = {\n  readonly executable: boolean;\n  readonly owner: PublicKey;\n  readonly lamports: SolAmount;\n  readonly rentEpoch?: number;\n};\n\nexport type Account<T> = AccountInfo & {\n  readonly publicKey: PublicKey;\n  readonly data: T;\n};\n\nexport type MaybeAccount<T> =\n  | (Account<T> & { readonly exists: true })\n  | { readonly publicKey: PublicKey; readonly exists: false };\n\nexport type UnparsedAccount = Account<Buffer>;\nexport type UnparsedMaybeAccount = MaybeAccount<Buffer>;\n\nexport type AccountParsingFunction<T> = {\n  (unparsedAccount: UnparsedAccount): Account<T>;\n  (unparsedAccount: UnparsedMaybeAccount): MaybeAccount<T>;\n};\n\nexport type AccountParsingAndAssertingFunction<T> = (\n  unparsedAccount: UnparsedAccount | UnparsedMaybeAccount,\n  solution?: string\n) => Account<T>;\n\nexport function getAccountParsingFunction<T>(\n  parser: SolitaType<T>\n): AccountParsingFunction<T> {\n  function parse(account: UnparsedAccount): Account<T>;\n  function parse(account: UnparsedMaybeAccount): MaybeAccount<T>;\n  function parse(\n    account: UnparsedAccount | UnparsedMaybeAccount\n  ): Account<T> | MaybeAccount<T> {\n    if ('exists' in account && !account.exists) {\n      return account;\n    }\n\n    const serializer = createSerializerFromSolitaType(parser);\n    return deserializeAccount(account, serializer);\n  }\n\n  return parse;\n}\n\nexport function getAccountParsingAndAssertingFunction<T>(\n  parser: SolitaType<T>\n): AccountParsingAndAssertingFunction<T> {\n  const parse = getAccountParsingFunction(parser);\n\n  return (\n    unparsedAccount: UnparsedAccount | UnparsedMaybeAccount,\n    solution?: string\n  ) => {\n    if ('exists' in unparsedAccount) {\n      assertAccountExists(unparsedAccount, parser.name, solution);\n    }\n\n    return parse(unparsedAccount);\n  };\n}\n\nexport function assertAccountExists<T>(\n  account: MaybeAccount<T>,\n  name?: string,\n  solution?: string\n): asserts account is Account<T> & { exists: true } {\n  if (!account.exists) {\n    throw new AccountNotFoundError(account.publicKey, name, solution);\n  }\n}\n\nexport const toAccountInfo = (account: UnparsedAccount): AccountInfo => {\n  const { executable, owner, lamports, rentEpoch } = account;\n  return { executable, owner, lamports, rentEpoch };\n};\n"]},"metadata":{},"sourceType":"module"}