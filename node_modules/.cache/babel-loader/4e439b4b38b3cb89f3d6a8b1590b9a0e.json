{"ast":null,"code":"import assert from '../../../utils/assert.mjs';\nimport { amount, lamports } from '../../../types/Amount.mjs';\nimport { toBigNumber } from '../../../types/BigNumber.mjs';\nimport { toDateTime } from '../../../types/DateTime.mjs';\n\nconst isPurchase = value => typeof value === 'object' && value.model === 'purchase' && !value.lazy;\n\nfunction assertPurchase(value) {\n  assert(isPurchase(value), `Expected Purchase type`);\n}\n\nconst toPurchase = (account, auctionHouseModel, asset) => {\n  const lazyPurchase = toLazyPurchase(account, auctionHouseModel);\n  return { ...lazyPurchase,\n    model: 'purchase',\n    lazy: false,\n    asset,\n    tokens: amount(lazyPurchase.tokens, asset.mint.currency)\n  };\n};\n\nconst isLazyPurchase = value => typeof value === 'object' && value.model === 'purchase' && value.lazy;\n\nfunction assertLazyPurchase(value) {\n  assert(isLazyPurchase(value), `Expected LazyPurchase type`);\n}\n\nconst toLazyPurchase = (account, auctionHouseModel) => {\n  return {\n    model: 'purchase',\n    lazy: true,\n    auctionHouse: auctionHouseModel,\n    buyerAddress: account.data.buyer,\n    sellerAddress: account.data.seller,\n    metadataAddress: account.data.metadata,\n    bookkeeperAddress: account.data.bookkeeper,\n    receiptAddress: account.publicKey,\n    price: auctionHouseModel.isNative ? lamports(account.data.price) : amount(account.data.price, auctionHouseModel.treasuryMint.currency),\n    tokens: toBigNumber(account.data.tokenSize),\n    createdAt: toDateTime(account.data.createdAt)\n  };\n};\n\nexport { assertLazyPurchase, assertPurchase, isLazyPurchase, isPurchase, toLazyPurchase, toPurchase };","map":{"version":3,"sources":["../../../../../src/plugins/auctionHouseModule/models/Purchase.ts"],"names":["isPurchase","value","model","lazy","assertPurchase","assert","toPurchase","account","auctionHouseModel","asset","lazyPurchase","toLazyPurchase","tokens","amount","mint","currency","isLazyPurchase","assertLazyPurchase","auctionHouse","buyerAddress","data","buyer","sellerAddress","seller","metadataAddress","metadata","bookkeeperAddress","bookkeeper","receiptAddress","publicKey","price","isNative","lamports","treasuryMint","toBigNumber","tokenSize","createdAt","toDateTime"],"mappings":";;;;;MA6DaA,UAAU,GAAIC,KAAU,IACnC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACC,KAAND,KAAgB,UAA7C,IAA2D,CAACA,KAAK,CAACE,I;;AAE7D,SAASC,cAAT,CAAwBH,KAAxB,EAA+D;EACpEI,MAAM,CAACL,UAAU,CAACC,KAAD,CAAX,EAAqB,wBAArB,CAANI;AACF;;AAEO,MAAMC,UAAU,GAAG,CACxBC,OADwB,EAExBC,iBAFwB,EAGxBC,KAHwB,KAIX;EACb,MAAMC,YAAY,GAAGC,cAAc,CAACJ,OAAD,EAAUC,iBAAV,CAAnC;EAEA,OAAO,EACL,GAAGE,YADE;IAELR,KAAK,EAAE,UAFF;IAGLC,IAAI,EAAE,KAHD;IAILM,KAJK;IAKLG,MAAM,EAAEC,MAAM,CAACH,YAAY,CAACE,MAAd,EAAsBH,KAAK,CAACK,IAANL,CAAWM,QAAjC;EALT,CAAP;AAOF,CAdO;;MAuBMC,cAAc,GAAIf,KAAU,IACvC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACC,KAAND,KAAgB,UAA7C,IAA2DA,KAAK,CAACE,I;;AAE5D,SAASc,kBAAT,CAA4BhB,KAA5B,EAAuE;EAC5EI,MAAM,CAACW,cAAc,CAACf,KAAD,CAAf,EAAyB,4BAAzB,CAANI;AACF;;MACaM,cAAc,GAAG,CAC5BJ,OAD4B,EAE5BC,iBAF4B,KAGX;EACjB,OAAO;IACLN,KAAK,EAAE,UADF;IAELC,IAAI,EAAE,IAFD;IAGLe,YAAY,EAAEV,iBAHT;IAILW,YAAY,EAAEZ,OAAO,CAACa,IAARb,CAAac,KAJtB;IAKLC,aAAa,EAAEf,OAAO,CAACa,IAARb,CAAagB,MALvB;IAMLC,eAAe,EAAEjB,OAAO,CAACa,IAARb,CAAakB,QANzB;IAOLC,iBAAiB,EAAEnB,OAAO,CAACa,IAARb,CAAaoB,UAP3B;IAQLC,cAAc,EAAErB,OAAO,CAACsB,SARnB;IASLC,KAAK,EAAEtB,iBAAiB,CAACuB,QAAlBvB,GACHwB,QAAQ,CAACzB,OAAO,CAACa,IAARb,CAAauB,KAAd,CADLtB,GAEHK,MAAM,CAACN,OAAO,CAACa,IAARb,CAAauB,KAAd,EAAqBtB,iBAAiB,CAACyB,YAAlBzB,CAA+BO,QAApD,CAXL;IAYLH,MAAM,EAAEsB,WAAW,CAAC3B,OAAO,CAACa,IAARb,CAAa4B,SAAd,CAZd;IAaLC,SAAS,EAAEC,UAAU,CAAC9B,OAAO,CAACa,IAARb,CAAa6B,SAAd;EAbhB,CAAP;AAeF,C","sourcesContent":["import { PublicKey } from '@solana/web3.js';\nimport { PurchaseReceiptAccount } from '../accounts';\nimport { NftWithToken, SftWithToken } from '../../nftModule';\nimport { AuctionHouse } from './AuctionHouse';\nimport {\n  amount,\n  BigNumber,\n  DateTime,\n  lamports,\n  SolAmount,\n  SplTokenAmount,\n  toBigNumber,\n  toDateTime,\n} from '@/types';\nimport { assert, Option } from '@/utils';\n\nexport type Purchase = Readonly<{\n  /** A model identifier to distinguish models in the SDK. */\n  model: 'purchase';\n\n  /**\n   * Whether or not the asset was loaded.\n   * When this is `false`, it means the Purchase includes asset model.\n   */\n  lazy: false;\n\n  /** A model of the Auction House related to this purchase. */\n  auctionHouse: AuctionHouse;\n\n  /** The Nft or Sft with the associated token account. */\n  asset: SftWithToken | NftWithToken;\n\n  /** The address of the buyer's wallet. */\n  buyerAddress: PublicKey;\n\n  /** The address of the seller's wallet. */\n  sellerAddress: PublicKey;\n\n  /**\n   * The address of the bookkeeper account.\n   * It is responsible for signing a Purchase Receipt Print.\n   */\n  bookkeeperAddress: Option<PublicKey>;\n\n  /**\n   * The address of the purchase receipt account.\n   * This is the account that stores information about this purchase.\n   * The Purchase model is built on top of this account.\n   */\n  receiptAddress: Option<PublicKey>;\n\n  /** The number of tokens spent on this purchase. */\n  price: SolAmount | SplTokenAmount;\n\n  /** The number of tokens bought in case it's a sale of a Fungible Token. */\n  tokens: SplTokenAmount;\n\n  /** The date of creation. */\n  createdAt: DateTime;\n}>;\n\nexport const isPurchase = (value: any): value is Purchase =>\n  typeof value === 'object' && value.model === 'purchase' && !value.lazy;\n\nexport function assertPurchase(value: any): asserts value is Purchase {\n  assert(isPurchase(value), `Expected Purchase type`);\n}\n\nexport const toPurchase = (\n  account: PurchaseReceiptAccount,\n  auctionHouseModel: AuctionHouse,\n  asset: NftWithToken | SftWithToken\n): Purchase => {\n  const lazyPurchase = toLazyPurchase(account, auctionHouseModel);\n\n  return {\n    ...lazyPurchase,\n    model: 'purchase',\n    lazy: false,\n    asset,\n    tokens: amount(lazyPurchase.tokens, asset.mint.currency),\n  };\n};\n\nexport type LazyPurchase = Omit<Purchase, 'lazy' | 'asset' | 'tokens'> &\n  Readonly<{\n    lazy: true;\n    metadataAddress: PublicKey;\n    tokens: BigNumber;\n  }>;\n\nexport const isLazyPurchase = (value: any): value is LazyPurchase =>\n  typeof value === 'object' && value.model === 'purchase' && value.lazy;\n\nexport function assertLazyPurchase(value: any): asserts value is LazyPurchase {\n  assert(isLazyPurchase(value), `Expected LazyPurchase type`);\n}\nexport const toLazyPurchase = (\n  account: PurchaseReceiptAccount,\n  auctionHouseModel: AuctionHouse\n): LazyPurchase => {\n  return {\n    model: 'purchase',\n    lazy: true,\n    auctionHouse: auctionHouseModel,\n    buyerAddress: account.data.buyer,\n    sellerAddress: account.data.seller,\n    metadataAddress: account.data.metadata,\n    bookkeeperAddress: account.data.bookkeeper,\n    receiptAddress: account.publicKey,\n    price: auctionHouseModel.isNative\n      ? lamports(account.data.price)\n      : amount(account.data.price, auctionHouseModel.treasuryMint.currency),\n    tokens: toBigNumber(account.data.tokenSize),\n    createdAt: toDateTime(account.data.createdAt),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}