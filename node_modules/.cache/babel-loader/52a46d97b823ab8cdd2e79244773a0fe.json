{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setsTypeMap = exports.set = void 0;\n\nconst types_1 = require(\"../types\");\n\nconst numbers_1 = require(\"./numbers\");\n\nconst utils_1 = require(\"../utils\");\n\nconst assert_1 = require(\"assert\");\n/**\n * De/Serializes a set with a specific number of keys of type {@link K}.\n *\n * NOTE: that it is not exported as no fixed size set exists but will have to\n * be derived from data or value instead.\n *\n * @template K type of key elements held in the set\n *\n * @param keyElement the De/Serializers for the key element types\n * @param len amount of entries in the set\n *\n * @category beet/composite\n * @private\n */\n\n\nfunction fixedSizeSet(keyElement, fixedElements, len) {\n  const keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n\n  function determineSizes() {\n    if (keyElementFixed) {\n      const elementByteSize = keyElement.byteSize;\n      return {\n        elementByteSize,\n        byteSize: 4 + len * elementByteSize\n      };\n    } else {\n      let keysByteSize = 0;\n\n      for (const k of fixedElements.values()) {\n        keysByteSize += k.byteSize;\n      }\n\n      const elementByteSize = Math.ceil(keysByteSize / len);\n      return {\n        elementByteSize,\n        byteSize: 4 + keysByteSize\n      };\n    }\n  }\n\n  const {\n    elementByteSize,\n    byteSize\n  } = determineSizes();\n  return {\n    write: function (buf, offset, set) {\n      // Write the values first and then the size as it comes clear while we do the former\n      let cursor = offset + 4;\n      let size = 0;\n\n      for (const k of set.keys()) {\n        let fixedKey = keyElementFixed ? keyElement : null;\n\n        if (fixedKey == null) {\n          // When we write the value we know the key and an just pull the\n          // matching fixed beet for key from the provided set which is\n          // faster than fixing it by value\n          const el = fixedElements.get(k);\n          (0, assert_1.strict)(el != null, `Should be able to find beet el for ${(0, utils_1.stringify)(k)}, but could not`);\n          fixedKey !== null && fixedKey !== void 0 ? fixedKey : fixedKey = el;\n        }\n\n        fixedKey.write(buf, cursor, k);\n        cursor += fixedKey.byteSize;\n        size++;\n      }\n\n      numbers_1.u32.write(buf, offset, size);\n      assert_1.strict.equal(size, len, `Expected set to have size ${len}, but has ${size}.`);\n    },\n    read: function (buf, offset) {\n      const size = numbers_1.u32.read(buf, offset);\n      assert_1.strict.equal(size, len, `Expected set to have size ${len}, but has ${size}.`);\n      let cursor = offset + 4;\n      const set = new Set();\n\n      for (let i = 0; i < size; i++) {\n        // When we read the value from a buffer we don't know the key we're\n        // reading yet and thus cannot use the provided set of fixed\n        // de/serializers.\n        // Therefore we obtain it by fixing it by data instead.\n        const fixedKey = keyElementFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n        const k = fixedKey.read(buf, cursor);\n        cursor += fixedKey.byteSize;\n        set.add(k);\n      }\n\n      return set;\n    },\n    elementByteSize,\n    byteSize,\n    length: len,\n    lenPrefixByteSize: 4,\n    description: `Set<${keyElement.description}>`\n  };\n}\n/**\n * De/Serializes a set with a specific number of keys of type {@link K}\n *\n * @template K type of key elements held in the set\n *\n * @param keyElement the _fixable_ or _fixed_ de/serializers for the key element types\n *\n * @category beet/composite\n */\n\n\nfunction set(keyElement) {\n  const keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n  return {\n    toFixedFromData(buf, offset) {\n      const len = numbers_1.u32.read(buf, offset);\n      let cursor = offset + 4; // Shortcut for the case that both key and value are fixed size beets\n\n      if (keyIsFixed) {\n        return fixedSizeSet(keyElement, new Map(), len);\n      } // If key is not fixed size beet we need to determine the fixed versions and add them to a set by key\n\n\n      const fixedBeets = new Map();\n\n      for (let i = 0; i < len; i++) {\n        const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n        const key = keyFixed.read(buf, cursor);\n        cursor += keyFixed.byteSize;\n        fixedBeets.set(key, keyFixed);\n      }\n\n      return fixedSizeSet(keyElement, fixedBeets, len);\n    },\n\n    toFixedFromValue(setVal) {\n      const len = setVal.size; // As above shortcut for the optimal case and build a set for all others\n\n      if (keyIsFixed) {\n        return fixedSizeSet(keyElement, new Map(), len);\n      }\n\n      const fixedBeets = new Map();\n\n      for (const k of setVal) {\n        const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromValue(k);\n        fixedBeets.set(k, keyFixed);\n      }\n\n      return fixedSizeSet(keyElement, fixedBeets, len);\n    },\n\n    description: `FixableSet<${keyElement.description}>`\n  };\n}\n\nexports.set = set;\n/**\n * Sets sets beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexports.setsTypeMap = {\n  Set: {\n    beet: 'set',\n    isFixable: true,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: 'Set'\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/sets.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setsTypeMap = exports.set = void 0;\nconst types_1 = require(\"../types\");\nconst numbers_1 = require(\"./numbers\");\nconst utils_1 = require(\"../utils\");\nconst assert_1 = require(\"assert\");\n/**\n * De/Serializes a set with a specific number of keys of type {@link K}.\n *\n * NOTE: that it is not exported as no fixed size set exists but will have to\n * be derived from data or value instead.\n *\n * @template K type of key elements held in the set\n *\n * @param keyElement the De/Serializers for the key element types\n * @param len amount of entries in the set\n *\n * @category beet/composite\n * @private\n */\nfunction fixedSizeSet(keyElement, fixedElements, len) {\n    const keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n    function determineSizes() {\n        if (keyElementFixed) {\n            const elementByteSize = keyElement.byteSize;\n            return {\n                elementByteSize,\n                byteSize: 4 + len * elementByteSize,\n            };\n        }\n        else {\n            let keysByteSize = 0;\n            for (const k of fixedElements.values()) {\n                keysByteSize += k.byteSize;\n            }\n            const elementByteSize = Math.ceil(keysByteSize / len);\n            return {\n                elementByteSize,\n                byteSize: 4 + keysByteSize,\n            };\n        }\n    }\n    const { elementByteSize, byteSize } = determineSizes();\n    return {\n        write: function (buf, offset, set) {\n            // Write the values first and then the size as it comes clear while we do the former\n            let cursor = offset + 4;\n            let size = 0;\n            for (const k of set.keys()) {\n                let fixedKey = keyElementFixed ? keyElement : null;\n                if (fixedKey == null) {\n                    // When we write the value we know the key and an just pull the\n                    // matching fixed beet for key from the provided set which is\n                    // faster than fixing it by value\n                    const el = fixedElements.get(k);\n                    (0, assert_1.strict)(el != null, `Should be able to find beet el for ${(0, utils_1.stringify)(k)}, but could not`);\n                    fixedKey !== null && fixedKey !== void 0 ? fixedKey : (fixedKey = el);\n                }\n                fixedKey.write(buf, cursor, k);\n                cursor += fixedKey.byteSize;\n                size++;\n            }\n            numbers_1.u32.write(buf, offset, size);\n            assert_1.strict.equal(size, len, `Expected set to have size ${len}, but has ${size}.`);\n        },\n        read: function (buf, offset) {\n            const size = numbers_1.u32.read(buf, offset);\n            assert_1.strict.equal(size, len, `Expected set to have size ${len}, but has ${size}.`);\n            let cursor = offset + 4;\n            const set = new Set();\n            for (let i = 0; i < size; i++) {\n                // When we read the value from a buffer we don't know the key we're\n                // reading yet and thus cannot use the provided set of fixed\n                // de/serializers.\n                // Therefore we obtain it by fixing it by data instead.\n                const fixedKey = keyElementFixed\n                    ? keyElement\n                    : keyElement.toFixedFromData(buf, cursor);\n                const k = fixedKey.read(buf, cursor);\n                cursor += fixedKey.byteSize;\n                set.add(k);\n            }\n            return set;\n        },\n        elementByteSize,\n        byteSize,\n        length: len,\n        lenPrefixByteSize: 4,\n        description: `Set<${keyElement.description}>`,\n    };\n}\n/**\n * De/Serializes a set with a specific number of keys of type {@link K}\n *\n * @template K type of key elements held in the set\n *\n * @param keyElement the _fixable_ or _fixed_ de/serializers for the key element types\n *\n * @category beet/composite\n */\nfunction set(keyElement) {\n    const keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n    return {\n        toFixedFromData(buf, offset) {\n            const len = numbers_1.u32.read(buf, offset);\n            let cursor = offset + 4;\n            // Shortcut for the case that both key and value are fixed size beets\n            if (keyIsFixed) {\n                return fixedSizeSet(keyElement, new Map(), len);\n            }\n            // If key is not fixed size beet we need to determine the fixed versions and add them to a set by key\n            const fixedBeets = new Map();\n            for (let i = 0; i < len; i++) {\n                const keyFixed = keyIsFixed\n                    ? keyElement\n                    : keyElement.toFixedFromData(buf, cursor);\n                const key = keyFixed.read(buf, cursor);\n                cursor += keyFixed.byteSize;\n                fixedBeets.set(key, keyFixed);\n            }\n            return fixedSizeSet(keyElement, fixedBeets, len);\n        },\n        toFixedFromValue(setVal) {\n            const len = setVal.size;\n            // As above shortcut for the optimal case and build a set for all others\n            if (keyIsFixed) {\n                return fixedSizeSet(keyElement, new Map(), len);\n            }\n            const fixedBeets = new Map();\n            for (const k of setVal) {\n                const keyFixed = keyIsFixed\n                    ? keyElement\n                    : keyElement.toFixedFromValue(k);\n                fixedBeets.set(k, keyFixed);\n            }\n            return fixedSizeSet(keyElement, fixedBeets, len);\n        },\n        description: `FixableSet<${keyElement.description}>`,\n    };\n}\nexports.set = set;\n/**\n * Sets sets beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.setsTypeMap = {\n    Set: {\n        beet: 'set',\n        isFixable: true,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: 'Set',\n    },\n};\n//# sourceMappingURL=sets.js.map"]},"metadata":{},"sourceType":"script"}