{"ast":null,"code":"import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError, TokenInvalidMintError, TokenOwnerOffCurveError } from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport { getMintLen } from '../extensions/extensionType.js';\nimport { ACCOUNT_SIZE } from './account.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n/** Buffer layout for de/serializing a mint */\n\nexport const MintLayout = struct([u32('mintAuthorityOption'), publicKey('mintAuthority'), u64('supply'), u8('decimals'), bool('isInitialized'), u32('freezeAuthorityOption'), publicKey('freezeAuthority')]);\n/** Byte length of a mint */\n\nexport const MINT_SIZE = MintLayout.span;\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\n\nexport async function getMint(connection, address, commitment) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_PROGRAM_ID;\n  const info = await connection.getAccountInfo(address, commitment);\n  return unpackMint(address, info, programId);\n}\n/**\n * Unpack a mint\n *\n * @param address   Mint account\n * @param info      Mint account data\n * @param programId SPL Token program account\n *\n * @return Unpacked mint\n */\n\nexport function unpackMint(address, info) {\n  let programId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TOKEN_PROGRAM_ID;\n  if (!info) throw new TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n  if (info.data.length < MINT_SIZE) throw new TokenInvalidAccountSizeError();\n  const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));\n  let tlvData = Buffer.alloc(0);\n\n  if (info.data.length > MINT_SIZE) {\n    if (info.data.length <= ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n    if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n    if (info.data[ACCOUNT_SIZE] != AccountType.Mint) throw new TokenInvalidMintError();\n    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n  }\n\n  return {\n    address: address,\n    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n    supply: rawMint.supply,\n    decimals: rawMint.decimals,\n    isInitialized: rawMint.isInitialized,\n    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n    tlvData: tlvData\n  };\n}\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nexport async function getMinimumBalanceForRentExemptMint(connection, commitment) {\n  return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n}\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\n *\n * @param connection Connection to use\n * @param extensions Extension types included in the mint\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nexport async function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {\n  const mintLen = getMintLen(extensions);\n  return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n}\n/**\n * Async version of getAssociatedTokenAddressSync\n * For backwards compatibility\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Promise containing the address of the associated token account\n */\n\nexport async function getAssociatedTokenAddress(mint, owner) {\n  let allowOwnerOffCurve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_PROGRAM_ID;\n  let associatedTokenProgramId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ASSOCIATED_TOKEN_PROGRAM_ID;\n  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n  const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n  return address;\n}\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\n\nexport function getAssociatedTokenAddressSync(mint, owner) {\n  let allowOwnerOffCurve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_PROGRAM_ID;\n  let associatedTokenProgramId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ASSOCIATED_TOKEN_PROGRAM_ID;\n  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n  const [address] = PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n  return address;\n}","map":{"version":3,"sources":["../../../src/state/mint.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError, TokenInvalidMintError, TokenOwnerOffCurveError, } from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport { getMintLen } from '../extensions/extensionType.js';\nimport { ACCOUNT_SIZE } from './account.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct([\n    u32('mintAuthorityOption'),\n    publicKey('mintAuthority'),\n    u64('supply'),\n    u8('decimals'),\n    bool('isInitialized'),\n    u32('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nexport async function getMint(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMint(address, info, programId);\n}\n/**\n * Unpack a mint\n *\n * @param address   Mint account\n * @param info      Mint account data\n * @param programId SPL Token program account\n *\n * @return Unpacked mint\n */\nexport function unpackMint(address, info, programId = TOKEN_PROGRAM_ID) {\n    if (!info)\n        throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId))\n        throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < MINT_SIZE)\n        throw new TokenInvalidAccountSizeError();\n    const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > MINT_SIZE) {\n        if (info.data.length <= ACCOUNT_SIZE)\n            throw new TokenInvalidAccountSizeError();\n        if (info.data.length === MULTISIG_SIZE)\n            throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Mint)\n            throw new TokenInvalidMintError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n    return {\n        address,\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n        supply: rawMint.supply,\n        decimals: rawMint.decimals,\n        isInitialized: rawMint.isInitialized,\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n        tlvData,\n    };\n}\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMint(connection, commitment) {\n    return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n}\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\n *\n * @param connection Connection to use\n * @param extensions Extension types included in the mint\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {\n    const mintLen = getMintLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n}\n/**\n * Async version of getAssociatedTokenAddressSync\n * For backwards compatibility\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Promise containing the address of the associated token account\n */\nexport async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))\n        throw new TokenOwnerOffCurveError();\n    const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n    return address;\n}\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nexport function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))\n        throw new TokenOwnerOffCurveError();\n    const [address] = PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n    return address;\n}\n//# sourceMappingURL=mint.js.map"]},"metadata":{},"sourceType":"module"}