{"ast":null,"code":"import * as beet from '@metaplex-foundation/beet';\nimport { FailedToSerializeDataError, FailedToDeserializeDataError, UnexpectedAccountError } from '../errors/SdkError.mjs';\n\nconst mapSerializer = (serializer, map, unmap) => ({\n  description: serializer.description,\n  serialize: value => serializer.serialize(unmap(value)),\n  deserialize: (buffer, offset) => {\n    const [value, newOffset] = serializer.deserialize(buffer, offset);\n    return [map(value), newOffset];\n  }\n});\n\nconst createSerializerFromBeet = beetArg => ({\n  description: beetArg.description,\n  serialize: value => {\n    const fixedBeet = beet.isFixableBeet(beetArg) ? beetArg.toFixedFromValue(value) : beetArg;\n    const writer = new beet.BeetWriter(fixedBeet.byteSize);\n    writer.write(fixedBeet, value);\n    return writer.buffer;\n  },\n  deserialize: (buffer, offset) => {\n    const fixedBeet = beet.isFixableBeet(beetArg) ? beetArg.toFixedFromData(buffer, offset ?? 0) : beetArg;\n    const reader = new beet.BeetReader(buffer, offset ?? 0);\n    const value = reader.read(fixedBeet);\n    return [value, reader.offset];\n  }\n});\n\nconst createSerializerFromSolitaType = (solitaType, description) => ({\n  description: description ?? solitaType.name,\n  serialize: value => {\n    return solitaType.fromArgs(value).serialize()[0];\n  },\n  deserialize: (buffer, offset) => {\n    return solitaType.deserialize(buffer, offset);\n  }\n});\n\nconst serialize = (value, serializer) => {\n  try {\n    return serializer.serialize(value);\n  } catch (error) {\n    throw new FailedToSerializeDataError(serializer.description, error);\n  }\n};\n\nconst deserialize = (value, serializer) => {\n  try {\n    return serializer.deserialize(value);\n  } catch (error) {\n    throw new FailedToDeserializeDataError(serializer.description, error);\n  }\n};\n\nfunction deserializeAccount(account, serializer) {\n  if ('exists' in account && !account.exists) {\n    return account;\n  }\n\n  try {\n    const data = serializer.deserialize(account.data)[0];\n    return { ...account,\n      data\n    };\n  } catch (error) {\n    throw new UnexpectedAccountError(account.publicKey, serializer.description, error);\n  }\n}\n\nconst serializeDiscriminator = discriminator => {\n  const serializer = createSerializerFromBeet(beet.uniformFixedSizeArray(beet.u8, 8));\n  return serialize(discriminator, serializer);\n};\n\nexport { createSerializerFromBeet, createSerializerFromSolitaType, deserialize, deserializeAccount, mapSerializer, serialize, serializeDiscriminator };","map":{"version":3,"sources":["../../../src/types/Serializer.ts"],"names":["mapSerializer","serializer","map","unmap","description","serialize","value","deserialize","buffer","offset","newOffset","createSerializerFromBeet","beetArg","fixedBeet","beet","isFixableBeet","toFixedFromValue","writer","BeetWriter","byteSize","write","toFixedFromData","reader","BeetReader","read","createSerializerFromSolitaType","solitaType","name","fromArgs","error","FailedToSerializeDataError","FailedToDeserializeDataError","deserializeAccount","account","exists","data","UnexpectedAccountError","publicKey","serializeDiscriminator","discriminator","uniformFixedSizeArray","u8"],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\nimport type { Beet } from '@metaplex-foundation/beet';\nimport * as beet from '@metaplex-foundation/beet';\nimport {\n  FailedToDeserializeDataError,\n  FailedToSerializeDataError,\n  UnexpectedAccountError,\n} from '../errors';\nimport {\n  Account,\n  MaybeAccount,\n  UnparsedAccount,\n  UnparsedMaybeAccount,\n} from './Account';\n\nexport type Serializer<T> = {\n  description: string;\n  serialize: (value: T) => Buffer;\n  deserialize: (buffer: Buffer, offset?: number) => [T, number];\n};\n\nexport const mapSerializer = <T, U>(\n  serializer: Serializer<T>,\n  map: (value: T) => U,\n  unmap: (value: U) => T\n): Serializer<U> => ({\n  description: serializer.description,\n  serialize: (value) => serializer.serialize(unmap(value)),\n  deserialize: (buffer, offset) => {\n    const [value, newOffset] = serializer.deserialize(buffer, offset);\n    return [map(value), newOffset];\n  },\n});\n\nexport const createSerializerFromBeet = <T>(\n  beetArg: Beet<T>\n): Serializer<T> => ({\n  description: beetArg.description,\n  serialize: (value: T) => {\n    const fixedBeet = beet.isFixableBeet(beetArg)\n      ? beetArg.toFixedFromValue(value)\n      : beetArg;\n    const writer = new beet.BeetWriter(fixedBeet.byteSize);\n    writer.write(fixedBeet, value);\n    return writer.buffer;\n  },\n  deserialize: (buffer: Buffer, offset?: number) => {\n    const fixedBeet = beet.isFixableBeet(beetArg)\n      ? beetArg.toFixedFromData(buffer, offset ?? 0)\n      : beetArg;\n    const reader = new beet.BeetReader(buffer, offset ?? 0);\n    const value = reader.read(fixedBeet);\n    return [value, reader.offset];\n  },\n});\n\nexport type SolitaType<T> = {\n  name: string;\n  deserialize: (data: Buffer, offset?: number) => [T, number];\n  fromArgs: (args: T) => {\n    serialize: () => [Buffer, number];\n  };\n};\n\nexport const createSerializerFromSolitaType = <T>(\n  solitaType: SolitaType<T>,\n  description?: string\n): Serializer<T> => ({\n  description: description ?? solitaType.name,\n  serialize: (value: T) => {\n    return solitaType.fromArgs(value).serialize()[0];\n  },\n  deserialize: (buffer: Buffer, offset?: number) => {\n    return solitaType.deserialize(buffer, offset);\n  },\n});\n\nexport const serialize = <T>(\n  value: T,\n  serializer: Pick<Serializer<T>, 'description' | 'serialize'>\n): Buffer => {\n  try {\n    return serializer.serialize(value);\n  } catch (error) {\n    throw new FailedToSerializeDataError(\n      serializer.description,\n      error as Error\n    );\n  }\n};\n\nexport const deserialize = <T>(\n  value: Buffer,\n  serializer: Pick<Serializer<T>, 'description' | 'deserialize'>\n): [T, number] => {\n  try {\n    return serializer.deserialize(value);\n  } catch (error) {\n    throw new FailedToDeserializeDataError(\n      serializer.description,\n      error as Error\n    );\n  }\n};\n\nexport function deserializeAccount<T>(\n  account: UnparsedMaybeAccount,\n  serializer: Pick<Serializer<T>, 'description' | 'deserialize'>\n): MaybeAccount<T>;\nexport function deserializeAccount<T>(\n  account: UnparsedAccount,\n  serializer: Pick<Serializer<T>, 'description' | 'deserialize'>\n): Account<T>;\nexport function deserializeAccount<T>(\n  account: UnparsedAccount | UnparsedMaybeAccount,\n  serializer: Pick<Serializer<T>, 'description' | 'deserialize'>\n): Account<T> | MaybeAccount<T> {\n  if ('exists' in account && !account.exists) {\n    return account;\n  }\n\n  try {\n    const data: T = serializer.deserialize(account.data)[0];\n    return { ...account, data };\n  } catch (error) {\n    throw new UnexpectedAccountError(\n      account.publicKey,\n      serializer.description,\n      error as Error\n    );\n  }\n}\n\nexport const serializeDiscriminator = (discriminator: number[]): Buffer => {\n  const serializer = createSerializerFromBeet(\n    beet.uniformFixedSizeArray(beet.u8, 8)\n  );\n  return serialize(discriminator, serializer);\n};\n"]},"metadata":{},"sourceType":"module"}