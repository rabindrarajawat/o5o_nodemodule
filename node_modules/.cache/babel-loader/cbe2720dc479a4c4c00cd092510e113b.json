{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport { freezeTokenPaymentBeet, FreezeInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport { MintOwnerMustBeMintPayerError, UnrecognizePathForRouteInstructionError } from '../errors.mjs';\nimport assert from '../../../utils/assert.mjs';\nimport { mapSerializer, createSerializerFromBeet } from '../../../types/Serializer.mjs';\nimport { token } from '../../../types/Amount.mjs';\n/**\n * The freezeTokenPayment guard allows minting frozen NFTs by charging\n * the payer a specific amount of tokens from a certain mint acount.\n * Frozen NFTs cannot be transferred or listed on any marketplaces until thawed.\n *\n * The funds are transferred to a freeze escrow until all NFTs are thaw,\n * at which point, they can be transferred (unlocked) to the configured\n * destination account.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link FreezeTokenPaymentGuardRouteSettings} to learn more about\n * the instructions that can be executed against this guard.\n */\n\n/** @internal */\n\nconst freezeTokenPaymentGuardManifest = {\n  name: 'freezeTokenPayment',\n  settingsBytes: 72,\n  settingsSerializer: mapSerializer(createSerializerFromBeet(freezeTokenPaymentBeet), settings => ({\n    mint: settings.mint,\n    amount: token(settings.amount),\n    destinationAta: settings.destinationAta\n  }), settings => ({\n    mint: settings.mint,\n    amount: settings.amount.basisPoints,\n    destinationAta: settings.destinationAta\n  })),\n  mintSettingsParser: _ref => {\n    let {\n      metaplex,\n      settings,\n      owner,\n      payer,\n      mint: nftMint,\n      candyMachine,\n      candyGuard,\n      programs\n    } = _ref;\n\n    if (!owner.equals(payer.publicKey)) {\n      throw new MintOwnerMustBeMintPayerError('freezeTokenPayment');\n    }\n\n    const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n      destination: settings.destinationAta,\n      candyMachine,\n      candyGuard,\n      programs\n    });\n    const nftAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: nftMint.publicKey,\n      owner: payer.publicKey\n    });\n    const tokenAddress = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: settings.mint,\n      owner: payer.publicKey,\n      programs\n    });\n    const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: settings.mint,\n      owner: freezeEscrow,\n      programs\n    });\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [{\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true\n      }, {\n        isSigner: false,\n        address: nftAta,\n        isWritable: false\n      }, {\n        isSigner: false,\n        address: tokenAddress,\n        isWritable: true\n      }, {\n        isSigner: false,\n        address: freezeAta,\n        isWritable: true\n      }]\n    };\n  },\n  routeSettingsParser: input => {\n    switch (input.routeSettings.path) {\n      case 'initialize':\n        return initializeRouteInstruction(input);\n\n      case 'thaw':\n        return thawRouteInstruction(input);\n\n      case 'unlockFunds':\n        return unlockFundsRouteInstruction(input);\n\n      default:\n        throw new UnrecognizePathForRouteInstructionError('freezeTokenPayment', // @ts-ignore\n        input.routeSettings.path);\n    }\n  }\n};\n\nfunction initializeRouteInstruction(_ref2) {\n  let {\n    metaplex,\n    settings,\n    routeSettings,\n    candyMachine,\n    candyGuard,\n    programs\n  } = _ref2;\n  assert(routeSettings.path === 'initialize');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destinationAta,\n    candyMachine,\n    candyGuard,\n    programs\n  });\n  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: settings.mint,\n    owner: freezeEscrow,\n    programs\n  });\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const associatedTokenProgram = metaplex.programs().getAssociatedToken(programs);\n  const args = Buffer.alloc(9);\n  beet.u8.write(args, 0, FreezeInstruction.Initialize);\n  beet.u64.write(args, 1, routeSettings.period);\n  return {\n    arguments: args,\n    remainingAccounts: [{\n      isSigner: false,\n      address: freezeEscrow,\n      isWritable: true\n    }, {\n      isSigner: true,\n      address: routeSettings.candyGuardAuthority,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: systemProgram.address,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: freezeAta,\n      isWritable: true\n    }, {\n      isSigner: false,\n      address: settings.mint,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: tokenProgram.address,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: associatedTokenProgram.address,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: settings.destinationAta,\n      isWritable: true\n    }]\n  };\n}\n\nfunction thawRouteInstruction(_ref3) {\n  let {\n    metaplex,\n    settings,\n    routeSettings,\n    candyMachine,\n    candyGuard,\n    programs\n  } = _ref3;\n  assert(routeSettings.path === 'thaw');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destinationAta,\n    candyMachine,\n    candyGuard,\n    programs\n  });\n  const nftAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: routeSettings.nftMint,\n    owner: routeSettings.nftOwner,\n    programs\n  });\n  const nftEdition = metaplex.nfts().pdas().masterEdition({\n    mint: routeSettings.nftMint,\n    programs\n  });\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const args = Buffer.alloc(1);\n  beet.u8.write(args, 0, FreezeInstruction.Thaw);\n  return {\n    arguments: args,\n    remainingAccounts: [{\n      isSigner: false,\n      address: freezeEscrow,\n      isWritable: true\n    }, {\n      isSigner: false,\n      address: routeSettings.nftMint,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: routeSettings.nftOwner,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: nftAta,\n      isWritable: true\n    }, {\n      isSigner: false,\n      address: nftEdition,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: tokenProgram.address,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: tokenMetadataProgram.address,\n      isWritable: false\n    }]\n  };\n}\n\nfunction unlockFundsRouteInstruction(_ref4) {\n  let {\n    metaplex,\n    settings,\n    routeSettings,\n    candyMachine,\n    candyGuard,\n    programs\n  } = _ref4;\n  assert(routeSettings.path === 'unlockFunds');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destinationAta,\n    candyMachine,\n    candyGuard,\n    programs\n  });\n  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: settings.mint,\n    owner: freezeEscrow,\n    programs\n  });\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const args = Buffer.alloc(1);\n  beet.u8.write(args, 0, FreezeInstruction.UnlockFunds);\n  return {\n    arguments: args,\n    remainingAccounts: [{\n      isSigner: false,\n      address: freezeEscrow,\n      isWritable: true\n    }, {\n      isSigner: true,\n      address: routeSettings.candyGuardAuthority,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: freezeAta,\n      isWritable: true\n    }, {\n      isSigner: false,\n      address: settings.destinationAta,\n      isWritable: true\n    }, {\n      isSigner: false,\n      address: tokenProgram.address,\n      isWritable: false\n    }, {\n      isSigner: false,\n      address: systemProgram.address,\n      isWritable: false\n    }]\n  };\n}\n\nexport { freezeTokenPaymentGuardManifest };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineModule/guards/freezeTokenPayment.ts"],"names":["freezeTokenPaymentGuardManifest","name","settingsBytes","settingsSerializer","mapSerializer","createSerializerFromBeet","freezeTokenPaymentBeet","settings","mint","amount","token","destinationAta","basisPoints","mintSettingsParser","metaplex","owner","payer","nftMint","candyMachine","candyGuard","programs","equals","publicKey","MintOwnerMustBeMintPayerError","freezeEscrow","candyMachines","pdas","destination","nftAta","tokens","associatedTokenAccount","tokenAddress","freezeAta","arguments","Buffer","from","remainingAccounts","isSigner","address","isWritable","routeSettingsParser","input","routeSettings","path","initializeRouteInstruction","thawRouteInstruction","unlockFundsRouteInstruction","UnrecognizePathForRouteInstructionError","assert","systemProgram","getSystem","tokenProgram","getToken","associatedTokenProgram","getAssociatedToken","args","alloc","beet","u8","write","FreezeInstruction","Initialize","u64","period","candyGuardAuthority","nftOwner","nftEdition","nfts","masterEdition","tokenMetadataProgram","getTokenMetadata","Thaw","UnlockFunds"],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport {\n  FreezeInstruction,\n  FreezeTokenPayment,\n  freezeTokenPaymentBeet,\n} from '@metaplex-foundation/mpl-candy-guard';\nimport {\n  MintOwnerMustBeMintPayerError,\n  UnrecognizePathForRouteInstructionError,\n} from '../errors';\nimport {\n  CandyGuardManifest,\n  CandyGuardsRemainingAccount,\n  RouteSettingsParserInput,\n} from './core';\nimport { assert } from '@/utils';\nimport {\n  createSerializerFromBeet,\n  mapSerializer,\n  PublicKey,\n  Signer,\n  SplTokenAmount,\n  token,\n} from '@/types';\n\n/**\n * The freezeTokenPayment guard allows minting frozen NFTs by charging\n * the payer a specific amount of tokens from a certain mint acount.\n * Frozen NFTs cannot be transferred or listed on any marketplaces until thawed.\n *\n * The funds are transferred to a freeze escrow until all NFTs are thaw,\n * at which point, they can be transferred (unlocked) to the configured\n * destination account.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link FreezeTokenPaymentGuardRouteSettings} to learn more about\n * the instructions that can be executed against this guard.\n */\nexport type FreezeTokenPaymentGuardSettings = {\n  /** The mint address of the required tokens. */\n  mint: PublicKey;\n\n  /** The amount of tokens required to mint an NFT. */\n  amount: SplTokenAmount;\n\n  /** The associated token address to send the tokens to. */\n  destinationAta: PublicKey;\n};\n\n/**\n * The settings for the freezeTokenPayment guard that should be provided\n * when accessing the guard's special \"route\" instruction.\n *\n * ## Initialize\n * The `initialize` path creates the freeze escrow account that will\n * hold the funds until all NFTs are thawed. It must be called before\n * any NFTs can be minted.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'freezeTokenPayment',\n *   settings: {\n *     path: 'initialize',\n *     period: 15 * 24 * 60 * 60, // 15 days.\n *     candyGuardAuthority,\n *   },\n * });\n * ```\n *\n * ## Thaw\n * The `thaw` path unfreezes one NFT if one of the following conditions are met:\n * - All NFTs have been minted.\n * - The configured period has elapsed (max 30 days).\n * - The Candy Machine account was deleted.\n *\n * Anyone can call this instruction. Since the funds are not transferrable\n * until all NFTs are thawed, it creates an incentive for the treasury to\n * thaw all NFTs as soon as possible.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'freezeTokenPayment',\n *   settings: {\n *     path: 'thaw',\n *     nftMint: nftToThaw.address,\n *     nftOwner: nftToThaw.token.ownerAddress,\n *   },\n * });\n * ```\n *\n * ## Unlock Funds\n * The `unlockFunds` path transfers all of the escrow funds to the\n * configured destination token address once all NFTs have been thawed.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'freezeTokenPayment',\n *   settings: {\n *     path: 'unlockFunds',\n *     candyGuardAuthority,\n *   },\n * });\n * ```\n *\n * @see {@link FreezeTokenPaymentGuardSettings} for more\n * information on the freezeTokenPayment guard itself.\n */\nexport type FreezeTokenPaymentGuardRouteSettings =\n  | {\n      /** Selects the path to execute in the route instruction. */\n      path: 'initialize';\n\n      /** The freeze period in seconds (maximum 30 days). */\n      period: number;\n\n      /** The authority of the Candy Guard as a Signer. */\n      candyGuardAuthority: Signer;\n    }\n  | {\n      /** Selects the path to execute in the route instruction. */\n      path: 'thaw';\n\n      /** The mint address of the NFT to thaw. */\n      nftMint: PublicKey;\n\n      /** The owner address of the NFT to thaw. */\n      nftOwner: PublicKey;\n    }\n  | {\n      /** Selects the path to execute in the route instruction. */\n      path: 'unlockFunds';\n\n      /** The authority of the Candy Guard as a Signer. */\n      candyGuardAuthority: Signer;\n    };\n\n/** @internal */\nexport const freezeTokenPaymentGuardManifest: CandyGuardManifest<\n  FreezeTokenPaymentGuardSettings,\n  {},\n  FreezeTokenPaymentGuardRouteSettings\n> = {\n  name: 'freezeTokenPayment',\n  settingsBytes: 72,\n  settingsSerializer: mapSerializer<\n    FreezeTokenPayment,\n    FreezeTokenPaymentGuardSettings\n  >(\n    createSerializerFromBeet(freezeTokenPaymentBeet),\n    (settings) => ({\n      mint: settings.mint,\n      amount: token(settings.amount),\n      destinationAta: settings.destinationAta,\n    }),\n    (settings) => ({\n      mint: settings.mint,\n      amount: settings.amount.basisPoints,\n      destinationAta: settings.destinationAta,\n    })\n  ),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    owner,\n    payer,\n    mint: nftMint,\n    candyMachine,\n    candyGuard,\n    programs,\n  }) => {\n    if (!owner.equals(payer.publicKey)) {\n      throw new MintOwnerMustBeMintPayerError('freezeTokenPayment');\n    }\n\n    const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n      destination: settings.destinationAta,\n      candyMachine,\n      candyGuard,\n      programs,\n    });\n    const nftAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: nftMint.publicKey,\n      owner: payer.publicKey,\n    });\n    const tokenAddress = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: settings.mint,\n      owner: payer.publicKey,\n      programs,\n    });\n    const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: settings.mint,\n      owner: freezeEscrow,\n      programs,\n    });\n\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          address: freezeEscrow,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: nftAta,\n          isWritable: false,\n        },\n        {\n          isSigner: false,\n          address: tokenAddress,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: freezeAta,\n          isWritable: true,\n        },\n      ],\n    };\n  },\n  routeSettingsParser: (input) => {\n    switch (input.routeSettings.path) {\n      case 'initialize':\n        return initializeRouteInstruction(input);\n      case 'thaw':\n        return thawRouteInstruction(input);\n      case 'unlockFunds':\n        return unlockFundsRouteInstruction(input);\n      default:\n        throw new UnrecognizePathForRouteInstructionError(\n          'freezeTokenPayment',\n          // @ts-ignore\n          input.routeSettings.path\n        );\n    }\n  },\n};\n\nfunction initializeRouteInstruction({\n  metaplex,\n  settings,\n  routeSettings,\n  candyMachine,\n  candyGuard,\n  programs,\n}: RouteSettingsParserInput<\n  FreezeTokenPaymentGuardSettings,\n  FreezeTokenPaymentGuardRouteSettings\n>) {\n  assert(routeSettings.path === 'initialize');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destinationAta,\n    candyMachine,\n    candyGuard,\n    programs,\n  });\n  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: settings.mint,\n    owner: freezeEscrow,\n    programs,\n  });\n\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const associatedTokenProgram = metaplex\n    .programs()\n    .getAssociatedToken(programs);\n\n  const args = Buffer.alloc(9);\n  beet.u8.write(args, 0, FreezeInstruction.Initialize);\n  beet.u64.write(args, 1, routeSettings.period);\n\n  return {\n    arguments: args,\n    remainingAccounts: [\n      {\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true,\n      },\n      {\n        isSigner: true,\n        address: routeSettings.candyGuardAuthority,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: systemProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: freezeAta,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: settings.mint,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: tokenProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: associatedTokenProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: settings.destinationAta,\n        isWritable: true,\n      },\n    ] as CandyGuardsRemainingAccount[],\n  };\n}\n\nfunction thawRouteInstruction({\n  metaplex,\n  settings,\n  routeSettings,\n  candyMachine,\n  candyGuard,\n  programs,\n}: RouteSettingsParserInput<\n  FreezeTokenPaymentGuardSettings,\n  FreezeTokenPaymentGuardRouteSettings\n>) {\n  assert(routeSettings.path === 'thaw');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destinationAta,\n    candyMachine,\n    candyGuard,\n    programs,\n  });\n  const nftAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: routeSettings.nftMint,\n    owner: routeSettings.nftOwner,\n    programs,\n  });\n  const nftEdition = metaplex.nfts().pdas().masterEdition({\n    mint: routeSettings.nftMint,\n    programs,\n  });\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  const args = Buffer.alloc(1);\n  beet.u8.write(args, 0, FreezeInstruction.Thaw);\n\n  return {\n    arguments: args,\n    remainingAccounts: [\n      {\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: routeSettings.nftMint,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: routeSettings.nftOwner,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: nftAta,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: nftEdition,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: tokenProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: tokenMetadataProgram.address,\n        isWritable: false,\n      },\n    ] as CandyGuardsRemainingAccount[],\n  };\n}\n\nfunction unlockFundsRouteInstruction({\n  metaplex,\n  settings,\n  routeSettings,\n  candyMachine,\n  candyGuard,\n  programs,\n}: RouteSettingsParserInput<\n  FreezeTokenPaymentGuardSettings,\n  FreezeTokenPaymentGuardRouteSettings\n>) {\n  assert(routeSettings.path === 'unlockFunds');\n  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({\n    destination: settings.destinationAta,\n    candyMachine,\n    candyGuard,\n    programs,\n  });\n  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: settings.mint,\n    owner: freezeEscrow,\n    programs,\n  });\n\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n\n  const args = Buffer.alloc(1);\n  beet.u8.write(args, 0, FreezeInstruction.UnlockFunds);\n\n  return {\n    arguments: args,\n    remainingAccounts: [\n      {\n        isSigner: false,\n        address: freezeEscrow,\n        isWritable: true,\n      },\n      {\n        isSigner: true,\n        address: routeSettings.candyGuardAuthority,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: freezeAta,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: settings.destinationAta,\n        isWritable: true,\n      },\n      {\n        isSigner: false,\n        address: tokenProgram.address,\n        isWritable: false,\n      },\n      {\n        isSigner: false,\n        address: systemProgram.address,\n        isWritable: false,\n      },\n    ] as CandyGuardsRemainingAccount[],\n  };\n}\n"]},"metadata":{},"sourceType":"module"}