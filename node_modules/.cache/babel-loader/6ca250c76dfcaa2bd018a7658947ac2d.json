{"ast":null,"code":"import { assertCandyGuardProgram } from '../programs.mjs';\nimport { toCandyMachine } from '../models/CandyMachine.mjs';\nimport { assertAccountExists } from '../../../types/Account.mjs';\nimport { toCandyGuard } from '../models/CandyGuard.mjs';\nimport { PublicKey } from '@solana/web3.js'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindCandyMachineByAddressOperation';\n/**\n * Find an existing Candy Machine by its address.\n *\n * ```ts\n * const candyMachine = await metaplex\n *   .candyMachines()\n *   .findbyAddress({ address };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst findCandyMachineByAddressOperation = _findCandyMachineByAddressOperation; // eslint-disable-next-line @typescript-eslint/naming-convention\n\nfunction _findCandyMachineByAddressOperation(input) {\n  return {\n    key: Key,\n    input\n  };\n}\n\n_findCandyMachineByAddressOperation.key = Key;\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst findCandyMachineByAddressOperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const {\n      address\n    } = operation.input;\n    const {\n      commitment,\n      programs\n    } = scope;\n    const potentialCandyGuardAddress = metaplex.candyMachines().pdas().candyGuard({\n      base: address,\n      programs\n    });\n    const [candyMachineAccount, potentialCandyGuardAccount] = await metaplex.rpc().getMultipleAccounts([address, potentialCandyGuardAddress], commitment);\n    scope.throwIfCanceled();\n    assertAccountExists(candyMachineAccount, 'CandyMachine');\n    const candyMachine = toCandyMachine(candyMachineAccount);\n    const mintAuthority = candyMachine.mintAuthorityAddress; // Optimisation that tries to load both the Candy Machine\n    // And the Candy Guard in one RPC call assuming the Candy\n    // Machine's address is the base address of the Candy Guard.\n\n    if (potentialCandyGuardAccount.exists && potentialCandyGuardAccount.publicKey.equals(mintAuthority)) {\n      return { ...candyMachine,\n        candyGuard: toCandyGuard(potentialCandyGuardAccount, metaplex)\n      };\n    } // If the Candy Machine's mint authority is not a PDA,\n    // it cannot have an associated Candy Guard.\n    // TODO(loris): Does not seem to work when the Candy Guard does not derive from the Candy Machine.\n\n\n    if (PublicKey.isOnCurve(mintAuthority)) {\n      return candyMachine;\n    } // Fetch the content of the mint authority PDA.\n\n\n    const mintAuthorityAccount = await metaplex.rpc().getAccount(mintAuthority, commitment);\n    scope.throwIfCanceled();\n\n    try {\n      // Identity the program owner as a Candy Guard program\n      // and parse the Candy Guard accordingly.\n      assertAccountExists(mintAuthorityAccount);\n      const program = metaplex.programs().get(mintAuthorityAccount.owner);\n      assertCandyGuardProgram(program);\n      return { ...candyMachine,\n        candyGuard: toCandyGuard(mintAuthorityAccount, metaplex)\n      };\n    } catch (error) {\n      // If anything goes wrong, assume there is no Candy Guard\n      // attached to this Candy Machine.\n      return candyMachine;\n    }\n  }\n\n};\nexport { findCandyMachineByAddressOperation, findCandyMachineByAddressOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineModule/operations/findCandyMachineByAddress.ts"],"names":["Key","findCandyMachineByAddressOperation","_findCandyMachineByAddressOperation","input","key","findCandyMachineByAddressOperationHandler","handle","operation","metaplex","scope","address","commitment","programs","potentialCandyGuardAddress","candyMachines","pdas","candyGuard","base","candyMachineAccount","potentialCandyGuardAccount","rpc","getMultipleAccounts","throwIfCanceled","assertAccountExists","candyMachine","toCandyMachine","mintAuthority","mintAuthorityAddress","exists","publicKey","equals","toCandyGuard","PublicKey","isOnCurve","mintAuthorityAccount","getAccount","program","get","owner","assertCandyGuardProgram","error"],"mappings":";;;;6CAYA;AACA;AACA;;AAEA,MAAMA,GAAG,GAAG,oCAAZ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,MAAMC,kCAAkC,GAC7CC,mCADK,C,CAEP;;AACA,SAASA,mCAAT,CAGEC,KAHF,EAIyC;EACvC,OAAO;IAAEC,GAAG,EAAEJ,GAAP;IAAYG;EAAZ,CAAP;AACF;;AACAD,mCAAmC,CAACE,GAApCF,GAA0CF,GAA1CE;AAEA;AACA;AACA;AACA;;AAcA;AACA;AACA;AACA;;AACO,MAAMG,yCAA+F,GAC1G;EACE,MAAMC,MAAN,CACEC,SADF,EAEEC,QAFF,EAGEC,KAHF,EAIE;IACA,MAAM;MAAEC;IAAF,IAAcH,SAAS,CAACJ,KAA9B;IACA,MAAM;MAAEQ,UAAF;MAAcC;IAAd,IAA2BH,KAAjC;IACA,MAAMI,0BAA0B,GAAGL,QAAQ,CACxCM,aADgCN,GAEhCO,IAFgCP,GAGhCQ,UAHgCR,CAGrB;MAAES,IAAI,EAAEP,OAAR;MAAiBE;IAAjB,CAHqBJ,CAAnC;IAIA,MAAM,CAACU,mBAAD,EAAsBC,0BAAtB,IAAoD,MAAMX,QAAQ,CACrEY,GAD6DZ,GAE7Da,mBAF6Db,CAEzC,CAACE,OAAD,EAAUG,0BAAV,CAFyCL,EAEFG,UAFEH,CAAhE;IAGAC,KAAK,CAACa,eAANb;IAEAc,mBAAmB,CAACL,mBAAD,EAAsB,cAAtB,CAAnBK;IACA,MAAMC,YAAY,GAAGC,cAAc,CAAIP,mBAAJ,CAAnC;IACA,MAAMQ,aAAa,GAAGF,YAAY,CAACG,oBAAnC,CAdA,CAgBA;IACA;IACA;;IACA,IACER,0BAA0B,CAACS,MAA3BT,IACAA,0BAA0B,CAACU,SAA3BV,CAAqCW,MAArCX,CAA4CO,aAA5CP,CAFF,EAGE;MACA,OAAO,EACL,GAAGK,YADE;QAELR,UAAU,EAAEe,YAAY,CAAIZ,0BAAJ,EAAgCX,QAAhC;MAFnB,CAAP;IAIF,CA3BA,CA6BA;IACA;IACA;;;IACA,IAAIwB,SAAS,CAACC,SAAVD,CAAoBN,aAApBM,CAAJ,EAAwC;MACtC,OAAOR,YAAP;IACF,CAlCA,CAoCA;;;IACA,MAAMU,oBAAoB,GAAG,MAAM1B,QAAQ,CACxCY,GADgCZ,GAEhC2B,UAFgC3B,CAErBkB,aAFqBlB,EAENG,UAFMH,CAAnC;IAGAC,KAAK,CAACa,eAANb;;IAEA,IAAI;MACF;MACA;MACAc,mBAAmB,CAACW,oBAAD,CAAnBX;MACA,MAAMa,OAAO,GAAG5B,QAAQ,CAACI,QAATJ,GAAoB6B,GAApB7B,CAAwB0B,oBAAoB,CAACI,KAA7C9B,CAAhB;MACA+B,uBAAuB,CAACH,OAAD,CAAvBG;MAEA,OAAO,EACL,GAAGf,YADE;QAELR,UAAU,EAAEe,YAAY,CAAIG,oBAAJ,EAA0B1B,QAA1B;MAFnB,CAAP;IAID,CAXD,CAWE,OAAOgC,KAAP,EAAc;MACd;MACA;MACA,OAAOhB,YAAP;IACF;EACF;;AA/DF,CADK","sourcesContent":["import { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport { CandyMachine, toCandyGuard, toCandyMachine } from '../models';\nimport { assertCandyGuardProgram } from '../programs';\nimport {\n  assertAccountExists,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindCandyMachineByAddressOperation' as const;\n\n/**\n * Find an existing Candy Machine by its address.\n *\n * ```ts\n * const candyMachine = await metaplex\n *   .candyMachines()\n *   .findbyAddress({ address };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findCandyMachineByAddressOperation =\n  _findCandyMachineByAddressOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _findCandyMachineByAddressOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  input: FindCandyMachineByAddressInput\n): FindCandyMachineByAddressOperation<T> {\n  return { key: Key, input };\n}\n_findCandyMachineByAddressOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindCandyMachineByAddressOperation<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Operation<typeof Key, FindCandyMachineByAddressInput, CandyMachine<T>>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindCandyMachineByAddressInput = {\n  /** The Candy Machine address. */\n  address: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findCandyMachineByAddressOperationHandler: OperationHandler<FindCandyMachineByAddressOperation> =\n  {\n    async handle<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n      operation: FindCandyMachineByAddressOperation<T>,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) {\n      const { address } = operation.input;\n      const { commitment, programs } = scope;\n      const potentialCandyGuardAddress = metaplex\n        .candyMachines()\n        .pdas()\n        .candyGuard({ base: address, programs });\n      const [candyMachineAccount, potentialCandyGuardAccount] = await metaplex\n        .rpc()\n        .getMultipleAccounts([address, potentialCandyGuardAddress], commitment);\n      scope.throwIfCanceled();\n\n      assertAccountExists(candyMachineAccount, 'CandyMachine');\n      const candyMachine = toCandyMachine<T>(candyMachineAccount);\n      const mintAuthority = candyMachine.mintAuthorityAddress;\n\n      // Optimisation that tries to load both the Candy Machine\n      // And the Candy Guard in one RPC call assuming the Candy\n      // Machine's address is the base address of the Candy Guard.\n      if (\n        potentialCandyGuardAccount.exists &&\n        potentialCandyGuardAccount.publicKey.equals(mintAuthority)\n      ) {\n        return {\n          ...candyMachine,\n          candyGuard: toCandyGuard<T>(potentialCandyGuardAccount, metaplex),\n        };\n      }\n\n      // If the Candy Machine's mint authority is not a PDA,\n      // it cannot have an associated Candy Guard.\n      // TODO(loris): Does not seem to work when the Candy Guard does not derive from the Candy Machine.\n      if (PublicKey.isOnCurve(mintAuthority)) {\n        return candyMachine;\n      }\n\n      // Fetch the content of the mint authority PDA.\n      const mintAuthorityAccount = await metaplex\n        .rpc()\n        .getAccount(mintAuthority, commitment);\n      scope.throwIfCanceled();\n\n      try {\n        // Identity the program owner as a Candy Guard program\n        // and parse the Candy Guard accordingly.\n        assertAccountExists(mintAuthorityAccount);\n        const program = metaplex.programs().get(mintAuthorityAccount.owner);\n        assertCandyGuardProgram(program);\n\n        return {\n          ...candyMachine,\n          candyGuard: toCandyGuard<T>(mintAuthorityAccount, metaplex),\n        };\n      } catch (error) {\n        // If anything goes wrong, assume there is no Candy Guard\n        // attached to this Candy Machine.\n        return candyMachine;\n      }\n    },\n  };\n"]},"metadata":{},"sourceType":"module"}