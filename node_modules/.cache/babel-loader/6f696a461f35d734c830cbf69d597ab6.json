{"ast":null,"code":"import { fixBeetFromData, fixBeetFromValue } from './beet.fixable';\nimport { BeetStruct } from './struct';\nimport { isFixedSizeBeet } from './types';\nimport { strict as assert } from 'assert';\nimport { beetBytes, logDebug } from './utils';\nimport colors from 'ansicolors';\nconst {\n  brightBlack\n} = colors;\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. Not all fields of that class have to be of fixed size.\n * If none of the fields requires a {@link FixableBeet} use the {@link BeetStruct} instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */\n\nexport class FixableBeetStruct {\n  /**\n   * Creates an instance of the {@link FixableBeetStruct}.\n   *\n   * @param fields fixed or fixable de/serializers for each field of the {@link Class}\n   * @param construct the function that creates an instance of {@link Class}\n   * from the args\n   * @param description identifies this struct for diagnostics/debugging\n   * purposes\n   */\n  constructor(fields, construct) {\n    let description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : FixableBeetStruct.description;\n    this.fields = fields;\n    this.construct = construct;\n    this.description = description;\n    let minByteSize = 0;\n\n    if (logDebug.enabled) {\n      const flds = fields.map(_ref => {\n        let [key, val] = _ref;\n\n        if (isFixedSizeBeet(val)) {\n          minByteSize += val.byteSize;\n        }\n\n        return `${key}: ${val.description} ${beetBytes(val)}`;\n      }).join('\\n  ');\n      const bytes = `> ${minByteSize} B`;\n      logDebug(`struct ${description} {\\n  ${flds}\\n} ${brightBlack(bytes)}`);\n    }\n  }\n  /**\n   * Deserializes an instance of the Class from the provided buffer starting to\n   * read at the provided offset.\n   *\n   * @returns `[instance of Class, offset into buffer after deserialization completed]`\n   */\n\n\n  deserialize(buffer) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return this.toFixedFromData(buffer, offset).deserialize(buffer, offset);\n  }\n  /**\n   * Serializes the provided instance into a new {@link Buffer}\n   *\n   * **NOTE:** that the `instance` is traversed and each of its fields accessed\n   * twice, once to derive a _fixed size_ {@link BeetStruct} and then use it to\n   * serialize the `instance`.\n   * Therefore ensure that none of the properties that are part of the struct\n   * have side effects, i.e. via `Getter`s.\n   *\n   * @param instance of the struct to serialize\n   * @param byteSize allows to override the size fo the created Buffer and\n   * defaults to the size of the struct to serialize\n   */\n\n\n  serialize(instance, byteSize) {\n    return this.toFixedFromValue(instance).serialize(instance, byteSize);\n  }\n\n  toFixedFromData(buf, offset) {\n    let cursor = offset;\n    const fixedFields = new Array(this.fields.length);\n\n    for (let i = 0; i < this.fields.length; i++) {\n      const [key, beet] = this.fields[i];\n      const fixedBeet = fixBeetFromData(beet, buf, cursor);\n      fixedFields[i] = [key, fixedBeet];\n      cursor += fixedBeet.byteSize;\n    }\n\n    return this.description !== FixableBeetStruct.description ? new BeetStruct(fixedFields, this.construct, this.description) : new BeetStruct(fixedFields, this.construct);\n  }\n\n  toFixedFromValue(args) {\n    const argsKeys = Object.keys(args);\n    const fixedFields = new Array(this.fields.length);\n\n    for (let i = 0; i < this.fields.length; i++) {\n      const [key, beet] = this.fields[i];\n      assert(argsKeys.includes(key), `Value with keys [ ${argsKeys} ] should include struct key '${key}' but doesn't.`);\n      const val = args[key];\n      const fixedBeet = fixBeetFromValue(beet, val);\n      fixedFields[i] = [key, fixedBeet];\n    }\n\n    return this.description !== FixableBeetStruct.description ? new BeetStruct(fixedFields, this.construct, this.description) : new BeetStruct(fixedFields, this.construct);\n  }\n\n  get type() {\n    return FixableBeetStruct.TYPE;\n  }\n\n}\nFixableBeetStruct.description = 'FixableBeetStruct';\nFixableBeetStruct.TYPE = 'FixableBeetStruct';\nexport function isFixableBeetStruct(beet) {\n  return beet.type === FixableBeetStruct.TYPE;\n}\n/**\n * Convenience wrapper around {@link FixableBeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */\n\nexport class FixableBeetArgsStruct extends FixableBeetStruct {\n  constructor(fields) {\n    let description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FixableBeetArgsStruct.description;\n    super(fields, args => args, description);\n  }\n\n}\nFixableBeetArgsStruct.description = 'FixableBeetArgsStruct';","map":{"version":3,"sources":["../../../src/struct.fixable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { fixBeetFromData, fixBeetFromValue } from './beet.fixable';\nimport { BeetStruct } from './struct';\nimport { isFixedSizeBeet } from './types';\nimport { strict as assert } from 'assert';\nimport { beetBytes, logDebug } from './utils';\nimport colors from 'ansicolors';\nconst { brightBlack } = colors;\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. Not all fields of that class have to be of fixed size.\n * If none of the fields requires a {@link FixableBeet} use the {@link BeetStruct} instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */\nexport class FixableBeetStruct {\n    /**\n     * Creates an instance of the {@link FixableBeetStruct}.\n     *\n     * @param fields fixed or fixable de/serializers for each field of the {@link Class}\n     * @param construct the function that creates an instance of {@link Class}\n     * from the args\n     * @param description identifies this struct for diagnostics/debugging\n     * purposes\n     */\n    constructor(fields, construct, description = FixableBeetStruct.description) {\n        this.fields = fields;\n        this.construct = construct;\n        this.description = description;\n        let minByteSize = 0;\n        if (logDebug.enabled) {\n            const flds = fields\n                .map(([key, val]) => {\n                if (isFixedSizeBeet(val)) {\n                    minByteSize += val.byteSize;\n                }\n                return `${key}: ${val.description} ${beetBytes(val)}`;\n            })\n                .join('\\n  ');\n            const bytes = `> ${minByteSize} B`;\n            logDebug(`struct ${description} {\\n  ${flds}\\n} ${brightBlack(bytes)}`);\n        }\n    }\n    /**\n     * Deserializes an instance of the Class from the provided buffer starting to\n     * read at the provided offset.\n     *\n     * @returns `[instance of Class, offset into buffer after deserialization completed]`\n     */\n    deserialize(buffer, offset = 0) {\n        return this.toFixedFromData(buffer, offset).deserialize(buffer, offset);\n    }\n    /**\n     * Serializes the provided instance into a new {@link Buffer}\n     *\n     * **NOTE:** that the `instance` is traversed and each of its fields accessed\n     * twice, once to derive a _fixed size_ {@link BeetStruct} and then use it to\n     * serialize the `instance`.\n     * Therefore ensure that none of the properties that are part of the struct\n     * have side effects, i.e. via `Getter`s.\n     *\n     * @param instance of the struct to serialize\n     * @param byteSize allows to override the size fo the created Buffer and\n     * defaults to the size of the struct to serialize\n     */\n    serialize(instance, byteSize) {\n        return this.toFixedFromValue(instance).serialize(instance, byteSize);\n    }\n    toFixedFromData(buf, offset) {\n        let cursor = offset;\n        const fixedFields = new Array(this.fields.length);\n        for (let i = 0; i < this.fields.length; i++) {\n            const [key, beet] = this.fields[i];\n            const fixedBeet = fixBeetFromData(beet, buf, cursor);\n            fixedFields[i] = [key, fixedBeet];\n            cursor += fixedBeet.byteSize;\n        }\n        return this.description !== FixableBeetStruct.description\n            ? new BeetStruct(fixedFields, this.construct, this.description)\n            : new BeetStruct(fixedFields, this.construct);\n    }\n    toFixedFromValue(args) {\n        const argsKeys = Object.keys(args);\n        const fixedFields = new Array(this.fields.length);\n        for (let i = 0; i < this.fields.length; i++) {\n            const [key, beet] = this.fields[i];\n            assert(argsKeys.includes(key), `Value with keys [ ${argsKeys} ] should include struct key '${key}' but doesn't.`);\n            const val = args[key];\n            const fixedBeet = fixBeetFromValue(beet, val);\n            fixedFields[i] = [key, fixedBeet];\n        }\n        return this.description !== FixableBeetStruct.description\n            ? new BeetStruct(fixedFields, this.construct, this.description)\n            : new BeetStruct(fixedFields, this.construct);\n    }\n    get type() {\n        return FixableBeetStruct.TYPE;\n    }\n}\nFixableBeetStruct.description = 'FixableBeetStruct';\nFixableBeetStruct.TYPE = 'FixableBeetStruct';\nexport function isFixableBeetStruct(beet) {\n    return beet.type === FixableBeetStruct.TYPE;\n}\n/**\n * Convenience wrapper around {@link FixableBeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */\nexport class FixableBeetArgsStruct extends FixableBeetStruct {\n    constructor(fields, description = FixableBeetArgsStruct.description) {\n        super(fields, (args) => args, description);\n    }\n}\nFixableBeetArgsStruct.description = 'FixableBeetArgsStruct';\n//# sourceMappingURL=struct.fixable.js.map"]},"metadata":{},"sourceType":"module"}