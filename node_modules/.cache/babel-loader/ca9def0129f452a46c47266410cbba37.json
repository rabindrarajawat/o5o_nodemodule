{"ast":null,"code":"import { createRouteInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport * as beet from '@metaplex-foundation/beet';\nimport { CandyGuardRequiredOnCandyMachineError } from '../errors.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'CallCandyGuardRouteOperation';\n/**\n * Calls the special \"route\" instruction on a specific guard.\n *\n * This allows guards to provide additional features such as creating\n * PDAs that verify a payer before the mint instruction is executed or\n * freezing and thawing minted NFTs.\n *\n * The \"route\" instruction must select a specific guard on a specific group\n * (if groups are enabled) since it is possible for the same type of guard\n * to have different settings based on its group.\n *\n * Additionally, it is possible for a guard to support multiple \"paths\" within\n * their \"route\" instruction. The route settings of the guard will usually use\n * the `path` property to distinguish them.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .candyMachines()\n *   .callGuardRoute({\n *     candyMachine,\n *     guard: 'allowList',\n *     settings: {\n *       path: 'proof',\n *       merkleProof: getMerkleProof(data, leaf)\n *     },\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst callCandyGuardRouteOperation = _callCandyGuardRouteOperation; // eslint-disable-next-line @typescript-eslint/naming-convention\n\nfunction _callCandyGuardRouteOperation(input) {\n  return {\n    key: Key,\n    input\n  };\n}\n\n_callCandyGuardRouteOperation.key = Key;\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst callCandyGuardRouteOperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const builder = callCandyGuardRouteBuilder(metaplex, operation.input, scope);\n    return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Calls the special \"route\" instruction on a specific guard.\n *\n * This allows guards to provide additional features such as creating\n * PDAs that verify a payer before the mint instruction is executed or\n * freezing and thawing minted NFTs.\n *\n * The \"route\" instruction must select a specific guard on a specific group\n * (if groups are enabled) since it is possible for the same type of guard\n * to have different settings based on its group.\n *\n * Additionally, it is possible for a guard to support multiple \"paths\" within\n * their \"route\" instruction. The route settings of the guard will usually use\n * the `path` property to distinguish them.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .callGuardRoute({\n *     candyMachine,\n *     guard: 'allowList',\n *     settings: {\n *       path: 'proof',\n *       merkleProof: getMerkleProof(data, leaf)\n *     },\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst callCandyGuardRouteBuilder = function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    candyMachine,\n    guard,\n    settings,\n    group = null\n  } = params;\n\n  if (!candyMachine.candyGuard) {\n    throw new CandyGuardRequiredOnCandyMachineError();\n  } // Route instruction.\n\n\n  const parsedRouteSettings = metaplex.candyMachines().guards().parseRouteSettings(candyMachine.address, candyMachine.candyGuard, payer, guard, settings, group, programs);\n  const routeSigners = [payer, ...parsedRouteSettings.signers];\n  const routeInstruction = createRouteInstruction({\n    candyGuard: candyMachine.candyGuard.address,\n    candyMachine: candyMachine.address,\n    payer: payer.publicKey\n  }, {\n    args: {\n      // \"GuardType\" is an enum for default guards only and will assert this\n      // whereas we want to allow custom guards, so we need to pass anything\n      // here to create the instruction and override this data afterwards.\n      guard: 0,\n      data: parsedRouteSettings.arguments\n    },\n    label: group\n  }, metaplex.programs().getCandyGuard(programs).address);\n  routeInstruction.keys.push(...parsedRouteSettings.accountMetas); // As promised, we override the guard index here.\n\n  const availableGuards = metaplex.candyMachines().guards().forCandyGuardProgram(programs);\n  const guardIndex = availableGuards.findIndex(g => g.name === guard);\n  beet.u8.write(routeInstruction.data, 8, guardIndex);\n  return TransactionBuilder.make().setFeePayer(payer) // Route instruction.\n  .add({\n    instruction: routeInstruction,\n    signers: routeSigners,\n    key: params.instructionKey ?? 'callGuardRoute'\n  });\n};\n\nexport { callCandyGuardRouteBuilder, callCandyGuardRouteOperation, callCandyGuardRouteOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineModule/operations/callCandyGuardRoute.ts"],"names":["Key","callCandyGuardRouteOperation","_callCandyGuardRouteOperation","input","key","callCandyGuardRouteOperationHandler","handle","operation","metaplex","scope","builder","callCandyGuardRouteBuilder","sendAndConfirm","confirmOptions","params","options","programs","payer","rpc","getDefaultFeePayer","candyMachine","guard","settings","group","candyGuard","CandyGuardRequiredOnCandyMachineError","parsedRouteSettings","candyMachines","guards","parseRouteSettings","address","routeSigners","signers","routeInstruction","createRouteInstruction","publicKey","args","data","arguments","label","getCandyGuard","keys","push","accountMetas","availableGuards","forCandyGuardProgram","guardIndex","findIndex","g","name","beet","u8","write","TransactionBuilder","make","setFeePayer","add","instruction","instructionKey"],"mappings":"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","sourcesContent":["import { createRouteInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport * as beet from '@metaplex-foundation/beet';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  CandyGuardsRouteSettings,\n  CandyGuardsSettings,\n  DefaultCandyGuardRouteSettings,\n  DefaultCandyGuardSettings,\n} from '../guards';\nimport { CandyMachine } from '../models';\nimport { CandyGuardRequiredOnCandyMachineError } from '../errors';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport { Operation, OperationHandler, OperationScope, Signer } from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CallCandyGuardRouteOperation' as const;\n\n/**\n * Calls the special \"route\" instruction on a specific guard.\n *\n * This allows guards to provide additional features such as creating\n * PDAs that verify a payer before the mint instruction is executed or\n * freezing and thawing minted NFTs.\n *\n * The \"route\" instruction must select a specific guard on a specific group\n * (if groups are enabled) since it is possible for the same type of guard\n * to have different settings based on its group.\n *\n * Additionally, it is possible for a guard to support multiple \"paths\" within\n * their \"route\" instruction. The route settings of the guard will usually use\n * the `path` property to distinguish them.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .candyMachines()\n *   .callGuardRoute({\n *     candyMachine,\n *     guard: 'allowList',\n *     settings: {\n *       path: 'proof',\n *       merkleProof: getMerkleProof(data, leaf)\n *     },\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const callCandyGuardRouteOperation = _callCandyGuardRouteOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _callCandyGuardRouteOperation<\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n>(\n  input: CallCandyGuardRouteInput<Guard, Settings, RouteSettings>\n): CallCandyGuardRouteOperation<Guard, Settings, RouteSettings> {\n  return { key: Key, input };\n}\n_callCandyGuardRouteOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CallCandyGuardRouteOperation<\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n> = Operation<\n  typeof Key,\n  CallCandyGuardRouteInput<Guard, Settings, RouteSettings>,\n  CallCandyGuardRouteOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CallCandyGuardRouteInput<\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n> = {\n  /**\n   * The Candy Machine containing the guard we are interested in.\n   * We only need a subset of the `CandyMachine` model but we\n   * need enough information regarding its settings to know how\n   * to execute the route instruction on the guard.\n   *\n   * This includes its address and the Candy Guard account associated with it.\n   */\n  candyMachine: Pick<CandyMachine<Settings>, 'address' | 'candyGuard'>;\n\n  /**\n   * The guard to select on the Candy Machine.\n   *\n   * If the Candy Machine uses groups of guards, the `group` property\n   * must also be provided so we known which specific guard to select.\n   */\n  guard: Guard;\n\n  /**\n   * The route settings of the selected guard.\n   *\n   * These will depend on the type of guard selected but they will\n   * usually include a `path` property to distinguish between the\n   * different paths available within their \"route\" instruction.\n   */\n  settings: RouteSettings[Guard];\n\n  /**\n   * The label of the group to mint from.\n   *\n   * If groups are configured on the Candy Machine,\n   * you must specify a group label to mint from.\n   *\n   * When set to `null` it will mint using the default\n   * guards, provided no groups are configured.\n   *\n   * @defaultValue `null`\n   */\n  group?: Option<string>;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CallCandyGuardRouteOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const callCandyGuardRouteOperationHandler: OperationHandler<\n  CallCandyGuardRouteOperation<any>\n> = {\n  async handle<\n    Guard extends keyof RouteSettings & string,\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n  >(\n    operation: CallCandyGuardRouteOperation<Guard, Settings, RouteSettings>,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<CallCandyGuardRouteOutput> {\n    const builder = callCandyGuardRouteBuilder<Guard, Settings, RouteSettings>(\n      metaplex,\n      operation.input,\n      scope\n    );\n\n    return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CallCandyGuardRouteBuilderParams<\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n> = Omit<\n  CallCandyGuardRouteInput<Guard, Settings, RouteSettings>,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that mints from the Candy Machine. */\n  instructionKey?: string;\n};\n\n/**\n * Calls the special \"route\" instruction on a specific guard.\n *\n * This allows guards to provide additional features such as creating\n * PDAs that verify a payer before the mint instruction is executed or\n * freezing and thawing minted NFTs.\n *\n * The \"route\" instruction must select a specific guard on a specific group\n * (if groups are enabled) since it is possible for the same type of guard\n * to have different settings based on its group.\n *\n * Additionally, it is possible for a guard to support multiple \"paths\" within\n * their \"route\" instruction. The route settings of the guard will usually use\n * the `path` property to distinguish them.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .callGuardRoute({\n *     candyMachine,\n *     guard: 'allowList',\n *     settings: {\n *       path: 'proof',\n *       merkleProof: getMerkleProof(data, leaf)\n *     },\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const callCandyGuardRouteBuilder = <\n  Guard extends keyof RouteSettings & string,\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n>(\n  metaplex: Metaplex,\n  params: CallCandyGuardRouteBuilderParams<Guard, Settings, RouteSettings>,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { candyMachine, guard, settings, group = null } = params;\n\n  if (!candyMachine.candyGuard) {\n    throw new CandyGuardRequiredOnCandyMachineError();\n  }\n\n  // Route instruction.\n  const parsedRouteSettings = metaplex\n    .candyMachines()\n    .guards()\n    .parseRouteSettings(\n      candyMachine.address,\n      candyMachine.candyGuard,\n      payer,\n      guard,\n      settings,\n      group,\n      programs\n    );\n\n  const routeSigners: Signer[] = [payer, ...parsedRouteSettings.signers];\n  const routeInstruction = createRouteInstruction(\n    {\n      candyGuard: candyMachine.candyGuard.address,\n      candyMachine: candyMachine.address,\n      payer: payer.publicKey,\n    },\n    {\n      args: {\n        // \"GuardType\" is an enum for default guards only and will assert this\n        // whereas we want to allow custom guards, so we need to pass anything\n        // here to create the instruction and override this data afterwards.\n        guard: 0,\n        data: parsedRouteSettings.arguments,\n      },\n      label: group,\n    },\n    metaplex.programs().getCandyGuard(programs).address\n  );\n  routeInstruction.keys.push(...parsedRouteSettings.accountMetas);\n\n  // As promised, we override the guard index here.\n  const availableGuards = metaplex\n    .candyMachines()\n    .guards()\n    .forCandyGuardProgram(programs);\n  const guardIndex = availableGuards.findIndex((g) => g.name === guard);\n  beet.u8.write(routeInstruction.data, 8, guardIndex);\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Route instruction.\n      .add({\n        instruction: routeInstruction,\n        signers: routeSigners,\n        key: params.instructionKey ?? 'callGuardRoute',\n      })\n  );\n};\n"]},"metadata":{},"sourceType":"module"}