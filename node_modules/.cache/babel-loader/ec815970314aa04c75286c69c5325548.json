{"ast":null,"code":"import { MerkleTree } from 'merkletreejs';\nimport { keccak_256 } from '@noble/hashes/sha3';\n/**\n * Describes the required data input for\n * handling Merkle Tree operations.\n */\n\n/**\n * Creates a Merkle Tree from the provided data.\n */\n\nconst getMerkleTree = data => {\n  return new MerkleTree(data.map(keccak_256), keccak_256, {\n    sortPairs: true\n  });\n};\n/**\n * Creates a Merkle Root from the provided data.\n *\n * This root provides a short identifier for the\n * provided data that is unique and deterministic.\n * This means, we can use this root to verify that\n * a given data is part of the original data set.\n */\n\n\nconst getMerkleRoot = data => {\n  return getMerkleTree(data).getRoot();\n};\n/**\n * Creates a Merkle Proof for a given data item.\n *\n * This proof can be used to verify that the given\n * data item is part of the original data set.\n */\n\n\nconst getMerkleProof = (data, leaf, index) => {\n  return getMerkleTree(data).getProof(Buffer.from(keccak_256(leaf)), index).map(proofItem => proofItem.data);\n};\n/**\n * Creates a Merkle Proof for a data item at a given index.\n *\n * This proof can be used to verify that the data item at\n * the given index is part of the original data set.\n */\n\n\nconst getMerkleProofAtIndex = (data, index) => {\n  return getMerkleProof(data, data[index], index);\n};\n\nexport { getMerkleProof, getMerkleProofAtIndex, getMerkleRoot, getMerkleTree };","map":{"version":3,"sources":["../../../src/utils/merkle.ts"],"names":["getMerkleTree","data","MerkleTree","map","keccak_256","sortPairs","getMerkleRoot","getRoot","getMerkleProof","leaf","index","getProof","Buffer","from","proofItem","getMerkleProofAtIndex"],"mappings":";;AAGA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AACaA,MAAAA,aAAa,GAAIC,IAAuB,IAAiB;EACpE,OAAO,IAAIC,UAAJ,CAAeD,IAAI,CAACE,GAALF,CAASG,UAATH,CAAf,EAAqCG,UAArC,EAAiD;IACtDC,SAAS,EAAE;EAD2C,CAAjD,CAAP;AAGF,CAJaL;AAMb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACaM,MAAAA,aAAa,GAAIL,IAAuB,IAAiB;EACpE,OAAOD,aAAa,CAACC,IAAD,CAAbD,CAAoBO,OAApBP,EAAP;AACF,CAFaM;AAIb;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAME,cAAc,GAAG,CAC5BP,IAD4B,EAE5BQ,IAF4B,EAG5BC,KAH4B,KAIX;EACjB,OAAOV,aAAa,CAACC,IAAD,CAAbD,CACJW,QADIX,CACKY,MAAM,CAACC,IAAPD,CAAYR,UAAU,CAACK,IAAD,CAAtBG,CADLZ,EACoCU,KADpCV,EAEJG,GAFIH,CAECc,SAAS,IAAKA,SAAS,CAACb,IAFzBD,CAAP;AAGF,CARO;AAUP;AACA;AACA;AACA;AACA;AACA;;;MACae,qBAAqB,GAAG,CACnCd,IADmC,EAEnCS,KAFmC,KAGlB;EACjB,OAAOF,cAAc,CAACP,IAAD,EAAOA,IAAI,CAACS,KAAD,CAAX,EAAoBA,KAApB,CAArB;AACF,C","sourcesContent":["import { MerkleTree } from 'merkletreejs';\nimport { keccak_256 } from '@noble/hashes/sha3';\n\n/**\n * Describes the required data input for\n * handling Merkle Tree operations.\n */\ntype MerkleTreeInput = Uint8Array | string;\n\n/**\n * Creates a Merkle Tree from the provided data.\n */\nexport const getMerkleTree = (data: MerkleTreeInput[]): MerkleTree => {\n  return new MerkleTree(data.map(keccak_256), keccak_256, {\n    sortPairs: true,\n  });\n};\n\n/**\n * Creates a Merkle Root from the provided data.\n *\n * This root provides a short identifier for the\n * provided data that is unique and deterministic.\n * This means, we can use this root to verify that\n * a given data is part of the original data set.\n */\nexport const getMerkleRoot = (data: MerkleTreeInput[]): Uint8Array => {\n  return getMerkleTree(data).getRoot();\n};\n\n/**\n * Creates a Merkle Proof for a given data item.\n *\n * This proof can be used to verify that the given\n * data item is part of the original data set.\n */\nexport const getMerkleProof = (\n  data: MerkleTreeInput[],\n  leaf: MerkleTreeInput,\n  index?: number\n): Uint8Array[] => {\n  return getMerkleTree(data)\n    .getProof(Buffer.from(keccak_256(leaf)), index)\n    .map((proofItem) => proofItem.data);\n};\n\n/**\n * Creates a Merkle Proof for a data item at a given index.\n *\n * This proof can be used to verify that the data item at\n * the given index is part of the original data set.\n */\nexport const getMerkleProofAtIndex = (\n  data: MerkleTreeInput[],\n  index: number\n): Uint8Array[] => {\n  return getMerkleProof(data, data[index], index);\n};\n"]},"metadata":{},"sourceType":"module"}