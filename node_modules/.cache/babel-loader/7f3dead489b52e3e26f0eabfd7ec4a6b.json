{"ast":null,"code":"import { Buffer } from 'buffer';\n/**\n * Serializes an array of boolean into a Buffer. The `byteSize` parameter\n * can be used to create a fixed-size Buffer, otherwise the Buffer will\n * have the minimum amount of bytes required to store the boolean array.\n *\n * Returns a Buffer whose bits are ordered from left to right, unless\n * `backward` is set to true, in which case the bits are ordered from\n * right to left.\n */\n\nconst serializeFeatureFlags = function (features, byteSize) {\n  let backward = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  byteSize = byteSize ?? Math.ceil(features.length / 8);\n  const bytes = [];\n\n  for (let i = 0; i < byteSize; i++) {\n    let byte = 0;\n\n    for (let j = 0; j < 8; j++) {\n      const feature = Number(features[i * 8 + j] ?? 0);\n      byte |= feature << (backward ? j : 7 - j);\n    }\n\n    if (backward) {\n      bytes.unshift(byte);\n    } else {\n      bytes.push(byte);\n    }\n  }\n\n  return Buffer.from(bytes);\n};\n/**\n * Parses a Buffer into an array of booleans using the\n * bits of the buffer. The number of flags can be provided\n * to determine how many booleans to return.\n *\n * Expects the bits in the Buffer to be ordered from left to right,\n * unless `backward` is set to true, we expect the bits to be\n * ordered from right to left.\n */\n\n\nconst deserializeFeatureFlags = function (buffer, numberOfFlags) {\n  let backward = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const booleans = [];\n  buffer = backward ? buffer.reverse() : buffer;\n\n  for (let byte of buffer) {\n    for (let i = 0; i < 8; i++) {\n      if (backward) {\n        booleans.push(Boolean(byte & 1));\n        byte >>= 1;\n      } else {\n        booleans.push(Boolean(byte & 0b1000_0000));\n        byte <<= 1;\n      }\n    }\n  }\n\n  return booleans.slice(0, numberOfFlags);\n};\n\nexport { deserializeFeatureFlags, serializeFeatureFlags };","map":{"version":3,"sources":["../../../src/types/FeatureFlags.ts"],"names":["serializeFeatureFlags","features","byteSize","backward","Math","ceil","length","bytes","i","byte","j","feature","Number","unshift","push","Buffer","from","deserializeFeatureFlags","buffer","numberOfFlags","booleans","reverse","Boolean","slice"],"mappings":";AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,MAAMA,qBAAqB,GAAG,UACnCC,QADmC,EAEnCC,QAFmC,EAIxB;EAAA,IADXC,QACW,uEADA,KACA;EACXD,QAAQ,GAAGA,QAAQ,IAAIE,IAAI,CAACC,IAALD,CAAUH,QAAQ,CAACK,MAATL,GAAkB,CAA5BG,CAAvBF;EACA,MAAMK,KAAe,GAAG,EAAxB;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAApB,EAA8BM,CAAC,EAA/B,EAAmC;IACjC,IAAIC,IAAI,GAAG,CAAX;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;MAC1B,MAAMC,OAAO,GAAGC,MAAM,CAACX,QAAQ,CAACO,CAAC,GAAG,CAAJA,GAAQE,CAAT,CAART,IAAuB,CAAxB,CAAtB;MACAQ,IAAI,IAAIE,OAAO,KAAKR,QAAQ,GAAGO,CAAH,GAAO,IAAIA,CAAxB,CAAfD;IACF;;IACA,IAAIN,QAAJ,EAAc;MACZI,KAAK,CAACM,OAANN,CAAcE,IAAdF;IACD,CAFD,MAEO;MACLA,KAAK,CAACO,IAANP,CAAWE,IAAXF;IACF;EACF;;EAEA,OAAOQ,MAAM,CAACC,IAAPD,CAAYR,KAAZQ,CAAP;AACF,CAtBO;AAwBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAME,uBAAuB,GAAG,UACrCC,MADqC,EAErCC,aAFqC,EAIpB;EAAA,IADjBhB,QACiB,uEADN,KACM;EACjB,MAAMiB,QAAmB,GAAG,EAA5B;EACAF,MAAM,GAAGf,QAAQ,GAAGe,MAAM,CAACG,OAAPH,EAAH,GAAsBA,MAAvCA;;EAEA,KAAK,IAAIT,IAAT,IAAiBS,MAAjB,EAAyB;IACvB,KAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;MAC1B,IAAIL,QAAJ,EAAc;QACZiB,QAAQ,CAACN,IAATM,CAAcE,OAAO,CAACb,IAAI,GAAG,CAAR,CAArBW;QACAX,IAAI,KAAK,CAATA;MACD,CAHD,MAGO;QACLW,QAAQ,CAACN,IAATM,CAAcE,OAAO,CAACb,IAAI,GAAG,WAAR,CAArBW;QACAX,IAAI,KAAK,CAATA;MACF;IACF;EACF;;EAEA,OAAOW,QAAQ,CAACG,KAATH,CAAe,CAAfA,EAAkBD,aAAlBC,CAAP;AACF,CArBO","sourcesContent":["import { Buffer } from 'buffer';\n\nexport type FeatureFlags = boolean[];\n\n/**\n * Serializes an array of boolean into a Buffer. The `byteSize` parameter\n * can be used to create a fixed-size Buffer, otherwise the Buffer will\n * have the minimum amount of bytes required to store the boolean array.\n *\n * Returns a Buffer whose bits are ordered from left to right, unless\n * `backward` is set to true, in which case the bits are ordered from\n * right to left.\n */\nexport const serializeFeatureFlags = (\n  features: FeatureFlags,\n  byteSize?: number,\n  backward = false\n): Buffer => {\n  byteSize = byteSize ?? Math.ceil(features.length / 8);\n  const bytes: number[] = [];\n\n  for (let i = 0; i < byteSize; i++) {\n    let byte = 0;\n    for (let j = 0; j < 8; j++) {\n      const feature = Number(features[i * 8 + j] ?? 0);\n      byte |= feature << (backward ? j : 7 - j);\n    }\n    if (backward) {\n      bytes.unshift(byte);\n    } else {\n      bytes.push(byte);\n    }\n  }\n\n  return Buffer.from(bytes);\n};\n\n/**\n * Parses a Buffer into an array of booleans using the\n * bits of the buffer. The number of flags can be provided\n * to determine how many booleans to return.\n *\n * Expects the bits in the Buffer to be ordered from left to right,\n * unless `backward` is set to true, we expect the bits to be\n * ordered from right to left.\n */\nexport const deserializeFeatureFlags = (\n  buffer: Buffer,\n  numberOfFlags?: number,\n  backward = false\n): FeatureFlags => {\n  const booleans: boolean[] = [];\n  buffer = backward ? buffer.reverse() : buffer;\n\n  for (let byte of buffer) {\n    for (let i = 0; i < 8; i++) {\n      if (backward) {\n        booleans.push(Boolean(byte & 1));\n        byte >>= 1;\n      } else {\n        booleans.push(Boolean(byte & 0b1000_0000));\n        byte <<= 1;\n      }\n    }\n  }\n\n  return booleans.slice(0, numberOfFlags);\n};\n"]},"metadata":{},"sourceType":"module"}