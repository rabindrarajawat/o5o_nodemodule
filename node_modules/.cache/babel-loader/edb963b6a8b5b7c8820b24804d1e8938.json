{"ast":null,"code":"import { createUpdateCandyMachineInstruction, createSetCollectionInstruction, createRemoveCollectionInstruction, createUpdateAuthorityInstruction } from '@metaplex-foundation/mpl-candy-machine';\nimport isEqual from 'lodash.isequal';\nimport { findCandyMachineV2CollectionPda } from '../pdas.mjs';\nimport { toCandyMachineV2Configs, toCandyMachineV2InstructionData } from '../models/CandyMachineV2.mjs';\nimport { useOperation } from '../../../types/Operation.mjs';\nimport { NoInstructionsToSendError } from '../../../errors/SdkError.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'UpdateCandyMachineV2Operation';\n/**\n * Updates an existing Candy Machine.\n *\n * ```ts\n * await metaplex\n *   .candyMachinesV2()\n *   .update({\n *     candyMachine,\n *     price: sol(2), // Updates the price only.\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst updateCandyMachineV2Operation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst updateCandyMachineV2OperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const {\n      candyMachine,\n      authority = metaplex.identity(),\n      newAuthority,\n      newCollection,\n      ...updatableFields\n    } = operation.input;\n    const currentConfigs = toCandyMachineV2Configs(candyMachine);\n    const instructionDataWithoutChanges = toCandyMachineV2InstructionData(candyMachine.address, currentConfigs);\n    const instructionData = toCandyMachineV2InstructionData(candyMachine.address, { ...currentConfigs,\n      ...updatableFields\n    });\n    const {\n      data,\n      wallet,\n      tokenMint\n    } = instructionData;\n    const shouldUpdateData = !isEqual(instructionData, instructionDataWithoutChanges);\n    const builder = updateCandyMachineV2Builder(metaplex, {\n      candyMachine,\n      authority,\n      newData: shouldUpdateData ? { ...data,\n        wallet,\n        tokenMint\n      } : undefined,\n      newCollection,\n      newAuthority\n    }, scope);\n\n    if (builder.isEmpty()) {\n      throw new NoInstructionsToSendError(Key);\n    }\n\n    return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Updates an existing Candy Machine.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .update({\n *     candyMachine: { address, walletAddress, collectionMintAddress },\n *     newData: {...}, // Updates the provided data.\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst updateCandyMachineV2Builder = function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    candyMachine,\n    authority = metaplex.identity(),\n    newData,\n    newAuthority,\n    newCollection\n  } = params;\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs).address;\n  const shouldUpdateAuthority = !!newAuthority && !newAuthority.equals(authority.publicKey);\n  const sameCollection = newCollection && candyMachine.collectionMintAddress && candyMachine.collectionMintAddress.equals(newCollection);\n  const shouldUpdateCollection = !!newCollection && !sameCollection;\n  const shouldRemoveCollection = !shouldUpdateCollection && newCollection === null && candyMachine.collectionMintAddress !== null;\n  return TransactionBuilder.make().setFeePayer(payer) // Update data.\n  .when(!!newData, builder => {\n    const data = newData;\n    const wallet = newData?.wallet;\n    const tokenMint = newData?.tokenMint;\n    const updateInstruction = createUpdateCandyMachineInstruction({\n      candyMachine: candyMachine.address,\n      authority: authority.publicKey,\n      wallet\n    }, {\n      data\n    });\n\n    if (tokenMint) {\n      updateInstruction.keys.push({\n        pubkey: tokenMint,\n        isWritable: false,\n        isSigner: false\n      });\n    }\n\n    return builder.add({\n      instruction: updateInstruction,\n      signers: [authority],\n      key: params.updateInstructionKey ?? 'update'\n    });\n  }) // Set or update collection.\n  .when(shouldUpdateCollection, builder => {\n    const collectionMint = newCollection;\n    const metadata = metaplex.nfts().pdas().metadata({\n      mint: collectionMint,\n      programs\n    });\n    const edition = metaplex.nfts().pdas().masterEdition({\n      mint: collectionMint,\n      programs\n    });\n    const collectionPda = findCandyMachineV2CollectionPda(candyMachine.address);\n    const collectionAuthorityRecord = metaplex.nfts().pdas().collectionAuthorityRecord({\n      mint: collectionMint,\n      collectionAuthority: collectionPda,\n      programs\n    });\n    return builder.add({\n      instruction: createSetCollectionInstruction({\n        candyMachine: candyMachine.address,\n        authority: authority.publicKey,\n        collectionPda,\n        payer: payer.publicKey,\n        metadata,\n        mint: collectionMint,\n        edition,\n        collectionAuthorityRecord,\n        tokenMetadataProgram\n      }),\n      signers: [payer, authority],\n      key: params.setCollectionInstructionKey ?? 'setCollection'\n    });\n  }) // Remove collection.\n  .when(shouldRemoveCollection, builder => {\n    const collectionMint = candyMachine.collectionMintAddress;\n    const metadata = metaplex.nfts().pdas().metadata({\n      mint: collectionMint,\n      programs\n    });\n    const collectionPda = findCandyMachineV2CollectionPda(candyMachine.address);\n    const collectionAuthorityRecord = metaplex.nfts().pdas().collectionAuthorityRecord({\n      mint: collectionMint,\n      collectionAuthority: collectionPda,\n      programs\n    });\n    return builder.add({\n      instruction: createRemoveCollectionInstruction({\n        candyMachine: candyMachine.address,\n        authority: authority.publicKey,\n        collectionPda,\n        metadata,\n        mint: collectionMint,\n        collectionAuthorityRecord,\n        tokenMetadataProgram\n      }),\n      signers: [authority],\n      key: params.removeCollectionInstructionKey ?? 'removeCollection'\n    });\n  }) // Update authority.\n  .when(shouldUpdateAuthority, builder => builder.add({\n    instruction: createUpdateAuthorityInstruction({\n      candyMachine: candyMachine.address,\n      authority: authority.publicKey,\n      wallet: newData?.wallet ?? candyMachine.walletAddress\n    }, {\n      newAuthority: newAuthority\n    }),\n    signers: [authority],\n    key: params.updateAuthorityInstructionKey ?? 'updateAuthority'\n  }));\n};\n\nexport { updateCandyMachineV2Builder, updateCandyMachineV2Operation, updateCandyMachineV2OperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineV2Module/operations/updateCandyMachineV2.ts"],"names":["Key","updateCandyMachineV2Operation","useOperation","updateCandyMachineV2OperationHandler","handle","operation","metaplex","scope","candyMachine","authority","identity","newAuthority","newCollection","updatableFields","input","currentConfigs","toCandyMachineV2Configs","instructionDataWithoutChanges","toCandyMachineV2InstructionData","address","instructionData","data","wallet","tokenMint","shouldUpdateData","isEqual","builder","updateCandyMachineV2Builder","newData","undefined","isEmpty","NoInstructionsToSendError","sendAndConfirm","confirmOptions","params","options","programs","payer","rpc","getDefaultFeePayer","tokenMetadataProgram","getTokenMetadata","shouldUpdateAuthority","equals","publicKey","sameCollection","collectionMintAddress","shouldUpdateCollection","shouldRemoveCollection","TransactionBuilder","make","setFeePayer","when","updateInstruction","createUpdateCandyMachineInstruction","keys","push","pubkey","isWritable","isSigner","add","instruction","signers","key","updateInstructionKey","collectionMint","metadata","nfts","pdas","mint","edition","masterEdition","collectionPda","findCandyMachineV2CollectionPda","collectionAuthorityRecord","collectionAuthority","createSetCollectionInstruction","setCollectionInstructionKey","createRemoveCollectionInstruction","removeCollectionInstructionKey","createUpdateAuthorityInstruction","walletAddress","updateAuthorityInstructionKey"],"mappings":"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","sourcesContent":["import {\n  CandyMachineData,\n  createRemoveCollectionInstruction,\n  createSetCollectionInstruction,\n  createUpdateAuthorityInstruction,\n  createUpdateCandyMachineInstruction,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport type { PublicKey } from '@solana/web3.js';\nimport isEqual from 'lodash.isequal';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  CandyMachineV2,\n  CandyMachineV2Configs,\n  toCandyMachineV2Configs,\n  toCandyMachineV2InstructionData,\n} from '../models';\nimport { findCandyMachineV2CollectionPda } from '../pdas';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\nimport { NoInstructionsToSendError } from '@/errors';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UpdateCandyMachineV2Operation' as const;\n\n/**\n * Updates an existing Candy Machine.\n *\n * ```ts\n * await metaplex\n *   .candyMachinesV2()\n *   .update({\n *     candyMachine,\n *     price: sol(2), // Updates the price only.\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const updateCandyMachineV2Operation =\n  useOperation<UpdateCandyMachineV2Operation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UpdateCandyMachineV2Operation = Operation<\n  typeof Key,\n  UpdateCandyMachineV2Input,\n  UpdateCandyMachineV2Output\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UpdateCandyMachineV2Input = Partial<CandyMachineV2Configs> & {\n  /**\n   * The Candy Machine to update.\n   * We need the full model in order to compare the current data with\n   * the provided data to update. For instance, if you only want to\n   * update the `price`, we need to send an instruction that updates\n   * the data whilst keeping all other properties the same.\n   *\n   * If you want more control over how this transaction is built,\n   * you may use the associated transaction builder instead using\n   * `metaplex.candyMachinesV2().builders().updateCandyMachineV2({...})`.\n   */\n  candyMachine: CandyMachineV2;\n\n  /**\n   * The Signer authorized to update the candy machine.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n\n  /**\n   * The new Candy Machine authority.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newAuthority?: PublicKey;\n\n  /**\n   * The mint address of the new Candy Machine collection.\n   * When `null` is provided, the collection is removed.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newCollection?: Option<PublicKey>;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UpdateCandyMachineV2Output = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const updateCandyMachineV2OperationHandler: OperationHandler<UpdateCandyMachineV2Operation> =\n  {\n    async handle(\n      operation: UpdateCandyMachineV2Operation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<UpdateCandyMachineV2Output> {\n      const {\n        candyMachine,\n        authority = metaplex.identity(),\n        newAuthority,\n        newCollection,\n        ...updatableFields\n      } = operation.input;\n\n      const currentConfigs = toCandyMachineV2Configs(candyMachine);\n      const instructionDataWithoutChanges = toCandyMachineV2InstructionData(\n        candyMachine.address,\n        currentConfigs\n      );\n      const instructionData = toCandyMachineV2InstructionData(\n        candyMachine.address,\n        {\n          ...currentConfigs,\n          ...updatableFields,\n        }\n      );\n      const { data, wallet, tokenMint } = instructionData;\n      const shouldUpdateData = !isEqual(\n        instructionData,\n        instructionDataWithoutChanges\n      );\n\n      const builder = updateCandyMachineV2Builder(\n        metaplex,\n        {\n          candyMachine,\n          authority,\n          newData: shouldUpdateData\n            ? { ...data, wallet, tokenMint }\n            : undefined,\n          newCollection,\n          newAuthority,\n        },\n        scope\n      );\n\n      if (builder.isEmpty()) {\n        throw new NoInstructionsToSendError(Key);\n      }\n\n      return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UpdateCandyMachineV2BuilderParams = {\n  /**\n   * The Candy Machine to update.\n   * We only need a subset of the `CandyMachine` model to figure out\n   * the current values for the wallet and collection addresses.\n   */\n  candyMachine: Pick<\n    CandyMachineV2,\n    'address' | 'walletAddress' | 'collectionMintAddress'\n  >;\n\n  /**\n   * The Signer authorized to update the candy machine.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer;\n\n  /**\n   * The new Candy Machine data.\n   * This includes the wallet and token mint addresses\n   * which can both be updated.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newData?: CandyMachineData & {\n    wallet: PublicKey;\n    tokenMint: Option<PublicKey>;\n  };\n\n  /**\n   * The new Candy Machine authority.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newAuthority?: PublicKey;\n\n  /**\n   * The mint address of the new Candy Machine collection.\n   * When `null` is provided, the collection is removed.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newCollection?: Option<PublicKey>;\n\n  /** A key to distinguish the instruction that updates the data. */\n  updateInstructionKey?: string;\n\n  /** A key to distinguish the instruction that updates the authority. */\n  updateAuthorityInstructionKey?: string;\n\n  /** A key to distinguish the instruction that sets the collection. */\n  setCollectionInstructionKey?: string;\n\n  /** A key to distinguish the instruction that removes the collection. */\n  removeCollectionInstructionKey?: string;\n};\n\n/**\n * Updates an existing Candy Machine.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .update({\n *     candyMachine: { address, walletAddress, collectionMintAddress },\n *     newData: {...}, // Updates the provided data.\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const updateCandyMachineV2Builder = (\n  metaplex: Metaplex,\n  params: UpdateCandyMachineV2BuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyMachine,\n    authority = metaplex.identity(),\n    newData,\n    newAuthority,\n    newCollection,\n  } = params;\n  const tokenMetadataProgram = metaplex\n    .programs()\n    .getTokenMetadata(programs).address;\n  const shouldUpdateAuthority =\n    !!newAuthority && !newAuthority.equals(authority.publicKey);\n  const sameCollection =\n    newCollection &&\n    candyMachine.collectionMintAddress &&\n    candyMachine.collectionMintAddress.equals(newCollection);\n  const shouldUpdateCollection = !!newCollection && !sameCollection;\n  const shouldRemoveCollection =\n    !shouldUpdateCollection &&\n    newCollection === null &&\n    candyMachine.collectionMintAddress !== null;\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update data.\n      .when(!!newData, (builder) => {\n        const data = newData as CandyMachineData;\n        const wallet = newData?.wallet as PublicKey;\n        const tokenMint = newData?.tokenMint as Option<PublicKey>;\n        const updateInstruction = createUpdateCandyMachineInstruction(\n          {\n            candyMachine: candyMachine.address,\n            authority: authority.publicKey,\n            wallet,\n          },\n          { data }\n        );\n\n        if (tokenMint) {\n          updateInstruction.keys.push({\n            pubkey: tokenMint,\n            isWritable: false,\n            isSigner: false,\n          });\n        }\n\n        return builder.add({\n          instruction: updateInstruction,\n          signers: [authority],\n          key: params.updateInstructionKey ?? 'update',\n        });\n      })\n\n      // Set or update collection.\n      .when(shouldUpdateCollection, (builder) => {\n        const collectionMint = newCollection as PublicKey;\n        const metadata = metaplex.nfts().pdas().metadata({\n          mint: collectionMint,\n          programs,\n        });\n        const edition = metaplex.nfts().pdas().masterEdition({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionPda = findCandyMachineV2CollectionPda(\n          candyMachine.address\n        );\n        const collectionAuthorityRecord = metaplex\n          .nfts()\n          .pdas()\n          .collectionAuthorityRecord({\n            mint: collectionMint,\n            collectionAuthority: collectionPda,\n            programs,\n          });\n\n        return builder.add({\n          instruction: createSetCollectionInstruction({\n            candyMachine: candyMachine.address,\n            authority: authority.publicKey,\n            collectionPda,\n            payer: payer.publicKey,\n            metadata,\n            mint: collectionMint,\n            edition,\n            collectionAuthorityRecord,\n            tokenMetadataProgram,\n          }),\n          signers: [payer, authority],\n          key: params.setCollectionInstructionKey ?? 'setCollection',\n        });\n      })\n\n      // Remove collection.\n      .when(shouldRemoveCollection, (builder) => {\n        const collectionMint = candyMachine.collectionMintAddress as PublicKey;\n        const metadata = metaplex.nfts().pdas().metadata({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionPda = findCandyMachineV2CollectionPda(\n          candyMachine.address\n        );\n        const collectionAuthorityRecord = metaplex\n          .nfts()\n          .pdas()\n          .collectionAuthorityRecord({\n            mint: collectionMint,\n            collectionAuthority: collectionPda,\n            programs,\n          });\n\n        return builder.add({\n          instruction: createRemoveCollectionInstruction({\n            candyMachine: candyMachine.address,\n            authority: authority.publicKey,\n            collectionPda,\n            metadata,\n            mint: collectionMint,\n            collectionAuthorityRecord,\n            tokenMetadataProgram,\n          }),\n          signers: [authority],\n          key: params.removeCollectionInstructionKey ?? 'removeCollection',\n        });\n      })\n\n      // Update authority.\n      .when(shouldUpdateAuthority, (builder) =>\n        builder.add({\n          instruction: createUpdateAuthorityInstruction(\n            {\n              candyMachine: candyMachine.address,\n              authority: authority.publicKey,\n              wallet: newData?.wallet ?? candyMachine.walletAddress,\n            },\n            { newAuthority: newAuthority as PublicKey }\n          ),\n          signers: [authority],\n          key: params.updateAuthorityInstructionKey ?? 'updateAuthority',\n        })\n      )\n  );\n};\n"]},"metadata":{},"sourceType":"module"}