{"ast":null,"code":"import { createAssociatedTokenAccountInstruction, ACCOUNT_SIZE, createInitializeAccountInstruction } from '@solana/spl-token';\nimport { ExpectedSignerError } from '../../../errors/SdkError.mjs';\nimport { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs';\nimport { toPublicKey } from '../../../types/PublicKey.mjs';\nimport { isSigner } from '../../../types/Signer.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateTokenOperation';\n/**\n * Creates a new token account.\n *\n * ```ts\n * const { token } = await metaplex.tokens().createToken({ mint });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst createTokenOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst createTokenOperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const builder = await createTokenBuilder(metaplex, operation.input, scope);\n    scope.throwIfCanceled();\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n    const token = await metaplex.tokens().findTokenByAddress({\n      address: output.tokenAddress\n    }, scope);\n    return { ...output,\n      token\n    };\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Creates a new token account.\n *\n * ```ts\n * const transactionBuilder = await metaplex.tokens().builders().createToken({ mint });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst createTokenBuilder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    mint,\n    owner = metaplex.identity().publicKey,\n    token\n  } = params;\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const associatedTokenProgram = metaplex.programs().getAssociatedToken(programs);\n  const isAssociatedToken = token === undefined;\n  const builder = TransactionBuilder.make().setFeePayer(payer);\n\n  if (isAssociatedToken) {\n    const associatedTokenAddress = metaplex.tokens().pdas().associatedTokenAccount({\n      mint,\n      owner,\n      programs\n    });\n    return builder.setContext({\n      tokenAddress: associatedTokenAddress\n    }) // Create an associated token account.\n    .add({\n      instruction: createAssociatedTokenAccountInstruction(payer.publicKey, associatedTokenAddress, owner, mint, tokenProgram.address, associatedTokenProgram.address),\n      signers: [payer],\n      key: params.createAssociatedTokenAccountInstructionKey ?? 'createAssociatedTokenAccount'\n    });\n  }\n\n  return builder.setFeePayer(payer).setContext({\n    tokenAddress: token.publicKey\n  }) // Create an empty account for the Token.\n  .add(await metaplex.system().builders().createAccount({\n    newAccount: token,\n    space: ACCOUNT_SIZE,\n    program: tokenProgram.address,\n    instructionKey: params.createAccountInstructionKey ?? 'createAccount'\n  }, {\n    payer,\n    programs\n  })) // Initialize the Token.\n  .add({\n    instruction: createInitializeAccountInstruction(token.publicKey, mint, owner, tokenProgram.address),\n    signers: [token],\n    key: params.initializeTokenInstructionKey ?? 'initializeToken'\n  });\n};\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * @group Transaction Builders\n * @category Constructors\n * @internal\n */\n\n\nconst createTokenIfMissingBuilder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    mint,\n    owner = metaplex.identity().publicKey,\n    token,\n    tokenExists = true,\n    tokenVariable = 'token'\n  } = params;\n  const destination = token ?? metaplex.tokens().pdas().associatedTokenAccount({\n    mint,\n    owner,\n    programs\n  });\n  const destinationAddress = toPublicKey(destination);\n  const builder = TransactionBuilder.make().setFeePayer(payer).setContext({\n    tokenAddress: destinationAddress\n  });\n\n  if (tokenExists) {\n    return builder;\n  } // When creating a token account, ensure it is passed as a Signer.\n\n\n  if (token && !isSigner(token)) {\n    throw new ExpectedSignerError(tokenVariable, 'PublicKey', `The provided \"${tokenVariable}\" account ` + `at address [${destinationAddress}] does not exist. ` + `Therefore, it needs to be created and passed as a Signer. ` + `If you want to create the \"${tokenVariable}\" account, then please pass it as a Signer. ` + `Alternatively, you can pass the owner account as a PublicKey instead to ` + `use (or create) an associated token account.`);\n  }\n\n  return builder.add(await metaplex.tokens().builders().createToken({ ...params,\n    mint,\n    owner,\n    token\n  }, {\n    programs,\n    payer\n  }));\n};\n\nexport { createTokenBuilder, createTokenIfMissingBuilder, createTokenOperation, createTokenOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/tokenModule/operations/createToken.ts"],"names":["Key","createTokenOperation","useOperation","createTokenOperationHandler","handle","operation","metaplex","scope","builder","createTokenBuilder","input","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","token","tokens","findTokenByAddress","address","tokenAddress","params","options","programs","payer","rpc","getDefaultFeePayer","mint","owner","identity","publicKey","tokenProgram","getToken","associatedTokenProgram","getAssociatedToken","isAssociatedToken","undefined","TransactionBuilder","make","setFeePayer","associatedTokenAddress","pdas","associatedTokenAccount","setContext","add","instruction","createAssociatedTokenAccountInstruction","signers","key","createAssociatedTokenAccountInstructionKey","system","builders","createAccount","newAccount","space","ACCOUNT_SIZE","program","instructionKey","createAccountInstructionKey","createInitializeAccountInstruction","initializeTokenInstructionKey","createTokenIfMissingBuilder","tokenExists","tokenVariable","destination","destinationAddress","toPublicKey","isSigner","ExpectedSignerError","createToken"],"mappings":"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","sourcesContent":["import {\n  ACCOUNT_SIZE,\n  createAssociatedTokenAccountInstruction,\n  createInitializeAccountInstruction,\n} from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Token } from '../models/Token';\nimport { ExpectedSignerError } from '@/errors';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateTokenOperation' as const;\n\n/**\n * Creates a new token account.\n *\n * ```ts\n * const { token } = await metaplex.tokens().createToken({ mint });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createTokenOperation = useOperation<CreateTokenOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateTokenOperation = Operation<\n  typeof Key,\n  CreateTokenInput,\n  CreateTokenOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateTokenInput = {\n  /**\n   * The address of the mint account associated\n   * with the new token account.\n   */\n  mint: PublicKey;\n\n  /**\n   * The address of the owner of the new token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  owner?: PublicKey;\n\n  /**\n   * The token account as a Signer if we want to create\n   * a new token account with a specific address instead of\n   * creating a new associated token account.\n   *\n   * @defaultValue Defaults to creating a new associated token account\n   * using the `mint` and `owner` parameters.\n   */\n  token?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateTokenOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created token account. */\n  token: Token;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createTokenOperationHandler: OperationHandler<CreateTokenOperation> =\n  {\n    async handle(\n      operation: CreateTokenOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateTokenOutput> {\n      const builder = await createTokenBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const token = await metaplex\n        .tokens()\n        .findTokenByAddress({ address: output.tokenAddress }, scope);\n\n      return { ...output, token };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateTokenBuilderParams = Omit<\n  CreateTokenInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the account. */\n  createAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateTokenBuilderContext = {\n  /** The computed address of the token account to create. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * Creates a new token account.\n *\n * ```ts\n * const transactionBuilder = await metaplex.tokens().builders().createToken({ mint });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createTokenBuilder = async (\n  metaplex: Metaplex,\n  params: CreateTokenBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateTokenBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { mint, owner = metaplex.identity().publicKey, token } = params;\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const associatedTokenProgram = metaplex\n    .programs()\n    .getAssociatedToken(programs);\n\n  const isAssociatedToken = token === undefined;\n  const builder =\n    TransactionBuilder.make<CreateTokenBuilderContext>().setFeePayer(payer);\n\n  if (isAssociatedToken) {\n    const associatedTokenAddress = metaplex\n      .tokens()\n      .pdas()\n      .associatedTokenAccount({ mint, owner, programs });\n\n    return (\n      builder\n        .setContext({ tokenAddress: associatedTokenAddress })\n\n        // Create an associated token account.\n        .add({\n          instruction: createAssociatedTokenAccountInstruction(\n            payer.publicKey,\n            associatedTokenAddress,\n            owner,\n            mint,\n            tokenProgram.address,\n            associatedTokenProgram.address\n          ),\n          signers: [payer],\n          key:\n            params.createAssociatedTokenAccountInstructionKey ??\n            'createAssociatedTokenAccount',\n        })\n    );\n  }\n\n  return (\n    builder\n      .setFeePayer(payer)\n      .setContext({ tokenAddress: token.publicKey })\n\n      // Create an empty account for the Token.\n      .add(\n        await metaplex\n          .system()\n          .builders()\n          .createAccount(\n            {\n              newAccount: token,\n              space: ACCOUNT_SIZE,\n              program: tokenProgram.address,\n              instructionKey:\n                params.createAccountInstructionKey ?? 'createAccount',\n            },\n            { payer, programs }\n          )\n      )\n\n      // Initialize the Token.\n      .add({\n        instruction: createInitializeAccountInstruction(\n          token.publicKey,\n          mint,\n          owner,\n          tokenProgram.address\n        ),\n        signers: [token],\n        key: params.initializeTokenInstructionKey ?? 'initializeToken',\n      })\n  );\n};\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateTokenIfMissingBuilderParams = Omit<\n  CreateTokenBuilderParams,\n  'token'\n> & {\n  /**\n   * The token account to create if it does not exist.\n   * Here, it may be passed as a PublicKey if and only\n   * if it already exists.\n   */\n  token?: PublicKey | Signer;\n\n  /**\n   * Whether or not the token account exists.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /**\n   * The name of the token variable on the operation that uses\n   * this helper token builder.\n   *\n   * @defaultValue `\"token\"`\n   */\n  tokenVariable?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Constructors\n * @internal\n */\nexport const createTokenIfMissingBuilder = async (\n  metaplex: Metaplex,\n  params: CreateTokenIfMissingBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateTokenBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mint,\n    owner = metaplex.identity().publicKey,\n    token,\n    tokenExists = true,\n    tokenVariable = 'token',\n  } = params;\n\n  const destination =\n    token ??\n    metaplex.tokens().pdas().associatedTokenAccount({ mint, owner, programs });\n  const destinationAddress = toPublicKey(destination);\n  const builder = TransactionBuilder.make<CreateTokenBuilderContext>()\n    .setFeePayer(payer)\n    .setContext({ tokenAddress: destinationAddress });\n\n  if (tokenExists) {\n    return builder;\n  }\n\n  // When creating a token account, ensure it is passed as a Signer.\n  if (token && !isSigner(token)) {\n    throw new ExpectedSignerError(\n      tokenVariable,\n      'PublicKey',\n      `The provided \"${tokenVariable}\" account ` +\n        `at address [${destinationAddress}] does not exist. ` +\n        `Therefore, it needs to be created and passed as a Signer. ` +\n        `If you want to create the \"${tokenVariable}\" account, then please pass it as a Signer. ` +\n        `Alternatively, you can pass the owner account as a PublicKey instead to ` +\n        `use (or create) an associated token account.`\n    );\n  }\n\n  return builder.add(\n    await metaplex\n      .tokens()\n      .builders()\n      .createToken(\n        {\n          ...params,\n          mint,\n          owner,\n          token,\n        },\n        { programs, payer }\n      )\n  );\n};\n"]},"metadata":{},"sourceType":"module"}