{"ast":null,"code":"import { isFixedSizeBeet } from '@metaplex-foundation/beet';\nimport { strict as assert } from 'assert';\nimport { logTrace } from '../utils';\nimport { encodeFixedBeet } from './util';\n/**\n * Provides an Account specific GPA builder.\n *\n * @template T - the type of the account for which the GpaBuilder is used\n */\n\nexport class GpaBuilder {\n  constructor(programId, beets, accountSize) {\n    this.programId = programId;\n    this.beets = beets;\n    this.accountSize = accountSize;\n    /**\n     * web3.js {@link GetProgramAccountsConfig} configured via filter GpaBuilder filter methods.\n     */\n\n    this.config = {};\n  }\n\n  _addFilter(filter) {\n    if (this.config.filters == null) {\n      this.config.filters = [];\n    }\n\n    this.config.filters.push(filter);\n    return this;\n  }\n\n  _addInnerFilter(key, innerKey, val) {\n    logTrace(`gpa.addInnerFilter: ${key}.${innerKey}`);\n    const outerBeetInfo = this.beets.get(key);\n    assert(outerBeetInfo != null, 'Outer filter key needs to be an existing field name');\n    const beetInfo = outerBeetInfo.beet;\n    let offset = outerBeetInfo.offset;\n    const outerBeet = isFixedSizeBeet(beetInfo) ? beetInfo : beetInfo.toFixedFromValue(val);\n    let beet;\n\n    for (const [k, v] of outerBeet.fields) {\n      if (k === innerKey) {\n        beet = v;\n        break;\n      }\n\n      offset += v.byteSize;\n    }\n\n    assert(beet != null, `${innerKey} is not a field of the ${key} struct`);\n    const bytes = encodeFixedBeet(beet, val);\n\n    this._addFilter({\n      memcmp: {\n        offset,\n        bytes\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Adds a _memcmp_ filter for a field inside a field which is a struct value.\n   * The provided keys need to be separated by a `.` and only one level of\n   * nesting is supported at this point.\n   *\n   * The filter is applied to the inner value.\n   *\n   * ## Example\n   *\n   * ### Given:\n   *\n   * ```typescript\n   * type Inner = {\n   *   a: number\n   * }\n   * type Outer = {\n   *   idx: number\n   *   inner: Inner\n   * }\n   * ```\n   * ### Apply a filter on `a` of the `Inner` type:\n   *\n   * ```typescript\n   * gpaBuilder.addInnerFilter('inner.a', 2)\n   * ```\n   *\n   * @param keys - the names of the fields by which to filter, i.e. `'outer.inner'`\n   * @param val - the field value that the filter should match\n   */\n\n\n  addInnerFilter(keys, val) {\n    const parts = keys.split('.');\n    assert.equal(parts.length, 2, `inner filters can go only one level deep, i.e. 'outer.inner' is ok, but 'outer.inner.deep' is not`);\n    const [ka, kb] = parts;\n    return this._addInnerFilter(ka, kb, val);\n  }\n  /**\n   * Adds a _memcmp_ filter for the provided {@link key} of the struct.\n   *\n   * @param key - the name of the field by which to filter\n   * @param val - the field value that the filter should match\n   */\n\n\n  addFilter(key, val) {\n    const beetInfo = this.beets.get(key);\n    assert(beetInfo != null, 'Filter key needs to be an existing field name');\n    const beet = isFixedSizeBeet(beetInfo.beet) ? beetInfo.beet : beetInfo.beet.toFixedFromValue(val);\n    const bytes = encodeFixedBeet(beet, val);\n\n    this._addFilter({\n      memcmp: {\n        offset: beetInfo.offset,\n        bytes\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Adds a `dataSize` filter which will match on account's sizes.\n   * You have to provide that {@link size} for accounts that don't have a fixed size.\n   * For _fixed_ size accounts that size is determined for you.\n   *\n   * @param size - the account size to match for\n   */\n\n\n  dataSize(size) {\n    size = size !== null && size !== void 0 ? size : this.accountSize;\n    assert(size != null, 'for accounts of dynamic size the dataSize arg needs to be provided');\n    return this._addFilter({\n      dataSize: size\n    });\n  }\n  /**\n   * Attempts to find the accounts matching the configured filters.\n   *\n   * @param connection used to query the program accounts on the cluster\n   */\n\n\n  run(connection) {\n    return connection.getProgramAccounts(this.programId, this.config);\n  }\n  /**\n   * Creates a GPA builder that supports adding up to four filters for\n   * fixed size fields.\n   *\n   * Once a non-fixed field is encountered, the remaining fields following it\n   * will not be included as a filter option since their position in the\n   * bytes array will change depending on the content of the non-fixed field.\n   *\n   * @param programId - the id of the program that owns the accounts we are querying\n   * @param beetFields - the beet fields that make up the structure of the account data\n   */\n\n\n  static fromBeetFields(programId, beetFields) {\n    const map = new Map();\n    let offset = 0;\n    let encounteredNonFixed = false;\n\n    for (const [k, v] of beetFields) {\n      map.set(k, {\n        beet: v,\n        offset\n      });\n\n      if (!isFixedSizeBeet(v)) {\n        encounteredNonFixed = true;\n        break;\n      }\n\n      offset += v.byteSize;\n    }\n\n    const accountSize = encounteredNonFixed ? undefined : offset;\n    return new GpaBuilder(programId, map, accountSize);\n  }\n  /**\n   * Convenience wrapper around {@link GpaBuilder.fromBeetFields} that allows\n   * providing a struct which contains the beet fields.\n   *\n   * @param programId - the id of the program that owns the accounts we are querying\n   * @param struct - containing the beet `fields` specifying the layout of the account\n   */\n\n\n  static fromStruct(programId, struct) {\n    return GpaBuilder.fromBeetFields(programId, struct.fields);\n  }\n\n}","map":{"version":3,"sources":["../../../../src/gpa/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isFixedSizeBeet, } from '@metaplex-foundation/beet';\nimport { strict as assert } from 'assert';\nimport { logTrace } from '../utils';\nimport { encodeFixedBeet } from './util';\n/**\n * Provides an Account specific GPA builder.\n *\n * @template T - the type of the account for which the GpaBuilder is used\n */\nexport class GpaBuilder {\n    constructor(programId, beets, accountSize) {\n        this.programId = programId;\n        this.beets = beets;\n        this.accountSize = accountSize;\n        /**\n         * web3.js {@link GetProgramAccountsConfig} configured via filter GpaBuilder filter methods.\n         */\n        this.config = {};\n    }\n    _addFilter(filter) {\n        if (this.config.filters == null) {\n            this.config.filters = [];\n        }\n        this.config.filters.push(filter);\n        return this;\n    }\n    _addInnerFilter(key, innerKey, val) {\n        logTrace(`gpa.addInnerFilter: ${key}.${innerKey}`);\n        const outerBeetInfo = this.beets.get(key);\n        assert(outerBeetInfo != null, 'Outer filter key needs to be an existing field name');\n        const beetInfo = outerBeetInfo.beet;\n        let offset = outerBeetInfo.offset;\n        const outerBeet = isFixedSizeBeet(beetInfo)\n            ? beetInfo\n            : beetInfo.toFixedFromValue(val);\n        let beet;\n        for (const [k, v] of outerBeet.fields) {\n            if (k === innerKey) {\n                beet = v;\n                break;\n            }\n            offset += v.byteSize;\n        }\n        assert(beet != null, `${innerKey} is not a field of the ${key} struct`);\n        const bytes = encodeFixedBeet(beet, val);\n        this._addFilter({ memcmp: { offset, bytes } });\n        return this;\n    }\n    /**\n     * Adds a _memcmp_ filter for a field inside a field which is a struct value.\n     * The provided keys need to be separated by a `.` and only one level of\n     * nesting is supported at this point.\n     *\n     * The filter is applied to the inner value.\n     *\n     * ## Example\n     *\n     * ### Given:\n     *\n     * ```typescript\n     * type Inner = {\n     *   a: number\n     * }\n     * type Outer = {\n     *   idx: number\n     *   inner: Inner\n     * }\n     * ```\n     * ### Apply a filter on `a` of the `Inner` type:\n     *\n     * ```typescript\n     * gpaBuilder.addInnerFilter('inner.a', 2)\n     * ```\n     *\n     * @param keys - the names of the fields by which to filter, i.e. `'outer.inner'`\n     * @param val - the field value that the filter should match\n     */\n    addInnerFilter(keys, val) {\n        const parts = keys.split('.');\n        assert.equal(parts.length, 2, `inner filters can go only one level deep, i.e. 'outer.inner' is ok, but 'outer.inner.deep' is not`);\n        const [ka, kb] = parts;\n        return this._addInnerFilter(ka, kb, val);\n    }\n    /**\n     * Adds a _memcmp_ filter for the provided {@link key} of the struct.\n     *\n     * @param key - the name of the field by which to filter\n     * @param val - the field value that the filter should match\n     */\n    addFilter(key, val) {\n        const beetInfo = this.beets.get(key);\n        assert(beetInfo != null, 'Filter key needs to be an existing field name');\n        const beet = isFixedSizeBeet(beetInfo.beet)\n            ? beetInfo.beet\n            : beetInfo.beet.toFixedFromValue(val);\n        const bytes = encodeFixedBeet(beet, val);\n        this._addFilter({ memcmp: { offset: beetInfo.offset, bytes } });\n        return this;\n    }\n    /**\n     * Adds a `dataSize` filter which will match on account's sizes.\n     * You have to provide that {@link size} for accounts that don't have a fixed size.\n     * For _fixed_ size accounts that size is determined for you.\n     *\n     * @param size - the account size to match for\n     */\n    dataSize(size) {\n        size = size !== null && size !== void 0 ? size : this.accountSize;\n        assert(size != null, 'for accounts of dynamic size the dataSize arg needs to be provided');\n        return this._addFilter({ dataSize: size });\n    }\n    /**\n     * Attempts to find the accounts matching the configured filters.\n     *\n     * @param connection used to query the program accounts on the cluster\n     */\n    run(connection) {\n        return connection.getProgramAccounts(this.programId, this.config);\n    }\n    /**\n     * Creates a GPA builder that supports adding up to four filters for\n     * fixed size fields.\n     *\n     * Once a non-fixed field is encountered, the remaining fields following it\n     * will not be included as a filter option since their position in the\n     * bytes array will change depending on the content of the non-fixed field.\n     *\n     * @param programId - the id of the program that owns the accounts we are querying\n     * @param beetFields - the beet fields that make up the structure of the account data\n     */\n    static fromBeetFields(programId, beetFields) {\n        const map = new Map();\n        let offset = 0;\n        let encounteredNonFixed = false;\n        for (const [k, v] of beetFields) {\n            map.set(k, { beet: v, offset });\n            if (!isFixedSizeBeet(v)) {\n                encounteredNonFixed = true;\n                break;\n            }\n            offset += v.byteSize;\n        }\n        const accountSize = encounteredNonFixed ? undefined : offset;\n        return new GpaBuilder(programId, map, accountSize);\n    }\n    /**\n     * Convenience wrapper around {@link GpaBuilder.fromBeetFields} that allows\n     * providing a struct which contains the beet fields.\n     *\n     * @param programId - the id of the program that owns the accounts we are querying\n     * @param struct - containing the beet `fields` specifying the layout of the account\n     */\n    static fromStruct(programId, struct) {\n        return GpaBuilder.fromBeetFields(programId, struct.fields);\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}