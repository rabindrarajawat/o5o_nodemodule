{"ast":null,"code":"import { createDefaultAddressSelector, createDefaultAuthorizationResultCache, createDefaultWalletNotFoundHandler, SolanaMobileWalletAdapter, SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-adapter-mobile';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\n\nlet _userAgent;\n\nfunction getUserAgent() {\n  if (_userAgent === undefined) {\n    var _globalThis$navigator, _globalThis$navigator2;\n\n    _userAgent = (_globalThis$navigator = (_globalThis$navigator2 = globalThis.navigator) === null || _globalThis$navigator2 === void 0 ? void 0 : _globalThis$navigator2.userAgent) !== null && _globalThis$navigator !== void 0 ? _globalThis$navigator : null;\n  }\n\n  return _userAgent;\n}\n\nfunction getIsMobile(adapters) {\n  const userAgentString = getUserAgent();\n  return getEnvironment({\n    adapters: adapters,\n    userAgentString: userAgentString\n  }) === Environment.MOBILE_WEB;\n}\n\nfunction getUriForAppIdentity() {\n  const location = globalThis.location;\n\n  if (location == null) {\n    return;\n  }\n\n  return `${location.protocol}//${location.host}`;\n}\n\nexport function WalletProvider(_ref) {\n  let {\n    children: children,\n    wallets: adapters,\n    autoConnect: autoConnect,\n    localStorageKey = 'walletName',\n    onError: onError\n  } = _ref;\n  const {\n    connection: connection\n  } = useConnection();\n  const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n  const mobileWalletAdapter = useMemo(() => {\n    if (!getIsMobile(adaptersWithStandardAdapters)) {\n      return null;\n    }\n\n    const existingMobileWalletAdapter = adaptersWithStandardAdapters.find(adapter => adapter.name === SolanaMobileWalletAdapterWalletName);\n\n    if (existingMobileWalletAdapter) {\n      return existingMobileWalletAdapter;\n    }\n\n    return new SolanaMobileWalletAdapter({\n      addressSelector: createDefaultAddressSelector(),\n      appIdentity: {\n        uri: getUriForAppIdentity()\n      },\n      authorizationResultCache: createDefaultAuthorizationResultCache(),\n      cluster: getInferredClusterFromEndpoint(connection === null || connection === void 0 ? void 0 : connection.rpcEndpoint),\n      onWalletNotFound: createDefaultWalletNotFoundHandler()\n    });\n  }, [adaptersWithStandardAdapters, connection === null || connection === void 0 ? void 0 : connection.rpcEndpoint]);\n  const adaptersWithMobileWalletAdapter = useMemo(() => {\n    if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n      return adaptersWithStandardAdapters;\n    }\n\n    return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n  }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n  const [walletName, setWalletName] = useLocalStorage(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null);\n  const adapter = useMemo(() => {\n    var _adaptersWithMobileWa;\n\n    return (_adaptersWithMobileWa = adaptersWithMobileWalletAdapter.find(a => a.name === walletName)) !== null && _adaptersWithMobileWa !== void 0 ? _adaptersWithMobileWa : null;\n  }, [adaptersWithMobileWalletAdapter, walletName]);\n  useEffect(() => {\n    if (adapter == null) {\n      return;\n    }\n\n    function handleDisconnect() {\n      if (isUnloadingRef.current) {\n        return;\n      }\n\n      if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n        // Leave the adapter selected in the event of a disconnection.\n        return;\n      }\n\n      setWalletName(null);\n    }\n\n    adapter.on('disconnect', handleDisconnect);\n    return () => {\n      adapter.off('disconnect', handleDisconnect);\n    };\n  }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n  const hasUserSelectedAWallet = useRef(false);\n  const handleAutoConnectRequest = useMemo(() => {\n    if (autoConnect !== true || !adapter) {\n      return;\n    }\n\n    return () => hasUserSelectedAWallet.current ? adapter.connect() : adapter.autoConnect();\n  }, [adapter, autoConnect]);\n  useEffect(() => {\n    if (adapter == null) {\n      return;\n    }\n\n    return () => {\n      if ( // Selecting a wallet other than the mobile wallet adapter is not\n      // sufficient reason to call `disconnect` on the mobile wallet adapter.\n      // Calling `disconnect` on the mobile wallet adapter causes the entire\n      // authorization store to be wiped.\n      adapter.name !== SolanaMobileWalletAdapterWalletName) {\n        adapter.disconnect();\n      }\n    };\n  }, [adapter]);\n  const isUnloadingRef = useRef(false);\n  useEffect(() => {\n    if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n      isUnloadingRef.current = false;\n      return;\n    }\n\n    function handleBeforeUnload() {\n      isUnloadingRef.current = true;\n    }\n    /**\n     * Some wallets fire disconnection events when the window unloads. Since there's no way to\n     * distinguish between a disconnection event received because a user initiated it, and one\n     * that was received because they've closed the window, we have to track window unload\n     * events themselves. Downstream components use this information to decide whether to act\n     * upon or drop wallet events and errors.\n     */\n\n\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => {\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    };\n  }, [adaptersWithStandardAdapters, walletName]);\n  const handleConnectError = useCallback(() => {\n    if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {\n      // If any error happens while connecting, unset the adapter.\n      setWalletName(null);\n    }\n  }, [adapter, setWalletName]);\n  const selectWallet = useCallback(walletName => {\n    hasUserSelectedAWallet.current = true;\n    setWalletName(walletName);\n  }, [setWalletName]);\n  return React.createElement(WalletProviderBase, {\n    wallets: adaptersWithMobileWalletAdapter,\n    adapter: adapter,\n    isUnloadingRef: isUnloadingRef,\n    onAutoConnectRequest: handleAutoConnectRequest,\n    onConnectError: handleConnectError,\n    onError: onError,\n    onSelectWallet: selectWallet\n  }, children);\n}","map":{"version":3,"sources":["../../src/WalletProvider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { createDefaultAddressSelector, createDefaultAuthorizationResultCache, createDefaultWalletNotFoundHandler, SolanaMobileWalletAdapter, SolanaMobileWalletAdapterWalletName, } from '@solana-mobile/wallet-adapter-mobile';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\nlet _userAgent;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\nfunction getIsMobile(adapters) {\n    const userAgentString = getUserAgent();\n    return getEnvironment({ adapters, userAgentString }) === Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (location == null) {\n        return;\n    }\n    return `${location.protocol}//${location.host}`;\n}\nexport function WalletProvider({ children, wallets: adapters, autoConnect, localStorageKey = 'walletName', onError, }) {\n    const { connection } = useConnection();\n    const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n    const mobileWalletAdapter = useMemo(() => {\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find((adapter) => adapter.name === SolanaMobileWalletAdapterWalletName);\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new SolanaMobileWalletAdapter({\n            addressSelector: createDefaultAddressSelector(),\n            appIdentity: {\n                uri: getUriForAppIdentity(),\n            },\n            authorizationResultCache: createDefaultAuthorizationResultCache(),\n            cluster: getInferredClusterFromEndpoint(connection?.rpcEndpoint),\n            onWalletNotFound: createDefaultWalletNotFoundHandler(),\n        });\n    }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]);\n    const adaptersWithMobileWalletAdapter = useMemo(() => {\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n    }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n    const [walletName, setWalletName] = useLocalStorage(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null);\n    const adapter = useMemo(() => adaptersWithMobileWalletAdapter.find((a) => a.name === walletName) ?? null, [adaptersWithMobileWalletAdapter, walletName]);\n    useEffect(() => {\n        if (adapter == null) {\n            return;\n        }\n        function handleDisconnect() {\n            if (isUnloadingRef.current) {\n                return;\n            }\n            if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n                // Leave the adapter selected in the event of a disconnection.\n                return;\n            }\n            setWalletName(null);\n        }\n        adapter.on('disconnect', handleDisconnect);\n        return () => {\n            adapter.off('disconnect', handleDisconnect);\n        };\n    }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n    const hasUserSelectedAWallet = useRef(false);\n    const handleAutoConnectRequest = useMemo(() => {\n        if (autoConnect !== true || !adapter) {\n            return;\n        }\n        return () => (hasUserSelectedAWallet.current ? adapter.connect() : adapter.autoConnect());\n    }, [adapter, autoConnect]);\n    useEffect(() => {\n        if (adapter == null) {\n            return;\n        }\n        return () => {\n            if (\n            // Selecting a wallet other than the mobile wallet adapter is not\n            // sufficient reason to call `disconnect` on the mobile wallet adapter.\n            // Calling `disconnect` on the mobile wallet adapter causes the entire\n            // authorization store to be wiped.\n            adapter.name !== SolanaMobileWalletAdapterWalletName) {\n                adapter.disconnect();\n            }\n        };\n    }, [adapter]);\n    const isUnloadingRef = useRef(false);\n    useEffect(() => {\n        if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */\n        window.addEventListener('beforeunload', handleBeforeUnload);\n        return () => {\n            window.removeEventListener('beforeunload', handleBeforeUnload);\n        };\n    }, [adaptersWithStandardAdapters, walletName]);\n    const handleConnectError = useCallback(() => {\n        if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {\n            // If any error happens while connecting, unset the adapter.\n            setWalletName(null);\n        }\n    }, [adapter, setWalletName]);\n    const selectWallet = useCallback((walletName) => {\n        hasUserSelectedAWallet.current = true;\n        setWalletName(walletName);\n    }, [setWalletName]);\n    return (React.createElement(WalletProviderBase, { wallets: adaptersWithMobileWalletAdapter, adapter: adapter, isUnloadingRef: isUnloadingRef, onAutoConnectRequest: handleAutoConnectRequest, onConnectError: handleConnectError, onError: onError, onSelectWallet: selectWallet }, children));\n}\n//# sourceMappingURL=WalletProvider.js.map"]},"metadata":{},"sourceType":"module"}