{"ast":null,"code":"import { createUtilizeInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { useOperation } from '../../../types/Operation.mjs';\nimport { isSigner } from '../../../types/Signer.mjs';\nimport { ExpectedSignerError } from '../../../errors/SdkError.mjs';\nimport { toPublicKey } from '../../../types/PublicKey.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'UseNftOperation';\n/**\n * Utilizes a usable NFT.\n *\n * ```ts\n * await metaplex.nfts().use({ mintAddress });\n * await metaplex.nfts().use({ mintAddress, numberOfUses: 3 });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst useNftOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst useNftOperationHandler = {\n  handle: async (operation, metaplex, scope) => {\n    return useNftBuilder(metaplex, operation.input, scope).sendAndConfirm(metaplex, scope.confirmOptions);\n  }\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Utilizes a usable NFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .use({ mintAddress });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst useNftBuilder = function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    mintAddress,\n    numberOfUses = 1,\n    owner = metaplex.identity(),\n    useAuthority\n  } = params; // Programs.\n\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  if (!isSigner(owner) && !useAuthority) {\n    throw new ExpectedSignerError('owner', 'PublicKey', 'In order to use an NFT you must either provide the owner as a Signer ' + 'or a delegated use authority as a Signer.');\n  } // PDAs.\n\n\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs\n  });\n  const tokenAccount = params.ownerTokenAccount ?? metaplex.tokens().pdas().associatedTokenAccount({\n    mint: mintAddress,\n    owner: toPublicKey(owner),\n    programs\n  });\n  const useAuthorityRecord = useAuthority ? metaplex.nfts().pdas().useAuthorityRecord({\n    mint: mintAddress,\n    useAuthority: useAuthority.publicKey,\n    programs\n  }) : undefined;\n  const programAsBurner = metaplex.nfts().pdas().burner({\n    programs\n  });\n  return TransactionBuilder.make().setFeePayer(payer) // Update the metadata account.\n  .add({\n    instruction: createUtilizeInstruction({\n      metadata,\n      tokenAccount,\n      useAuthority: useAuthority ? useAuthority.publicKey : toPublicKey(owner),\n      mint: mintAddress,\n      owner: toPublicKey(owner),\n      useAuthorityRecord,\n      burner: useAuthorityRecord ? programAsBurner : undefined\n    }, {\n      utilizeArgs: {\n        numberOfUses\n      }\n    }, tokenMetadataProgram.address),\n    signers: [owner, useAuthority].filter(isSigner),\n    key: params.instructionKey ?? 'utilizeNft'\n  });\n};\n\nexport { useNftBuilder, useNftOperation, useNftOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/nftModule/operations/useNft.ts"],"names":["Key","useNftOperation","useOperation","useNftOperationHandler","handle","operation","metaplex","scope","useNftBuilder","input","sendAndConfirm","confirmOptions","params","options","programs","payer","rpc","getDefaultFeePayer","mintAddress","numberOfUses","owner","identity","useAuthority","tokenMetadataProgram","getTokenMetadata","isSigner","ExpectedSignerError","metadata","nfts","pdas","mint","tokenAccount","ownerTokenAccount","tokens","associatedTokenAccount","toPublicKey","useAuthorityRecord","publicKey","undefined","programAsBurner","burner","TransactionBuilder","make","setFeePayer","add","instruction","createUtilizeInstruction","utilizeArgs","address","signers","filter","key","instructionKey"],"mappings":"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","sourcesContent":["import { createUtilizeInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { ExpectedSignerError } from '@/errors';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UseNftOperation' as const;\n\n/**\n * Utilizes a usable NFT.\n *\n * ```ts\n * await metaplex.nfts().use({ mintAddress });\n * await metaplex.nfts().use({ mintAddress, numberOfUses: 3 });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const useNftOperation = useOperation<UseNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UseNftOperation = Operation<typeof Key, UseNftInput, UseNftOutput>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UseNftInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The number of uses to utilize.\n   *\n   * @defaultValue `1`\n   */\n  numberOfUses?: number; // Defaults to 1.\n\n  /**\n   * The owner of the NFT or SFT.\n   *\n   * This must be a Signer unless a `useAuthority` is provided.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  owner?: PublicKey | Signer;\n\n  /**\n   * The address of the token account linking the mint account\n   * with the owner account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `owner` parameters.\n   */\n  ownerTokenAccount?: PublicKey;\n\n  /**\n   * The delegated use authority that should authorize this operation.\n   *\n   * @defaultValue Defaults to not using a delegated use authority\n   * and using the `owner` parameter as a Signer instead.\n   */\n  useAuthority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UseNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const useNftOperationHandler: OperationHandler<UseNftOperation> = {\n  handle: async (\n    operation: UseNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<UseNftOutput> => {\n    return useNftBuilder(metaplex, operation.input, scope).sendAndConfirm(\n      metaplex,\n      scope.confirmOptions\n    );\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UseNftBuilderParams = Omit<UseNftInput, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Utilizes a usable NFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .use({ mintAddress });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const useNftBuilder = (\n  metaplex: Metaplex,\n  params: UseNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    numberOfUses = 1,\n    owner = metaplex.identity(),\n    useAuthority,\n  } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  if (!isSigner(owner) && !useAuthority) {\n    throw new ExpectedSignerError(\n      'owner',\n      'PublicKey',\n      'In order to use an NFT you must either provide the owner as a Signer ' +\n        'or a delegated use authority as a Signer.'\n    );\n  }\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const tokenAccount =\n    params.ownerTokenAccount ??\n    metaplex\n      .tokens()\n      .pdas()\n      .associatedTokenAccount({\n        mint: mintAddress,\n        owner: toPublicKey(owner),\n        programs,\n      });\n  const useAuthorityRecord = useAuthority\n    ? metaplex.nfts().pdas().useAuthorityRecord({\n        mint: mintAddress,\n        useAuthority: useAuthority.publicKey,\n        programs,\n      })\n    : undefined;\n  const programAsBurner = metaplex.nfts().pdas().burner({ programs });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the metadata account.\n      .add({\n        instruction: createUtilizeInstruction(\n          {\n            metadata,\n            tokenAccount,\n            useAuthority: useAuthority\n              ? useAuthority.publicKey\n              : toPublicKey(owner),\n            mint: mintAddress,\n            owner: toPublicKey(owner),\n            useAuthorityRecord,\n            burner: useAuthorityRecord ? programAsBurner : undefined,\n          },\n          { utilizeArgs: { numberOfUses } },\n          tokenMetadataProgram.address\n        ),\n        signers: [owner, useAuthority].filter(isSigner),\n        key: params.instructionKey ?? 'utilizeNft',\n      })\n  );\n};\n"]},"metadata":{},"sourceType":"module"}