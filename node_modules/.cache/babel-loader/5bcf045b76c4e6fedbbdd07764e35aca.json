{"ast":null,"code":"var _s = $RefreshSig$();\n\n/* eslint-disable react-hooks/exhaustive-deps */\n\n/* eslint-disable eqeqeq */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { useEffect, useState } from \"react\";\nimport * as anchor from \"@project-serum/anchor\";\nimport useWalletBalance from \"./use-wallet-balance\";\nimport { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { programs } from \"@metaplex/js\";\nimport toast from \"react-hot-toast\";\nimport { PublicKey, Transaction, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\nimport * as splToken from \"@solana/spl-token\";\nimport axios from \"axios\";\nimport { STAKE_DATA_SIZE, STAKE_CONTRACT_IDL } from \"../constant/contract\";\nimport { GLOBAL_AUTHORITY_SEED, NEXT_PUBLIC_SOLANA_NETWORK, NEXT_PUBLIC_STAKE_CONTRACT_ID, REWARD_TOKEN, REWARD_TOKEN_DECIMALS, USER_POOL_DATA_SEED, USER_POOL_SEED } from \"../constant/env\";\nimport { printLog } from \"../utils/utility\";\nimport { sendTransactions } from \"../helpers/sol/connection\";\nconst {\n  metadata: {\n    Metadata: Metadata\n  }\n} = programs;\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"); // const connection = new anchor.web3.Connection(\n//   NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\"\n//     ? \"https://metaplex.devnet.rpcpool.com\"\n//     : \"https://metaplex.mainnet.rpcpool.com\"\n// );\n\nconst connection = new anchor.web3.Connection(NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\" ? \"https://api.devnet.solana.com\" : \"https://metaplex.mainnet.rpcpool.com\");\nconst programId = new PublicKey(NEXT_PUBLIC_STAKE_CONTRACT_ID);\nconst idl = STAKE_CONTRACT_IDL;\nconst confirmOption = {\n  commitment: \"finalized\",\n  preflightCommitment: \"finalized\",\n  skipPreflight: false\n};\nconst rewardMint = new PublicKey(REWARD_TOKEN);\n\nconst createAssociatedTokenAccountInstruction = (associatedTokenAddress, payer, walletAddress, splTokenMintAddress) => {\n  const keys = [{\n    pubkey: payer,\n    isSigner: true,\n    isWritable: true\n  }, {\n    pubkey: associatedTokenAddress,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: walletAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: splTokenMintAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: anchor.web3.SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: TOKEN_PROGRAM_ID,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  return new anchor.web3.TransactionInstruction({\n    keys: keys,\n    programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n    data: Buffer.from([])\n  });\n};\n\nconst sendTransaction = async (transaction, signers, wallet) => {\n  try {\n    transaction.feePayer = wallet.publicKey;\n    transaction.recentBlockhash = (await connection.getRecentBlockhash(\"max\")).blockhash;\n    await transaction.setSigners(wallet.publicKey, ...signers.map(s => s.publicKey));\n    if (signers.length != 0) await transaction.partialSign(...signers);\n    const signedTransaction = await wallet.signTransaction(transaction);\n    let hash = await connection.sendRawTransaction(await signedTransaction.serialize());\n    await connection.confirmTransaction(hash);\n    toast.success(\"Transaction succeed.\");\n  } catch (err) {\n    toast.error(\"Transaction failed. Please try again.\");\n  }\n};\n\nconst getTokenWallet = async (wallet, mint) => {\n  return (await anchor.web3.PublicKey.findProgramAddress([wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], ASSOCIATED_TOKEN_PROGRAM_ID))[0];\n};\n\nconst getMetadata = async mint => {\n  return (await anchor.web3.PublicKey.findProgramAddress([Buffer.from(\"metadata\"), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()], TOKEN_METADATA_PROGRAM_ID))[0];\n};\n\nconst getStakedNftsForOwner = async wallet => {\n  const provider = new anchor.Provider(connection, wallet, anchor.Provider.defaultOptions());\n  const program = new anchor.Program(idl, programId, provider);\n  const allTokens = []; // let [globalAuthority] = await PublicKey.findProgramAddress(\n  //     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\n  //     program.programId\n  // );\n\n  let stakedNftList = await connection.getParsedProgramAccounts(programId);\n\n  for (let nftAccount of stakedNftList) {\n    try {\n      let stakedNft = await program.account.userPoolData.fetch(nftAccount.pubkey);\n      console.log(nftAccount);\n\n      if (stakedNft.owner.toString() !== wallet.publicKey.toString()) {\n        continue;\n      }\n\n      let mint = stakedNft.nftMint;\n      let pda = await getMetadata(mint);\n      let account = await getTokenWallet(wallet.publicKey, mint);\n      const accountInfo = await connection.getParsedAccountInfo(pda);\n      let metadata = new Metadata(wallet.publicKey.toString(), accountInfo.value); // if (metadata.data.data.symbol == COLLECTION_NAME) {\n\n      const {\n        data: data\n      } = await axios.get(metadata.data.data.uri);\n      const entireData = { ...data,\n        id: Number(data.name.replace(/^\\D+/g, \"\").split(\" - \")[0])\n      };\n      allTokens.push({\n        account: account,\n        poolKey: nftAccount.pubkey,\n        address: mint,\n        ...entireData\n      }); // }\n    } catch (err) {\n      console.log(err);\n    }\n  }\n\n  return allTokens;\n};\n\nconst getStakedNftsForOwner1 = async wallet => {\n  const provider = new anchor.Provider(connection, wallet, anchor.Provider.defaultOptions());\n  const program = new anchor.Program(idl, programId, provider);\n  const allTokens = [];\n\n  try {\n    let resp = await connection.getProgramAccounts(programId, {\n      dataSlice: {\n        length: 0,\n        offset: 0\n      },\n      filters: [{\n        dataSize: STAKE_DATA_SIZE\n      }, {\n        memcmp: {\n          offset: 8,\n          bytes: wallet.publicKey.toBase58()\n        }\n      }]\n    });\n\n    for (let nftAccount of resp) {\n      let stakedNft = await program.account.userPool.fetch(nftAccount.pubkey);\n\n      if (stakedNft.itemCount == 0) {\n        continue;\n      }\n\n      for (let i = 0; i < stakedNft.itemCount; i++) {\n        let mint = stakedNft.nftMintList[i];\n        let pda = await getMetadata(mint);\n        const accountInfo = await connection.getParsedAccountInfo(pda);\n        let metadata = new Metadata(wallet.publicKey.toString(), accountInfo.value);\n        const {\n          data: data\n        } = await axios.get(metadata.data.data.uri);\n        const entireData = { ...data,\n          id: Number(data.name.replace(/^\\D+/g, \"\").split(\" - \")[0])\n        };\n        allTokens.push({\n          poolKey: nftAccount.pubkey,\n          address: mint,\n          ...entireData\n        });\n      }\n    }\n  } catch (e) {\n    console.log(e);\n  }\n\n  return allTokens;\n};\n\nconst getPoolInfo = async wallet => {\n  const provider = new anchor.Provider(connection, wallet, anchor.Provider.defaultOptions());\n  const program = new anchor.Program(idl, programId, provider);\n  let userPoolInfo = null; // for (let stakeAccount of resp) {\n\n  let [userPool] = await PublicKey.findProgramAddress([Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()], program.programId);\n\n  try {\n    userPoolInfo = await program.account.userPool.fetch(userPool);\n  } catch {}\n\n  return userPoolInfo;\n};\n\nconst getGlobalInfo = async wallet => {\n  const provider = new anchor.Provider(connection, wallet, anchor.Provider.defaultOptions());\n  const program = new anchor.Program(idl, programId, provider);\n  let globalInfo = null; // for (let stakeAccount of resp) {\n\n  let [globalAuthority] = await PublicKey.findProgramAddress([Buffer.from(GLOBAL_AUTHORITY_SEED)], program.programId);\n\n  try {\n    globalInfo = await program.account.globalPool.fetch(globalAuthority); //\n  } catch (err) {\n    console.log(err);\n  }\n\n  return globalInfo;\n};\n\nconst _stakeNftList = async (wallet, stakeMode, nftMintList) => {\n  let provider = new anchor.Provider(connection, wallet, anchor.Provider.defaultOptions());\n  let program = new anchor.Program(idl, programId, provider);\n  let [userPool] = await PublicKey.findProgramAddress([Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()], program.programId); // let transaction = new Transaction();\n  // let signers: Keypair[] = [];\n\n  try {\n    const signersMatrix = [];\n    const instructionsMatrix = [];\n    let userPoolInfo = await getPoolInfo(wallet);\n    let instructions = [];\n\n    if (userPoolInfo == null) {\n      instructions.push(await program.instruction.initUserPool({\n        accounts: {\n          owner: wallet.publicKey,\n          userPool: userPool,\n          systemProgram: anchor.web3.SystemProgram.programId\n        }\n      }));\n      let keypair = anchor.web3.Keypair.generate();\n      let signers = [keypair];\n      signersMatrix.push(signers);\n      instructionsMatrix.push(instructions);\n    }\n\n    const [globalAuthority] = await PublicKey.findProgramAddress([Buffer.from(GLOBAL_AUTHORITY_SEED)], program.programId);\n\n    for (let i = 0; i < nftMintList.length; i++) {\n      let instructions = [];\n      let nftMint = nftMintList[i];\n      const sourceNftAccount = nftMint.account;\n      const destNftAccount = await getTokenWallet(globalAuthority, nftMint.address);\n      console.log(\"mint-2\", nftMint.address.toString(), \"sourceNftAccount\", sourceNftAccount.toString(), \"destNftAccount\", destNftAccount.toString());\n\n      if ((await connection.getAccountInfo(destNftAccount)) == null) {\n        // transaction.add(createAssociatedTokenAccountInstruction(destNftAccount, wallet.publicKey, globalAuthority, nftMint.address))\n        instructions.push(createAssociatedTokenAccountInstruction(destNftAccount, wallet.publicKey, globalAuthority, nftMint.address));\n      }\n\n      let [userPoolData] = await PublicKey.findProgramAddress([Buffer.from(USER_POOL_DATA_SEED), wallet.publicKey.toBuffer(), nftMint.address.toBuffer()], program.programId);\n      instructions.push(await program.instruction.stakeNft(1, {\n        accounts: {\n          owner: wallet.publicKey,\n          userPool: userPool,\n          userPoolData: userPoolData,\n          globalAuthority: globalAuthority,\n          nftMint: nftMint.address,\n          sourceNftAccount: sourceNftAccount,\n          destNftAccount: destNftAccount,\n          tokenProgram: TOKEN_PROGRAM_ID,\n          systemProgram: anchor.web3.SystemProgram.programId\n        }\n      })); // transaction.add(\n      //     await program.instruction.stakeNft({\n      //         accounts: {\n      //             owner: wallet.publicKey,\n      //             userPool: userPool,\n      //             userPoolData: userPoolData,\n      //             globalAuthority: globalAuthority,\n      //             nftMint: nftMint.address,\n      //             sourceNftAccount: sourceNftAccount,\n      //             destNftAccount: destNftAccount,\n      //             tokenProgram: TOKEN_PROGRAM_ID,\n      //             systemProgram: anchor.web3.SystemProgram.programId,\n      //         }\n      //     })\n      // );\n\n      let keypair = anchor.web3.Keypair.generate();\n      let signers = [keypair];\n      signersMatrix.push(signers);\n      instructionsMatrix.push(instructions);\n    }\n\n    await sendTransactions(connection, wallet, instructionsMatrix, signersMatrix); // await delay(20000);\n\n    toast.success(\"Transaction succeed.\");\n    return 1;\n  } catch (err) {\n    toast.error(\"Transaction failed.\");\n    console.log(err);\n    return 0;\n  } // await sendTransaction(transaction, signers, wallet);\n\n};\n\nfunction delay(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n\nconst stake = async (PoolKey, nftMint, wallet) => {\n  let provider = new anchor.Provider(connection, wallet, confirmOption);\n  let program = new anchor.Program(idl, programId, provider);\n  const [globalAuthority, globalBump] = await PublicKey.findProgramAddress([Buffer.from(GLOBAL_AUTHORITY_SEED)], program.programId);\n  const sourceNftAccount = await getTokenWallet(wallet.publicKey, nftMint);\n  const destNftAccount = await getTokenWallet(globalAuthority, nftMint);\n  let transaction = new Transaction();\n  let signers = [];\n  let [userPoolData] = await PublicKey.findProgramAddress([Buffer.from(USER_POOL_DATA_SEED), wallet.publicKey.toBuffer(), nftMint.toBuffer()], program.programId);\n  if ((await connection.getAccountInfo(destNftAccount)) == null) transaction.add(createAssociatedTokenAccountInstruction(destNftAccount, wallet.publicKey, globalAuthority, nftMint));\n  transaction.add(await program.instruction.stakeNft(1, {\n    accounts: {\n      owner: wallet.publicKey,\n      userPool: PoolKey,\n      userPoolData: userPoolData,\n      globalAuthority: globalAuthority,\n      nftMint: nftMint,\n      sourceNftAccount: sourceNftAccount,\n      destNftAccount: destNftAccount,\n      tokenProgram: TOKEN_PROGRAM_ID,\n      systemProgram: anchor.web3.SystemProgram.programId\n    }\n  }));\n  await sendTransaction(transaction, signers, wallet);\n};\n\nconst unStake = async (nfts, wallet) => {\n  let provider = new anchor.Provider(connection, wallet, anchor.Provider.defaultOptions());\n  let program = new anchor.Program(idl, programId, provider);\n  const [globalAuthority, globalBump] = await PublicKey.findProgramAddress([Buffer.from(GLOBAL_AUTHORITY_SEED)], program.programId);\n  let [userPool] = await PublicKey.findProgramAddress([Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()], program.programId);\n  const signersMatrix = [];\n  const instructionsMatrix = []; // let transaction = new Transaction();\n\n  for (let i = 0; i < nfts.length; i++) {\n    let instructions = [];\n    let destAccount = await getTokenWallet(wallet.publicKey, nfts[i].address);\n    let sourceAccount = await getTokenWallet(globalAuthority, nfts[i].address);\n    console.log(\"mint-1\", nfts[i].address.toString(), \"sourceNftAccount\", sourceAccount.toString(), \"destNftAccount\", destAccount.toString());\n\n    if ((await connection.getAccountInfo(destAccount)) == null) {\n      // transaction.add(createAssociatedTokenAccountInstruction(destAccount, wallet.publicKey, wallet.publicKey, nfts[i].address))\n      instructions.push(createAssociatedTokenAccountInstruction(destAccount, wallet.publicKey, wallet.publicKey, nfts[i].address));\n    }\n\n    let [userPoolData] = await PublicKey.findProgramAddress([Buffer.from(USER_POOL_DATA_SEED), wallet.publicKey.toBuffer(), nfts[i].address.toBuffer()], program.programId); // transaction.add(\n    //     await program.instruction.unstakeNft(globalBump, {\n    //         accounts: {\n    //             owner: wallet.publicKey,\n    //             userPool: userPool,\n    //             userPoolData: userPoolData,\n    //             globalAuthority: globalAuthority,\n    //             nftMint: nfts[i].address,\n    //             sourceNftAccount: sourceAccount,\n    //             destNftAccount: destAccount,\n    //             tokenProgram: TOKEN_PROGRAM_ID,\n    //         }\n    //     })\n    // );\n\n    instructions.push(await program.instruction.unstakeNft(globalBump, 1, {\n      accounts: {\n        owner: wallet.publicKey,\n        userPool: userPool,\n        userPoolData: userPoolData,\n        globalAuthority: globalAuthority,\n        nftMint: nfts[i].address,\n        sourceNftAccount: sourceAccount,\n        destNftAccount: destAccount,\n        tokenProgram: TOKEN_PROGRAM_ID\n      }\n    }));\n    let keypair = anchor.web3.Keypair.generate();\n    let signers = [keypair];\n    signersMatrix.push(signers);\n    instructionsMatrix.push(instructions);\n  } // await sendTransaction(transaction, [], wallet);\n\n\n  try {\n    await sendTransactions(connection, wallet, instructionsMatrix, signersMatrix); // await delay(20000);\n\n    toast.success(\"Transaction succeed.\");\n    return 1;\n  } catch (err) {\n    toast.error(\"Transaction failed.\");\n    console.log(err);\n    return 0;\n  }\n};\n\nasync function claim(wallet) {\n  let provider = new anchor.Provider(connection, wallet, confirmOption);\n  let program = new anchor.Program(idl, programId, provider);\n  const [globalAuthority, globalBump] = await PublicKey.findProgramAddress([Buffer.from(GLOBAL_AUTHORITY_SEED)], program.programId);\n  var myToken = new Token(connection, rewardMint, TOKEN_PROGRAM_ID, wallet);\n  let sourceRewardAccount = await getTokenWallet(globalAuthority, rewardMint);\n  let srcAccInfo = await myToken.getAccountInfo(sourceRewardAccount);\n\n  if (!srcAccInfo) {\n    return;\n  }\n\n  let transaction = new Transaction();\n  let destRewardAccount = await withFindOrInitAssociatedTokenAccount(transaction, provider.connection, rewardMint, wallet.publicKey, wallet.publicKey, true);\n  let [userPool, userBump] = await PublicKey.findProgramAddress([Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()], program.programId);\n  transaction.add(await program.instruction.claimReward({\n    accounts: {\n      owner: wallet.publicKey,\n      userPool: userPool,\n      globalAuthority: globalAuthority,\n      sourceAccount: sourceRewardAccount,\n      destAccount: destRewardAccount,\n      tokenProgram: TOKEN_PROGRAM_ID\n    }\n  }));\n\n  try {\n    await sendTransaction(transaction, [], wallet);\n  } catch (err) {\n    var _err$error;\n\n    printLog(err.reason || ((_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || err.message);\n  }\n}\n\nconst useNftStake = () => {\n  _s();\n\n  const [balance, setBalance] = useWalletBalance();\n  const anchorWallet = useAnchorWallet();\n  const [isLoading, setIsLoading] = useState(false);\n  const [stakedNfts, setStakedNfts] = useState([]); // const [claimedAmount, setClaimedAmount] = useState(0);\n  // const [dailyReward, setDailyReward] = useState(0);\n\n  const [claimAmount, setClaimAmount] = useState(0);\n  const [stakedCount, setStakedCount] = useState(0);\n  const [totalStakedNFT, setTotalStakedNFT] = useState(0);\n  const [rewardedTime, setRewardedTime] = useState(0);\n  useEffect(() => {\n    getStakedNfts();\n  }, [anchorWallet, balance]);\n  useEffect(() => {// const interval = setInterval(async () => {\n    //   try {\n    //     if (\n    //       !anchorWallet ||\n    //       !anchorWallet.publicKey ||\n    //       !anchorWallet.signAllTransactions ||\n    //       !anchorWallet.signTransaction\n    //     ) {\n    //       return;\n    //     }\n    //     let poolInfo = await getPoolInfo(anchorWallet);\n    //     if (poolInfo != null) {\n    //       // let days = 0;\n    //       // if (Math.floor(Date.now() / 1000) > poolInfo.rewardTime.toNumber()) {\n    //       //   days =\n    //       //     (Math.floor(Date.now() / 1000) - poolInfo.rewardTime.toNumber()) /\n    //       //     DAY_TIME;\n    //       // }\n    //       // let reward = poolInfo.claimable.toNumber() / LAMPORTS_PER_SOL + poolInfo.stakedCount * days;\n    //       // setClaimAmount(Math.floor(reward * 100) / 100);\n    //       setStakedCount(poolInfo.stakedCount);\n    //     }\n    //   } catch (err) {\n    //     console.log(err);\n    //   }\n    // }, 10000);\n    // return () => clearInterval(interval);\n  }, [anchorWallet]);\n\n  const getStakedNfts = async () => {\n    try {\n      if (!anchorWallet || !anchorWallet.publicKey || !anchorWallet.signAllTransactions || !anchorWallet.signTransaction) {\n        return;\n      }\n\n      setIsLoading(true);\n      const stakedNftsForOwner = await getStakedNftsForOwner(anchorWallet);\n      console.log(\"loaded staked nfts\", stakedNftsForOwner);\n      setStakedNfts(stakedNftsForOwner);\n      let globalInfo = await getGlobalInfo(anchorWallet);\n      console.log(\"globalInfo\", globalInfo);\n      setTotalStakedNFT(globalInfo === null || globalInfo === void 0 ? void 0 : globalInfo.stakedCount);\n      const poolInfo = await getPoolInfo(anchorWallet);\n      console.log(\"poolInfo\", poolInfo);\n\n      if (poolInfo != null) {\n        // setClaimAmount(poolInfo.claimableReward.toNumber() / LAMPORTS_PER_SOL);\n        // setDailyReward(get_daily_reward(poolInfo.stakedCount));\n        console.log(\"claimableReward\", poolInfo.claimableReward.toNumber() / REWARD_TOKEN_DECIMALS);\n        console.log(\"durationPoint\", poolInfo.durationPoint.toNumber());\n        console.log(\"dailyReward\", poolInfo.dailyReward.toNumber());\n        console.log(\"stakedCount\", poolInfo.stakedCount);\n        console.log(\"gangCreatedTime\", poolInfo.gangCreatedTime.toNumber(), new Date(poolInfo.gangCreatedTime.toNumber()).toUTCString());\n        setClaimAmount(Math.floor(poolInfo.claimableReward.toNumber() / REWARD_TOKEN_DECIMALS * 100) / 100);\n        setStakedCount(poolInfo.stakedCount); // console.log(\"poolinfo->totalrewards\", poolInfo?.totalReward.toNumber() / LAMPORTS_PER_SOL)\n\n        setRewardedTime(poolInfo.rewardTime.toNumber());\n      }\n\n      setIsLoading(false);\n    } catch (e) {\n      console.error(e);\n      setIsLoading(false);\n    }\n  };\n\n  const get_daily_reward_multiplier = cnt => {\n    let res = 0.0;\n\n    if (cnt == 1) {\n      res = 1;\n    } else if (cnt == 2) {\n      res = 1.25;\n    } else if (cnt == 4) {\n      res = 1.5;\n    } else if (cnt == 6) {\n      res = 1.75;\n    } else if (cnt == 8) {\n      res = 2;\n    }\n\n    return res;\n  };\n\n  const get_daily_reward = staked_count => {\n    let rest = staked_count % 8;\n    let daily_reward = 0;\n\n    if (rest % 2 == 0) {\n      daily_reward = 8.0 * 2.0 * 2.0 * Math.floor(staked_count / 8) + rest * 2.0 * get_daily_reward_multiplier(rest);\n    } else {\n      daily_reward = 8.0 * 2.0 * 2.0 * Math.floor(staked_count / 8) + (rest - 1) * 2.0 * get_daily_reward_multiplier(rest - 1) + 1.0 * 2.0 * 1.0;\n    } // let days = (now - self.reward_time) / DAY_TIME;\n    // self.total_reward = self.total_reward + daily_reward as u64 * days as u64 * DECIMAL;\n    // self.reward_time = now;\n    // Ok(self.total_reward)\n\n\n    return daily_reward;\n  };\n\n  const updateBalance = async wallet => {\n    const balance = await connection.getBalance(wallet.publicKey);\n    setBalance(balance / LAMPORTS_PER_SOL);\n  };\n\n  const stakeNftList = async (stakeMode, nftMintList) => {\n    if (!anchorWallet) {\n      toast.error(\"Connect wallet first, please.\");\n      return 0;\n    }\n\n    setIsLoading(true);\n\n    try {\n      const res = await _stakeNftList(anchorWallet, stakeMode, nftMintList); // await updateBalance(anchorWallet);\n      // if (res == 1) {\n      //   const poolInfo = await getPoolInfo(anchorWallet);\n      //   console.log(\"poolInfo\", poolInfo);\n      //   if (poolInfo != null) {\n      //     // setClaimAmount(poolInfo.stakedCount);\n      //     console.log(\n      //       \"poolInfo->totalReward\",\n      //       poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL\n      //     );\n      //     console.log(\"setClaimAmt3\", poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL)  \n      //     setClaimAmount(Math.floor(poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL * 100) / 100);\n      //     setRewardedTime(poolInfo.rewardTime.toNumber());\n      //   }\n      // }\n\n      setIsLoading(false);\n      return res;\n    } catch (err) {\n      setIsLoading(false);\n      console.log(err);\n      return 0;\n    }\n  };\n\n  const stakeNft = async (PoolKey, nftMint) => {\n    if (!anchorWallet) {\n      toast.error(\"Connect wallet first, please.\");\n      return;\n    }\n\n    setIsLoading(true);\n    await stake(PoolKey, nftMint, anchorWallet); // await updateBalance(anchorWallet);\n\n    setIsLoading(false);\n  };\n\n  const unStakeNft = async nfts => {\n    if (!anchorWallet) {\n      toast.error(\"Connect wallet first, please.\");\n      return;\n    }\n\n    setIsLoading(true);\n    const res = await unStake(nfts, anchorWallet); // if (res == 1) {\n    //   const poolInfo = await getPoolInfo(anchorWallet);\n    //   console.log(\"poolInfo\", poolInfo);\n    //   if (poolInfo != null) {\n    //     console.log(\n    //       \"poolInfo->totalReward\",\n    //       poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL\n    //     );\n    //     console.log(\"setClaimAmt4\", poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL)  \n    //     setClaimAmount(Math.floor(poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL * 100) / 100);\n    //     setRewardedTime(poolInfo.rewardTime.toNumber());\n    //   }\n    // }\n\n    setIsLoading(false);\n    return res;\n  };\n\n  const claimRewards = async () => {\n    if (!anchorWallet) {\n      toast.error(\"Connect wallet first, please.\");\n      return;\n    }\n\n    setIsLoading(true);\n    await claim(anchorWallet);\n    setIsLoading(false);\n  };\n\n  return {\n    isLoading: isLoading,\n    stakedNfts: stakedNfts,\n    stakedCount: stakedCount,\n    claimAmount: claimAmount,\n    totalStakedNFT: totalStakedNFT,\n    stakeNftList: stakeNftList,\n    stakeNft: stakeNft,\n    unStakeNft: unStakeNft,\n    claimRewards: claimRewards,\n    getStakedNfts: getStakedNfts,\n    setStakedNfts: setStakedNfts\n  };\n};\n\n_s(useNftStake, \"0wg2u8i812+h/YmMSKUfzJqlyuI=\", false, function () {\n  return [useWalletBalance, useAnchorWallet];\n});\n\nasync function withFindOrInitAssociatedTokenAccount(transaction, connection, mint, owner, payer, allowOwnerOffCurve) {\n  const associatedAddress = await splToken.Token.getAssociatedTokenAddress(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, mint, owner, allowOwnerOffCurve);\n  const account = await connection.getAccountInfo(associatedAddress);\n\n  if (!account) {\n    transaction.add(splToken.Token.createAssociatedTokenAccountInstruction(splToken.ASSOCIATED_TOKEN_PROGRAM_ID, splToken.TOKEN_PROGRAM_ID, mint, associatedAddress, owner, payer));\n  }\n\n  return associatedAddress;\n}\n\nexport default useNftStake;","map":{"version":3,"names":["useAnchorWallet","useEffect","useState","anchor","useWalletBalance","TOKEN_PROGRAM_ID","ASSOCIATED_TOKEN_PROGRAM_ID","Token","programs","toast","PublicKey","Transaction","LAMPORTS_PER_SOL","splToken","axios","STAKE_DATA_SIZE","STAKE_CONTRACT_IDL","GLOBAL_AUTHORITY_SEED","NEXT_PUBLIC_SOLANA_NETWORK","NEXT_PUBLIC_STAKE_CONTRACT_ID","REWARD_TOKEN","REWARD_TOKEN_DECIMALS","USER_POOL_DATA_SEED","USER_POOL_SEED","printLog","sendTransactions","metadata","Metadata","TOKEN_METADATA_PROGRAM_ID","web3","connection","Connection","programId","idl","confirmOption","commitment","preflightCommitment","skipPreflight","rewardMint","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","SystemProgram","SYSVAR_RENT_PUBKEY","TransactionInstruction","data","Buffer","from","sendTransaction","transaction","signers","wallet","feePayer","publicKey","recentBlockhash","getRecentBlockhash","blockhash","setSigners","map","s","length","partialSign","signedTransaction","signTransaction","hash","sendRawTransaction","serialize","confirmTransaction","success","err","error","getTokenWallet","mint","findProgramAddress","toBuffer","getMetadata","getStakedNftsForOwner","provider","Provider","defaultOptions","program","Program","allTokens","stakedNftList","getParsedProgramAccounts","nftAccount","stakedNft","account","userPoolData","fetch","console","log","owner","toString","nftMint","pda","accountInfo","getParsedAccountInfo","value","get","uri","entireData","id","Number","name","replace","split","push","poolKey","address","getStakedNftsForOwner1","resp","getProgramAccounts","dataSlice","offset","filters","dataSize","memcmp","bytes","toBase58","userPool","itemCount","i","nftMintList","e","getPoolInfo","userPoolInfo","getGlobalInfo","globalInfo","globalAuthority","globalPool","_stakeNftList","stakeMode","signersMatrix","instructionsMatrix","instructions","instruction","initUserPool","accounts","systemProgram","keypair","Keypair","generate","sourceNftAccount","destNftAccount","getAccountInfo","stakeNft","tokenProgram","delay","ms","Promise","resolve","setTimeout","stake","PoolKey","globalBump","add","unStake","nfts","destAccount","sourceAccount","unstakeNft","claim","myToken","sourceRewardAccount","srcAccInfo","destRewardAccount","withFindOrInitAssociatedTokenAccount","userBump","claimReward","reason","message","useNftStake","balance","setBalance","anchorWallet","isLoading","setIsLoading","stakedNfts","setStakedNfts","claimAmount","setClaimAmount","stakedCount","setStakedCount","totalStakedNFT","setTotalStakedNFT","rewardedTime","setRewardedTime","getStakedNfts","signAllTransactions","stakedNftsForOwner","poolInfo","claimableReward","toNumber","durationPoint","dailyReward","gangCreatedTime","Date","toUTCString","Math","floor","rewardTime","get_daily_reward_multiplier","cnt","res","get_daily_reward","staked_count","rest","daily_reward","updateBalance","getBalance","stakeNftList","unStakeNft","claimRewards","allowOwnerOffCurve","associatedAddress","getAssociatedTokenAddress"],"sources":["D:/software/o5o BNB/o5o-staking-frontend/src/hooks/use-nft-stake.ts"],"sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\r\n/* eslint-disable eqeqeq */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { AnchorWallet, useAnchorWallet } from \"@solana/wallet-adapter-react\";\r\nimport { useEffect, useState } from \"react\";\r\nimport * as anchor from \"@project-serum/anchor\";\r\nimport useWalletBalance from \"./use-wallet-balance\";\r\nimport {\r\n  TOKEN_PROGRAM_ID,\r\n  ASSOCIATED_TOKEN_PROGRAM_ID,\r\n  Token,\r\n} from \"@solana/spl-token\";\r\nimport { programs } from \"@metaplex/js\";\r\nimport toast from \"react-hot-toast\";\r\nimport {\r\n  Keypair,\r\n  PublicKey,\r\n  Transaction,\r\n  ConfirmOptions,\r\n  LAMPORTS_PER_SOL,\r\n  Connection,\r\n} from \"@solana/web3.js\";\r\nimport * as splToken from \"@solana/spl-token\";\r\nimport axios from \"axios\";\r\nimport {\r\n  STAKE_DATA_SIZE,\r\n  STAKE_CONTRACT_IDL,\r\n  COLLECTION_NAME,\r\n} from \"../constant/contract\";\r\nimport {\r\n  GLOBAL_AUTHORITY_SEED,\r\n  NEXT_PUBLIC_SOLANA_NETWORK,\r\n  NEXT_PUBLIC_STAKE_CONTRACT_ID,\r\n  REWARD_TOKEN,\r\n  REWARD_TOKEN_DECIMALS,\r\n  USER_POOL_DATA_SEED,\r\n  USER_POOL_SEED,\r\n} from \"../constant/env\";\r\nimport { printLog } from \"../utils/utility\";\r\nimport { sendTransactions } from \"../helpers/sol/connection\";\r\n\r\nconst {\r\n  metadata: { Metadata },\r\n} = programs;\r\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\r\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\r\n);\r\n// const connection = new anchor.web3.Connection(\r\n//   NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\"\r\n//     ? \"https://metaplex.devnet.rpcpool.com\"\r\n//     : \"https://metaplex.mainnet.rpcpool.com\"\r\n// );\r\n\r\nconst connection = new anchor.web3.Connection(\r\n  NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\"\r\n    ? \"https://api.devnet.solana.com\"\r\n    : \"https://metaplex.mainnet.rpcpool.com\"\r\n);\r\n\r\n\r\nconst programId = new PublicKey(NEXT_PUBLIC_STAKE_CONTRACT_ID!);\r\nconst idl = STAKE_CONTRACT_IDL as anchor.Idl;\r\nconst confirmOption: ConfirmOptions = {\r\n  commitment: \"finalized\",\r\n  preflightCommitment: \"finalized\",\r\n  skipPreflight: false,\r\n};\r\n\r\nconst rewardMint = new PublicKey(REWARD_TOKEN);\r\n\r\nconst createAssociatedTokenAccountInstruction = (\r\n  associatedTokenAddress: anchor.web3.PublicKey,\r\n  payer: anchor.web3.PublicKey,\r\n  walletAddress: anchor.web3.PublicKey,\r\n  splTokenMintAddress: anchor.web3.PublicKey\r\n) => {\r\n  const keys = [\r\n    { pubkey: payer, isSigner: true, isWritable: true },\r\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\r\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\r\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\r\n    {\r\n      pubkey: anchor.web3.SystemProgram.programId,\r\n      isSigner: false,\r\n      isWritable: false,\r\n    },\r\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\r\n    {\r\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n      isSigner: false,\r\n      isWritable: false,\r\n    },\r\n  ];\r\n  return new anchor.web3.TransactionInstruction({\r\n    keys,\r\n    programId: ASSOCIATED_TOKEN_PROGRAM_ID,\r\n    data: Buffer.from([]),\r\n  });\r\n};\r\n\r\nconst sendTransaction = async (\r\n  transaction: Transaction,\r\n  signers: Keypair[],\r\n  wallet: AnchorWallet\r\n) => {\r\n  try {\r\n    transaction.feePayer = wallet.publicKey;\r\n    transaction.recentBlockhash = (\r\n      await connection.getRecentBlockhash(\"max\")\r\n    ).blockhash;\r\n    await transaction.setSigners(\r\n      wallet.publicKey,\r\n      ...signers.map((s) => s.publicKey)\r\n    );\r\n    if (signers.length != 0) await transaction.partialSign(...signers);\r\n    const signedTransaction = await wallet.signTransaction(transaction);\r\n    let hash = await connection.sendRawTransaction(\r\n      await signedTransaction.serialize()\r\n    );\r\n    await connection.confirmTransaction(hash);\r\n    toast.success(\"Transaction succeed.\");\r\n  } catch (err) {\r\n    toast.error(\"Transaction failed. Please try again.\");\r\n  }\r\n};\r\n\r\nconst getTokenWallet = async (\r\n  wallet: anchor.web3.PublicKey,\r\n  mint: anchor.web3.PublicKey\r\n) => {\r\n  return (\r\n    await anchor.web3.PublicKey.findProgramAddress(\r\n      [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\r\n      ASSOCIATED_TOKEN_PROGRAM_ID\r\n    )\r\n  )[0];\r\n};\r\n\r\nconst getMetadata = async (\r\n  mint: anchor.web3.PublicKey\r\n): Promise<anchor.web3.PublicKey> => {\r\n  return (\r\n    await anchor.web3.PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from(\"metadata\"),\r\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n        mint.toBuffer(),\r\n      ],\r\n      TOKEN_METADATA_PROGRAM_ID\r\n    )\r\n  )[0];\r\n};\r\n\r\nconst getStakedNftsForOwner = async (wallet: AnchorWallet) => {\r\n  const provider = new anchor.Provider(\r\n    connection,\r\n    wallet,\r\n    anchor.Provider.defaultOptions()\r\n  );\r\n  const program = new anchor.Program(idl, programId, provider);\r\n  const allTokens: any = [];\r\n\r\n  // let [globalAuthority] = await PublicKey.findProgramAddress(\r\n  //     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n  //     program.programId\r\n  // );\r\n\r\n  let stakedNftList = await connection.getParsedProgramAccounts(programId);\r\n  for (let nftAccount of stakedNftList) {\r\n    try {\r\n      let stakedNft = await program.account.userPoolData.fetch(\r\n        nftAccount.pubkey\r\n      );\r\n      console.log(nftAccount);\r\n\r\n      if (stakedNft.owner.toString() !== wallet.publicKey.toString()) {\r\n        continue;\r\n      }\r\n\r\n      let mint = stakedNft.nftMint;\r\n      let pda = await getMetadata(mint);\r\n      let account = await getTokenWallet(wallet.publicKey, mint);\r\n      const accountInfo: any = await connection.getParsedAccountInfo(pda);\r\n      let metadata: any = new Metadata(\r\n        wallet.publicKey.toString(),\r\n        accountInfo.value\r\n      );\r\n      // if (metadata.data.data.symbol == COLLECTION_NAME) {\r\n        const { data }: any = await axios.get(metadata.data.data.uri);\r\n        const entireData = {\r\n          ...data,\r\n          id: Number(data.name.replace(/^\\D+/g, \"\").split(\" - \")[0]),\r\n        };\r\n        allTokens.push({\r\n          account: account,\r\n          poolKey: nftAccount.pubkey,\r\n          address: mint,\r\n          ...entireData,\r\n        });\r\n      // }\r\n    } catch (err) {\r\n      console.log(err);\r\n    }\r\n  }\r\n  return allTokens;\r\n};\r\n\r\nconst getStakedNftsForOwner1 = async (wallet: AnchorWallet) => {\r\n  const provider = new anchor.Provider(\r\n    connection,\r\n    wallet,\r\n    anchor.Provider.defaultOptions()\r\n  );\r\n  const program = new anchor.Program(idl, programId, provider);\r\n\r\n  const allTokens: any = [];\r\n  try {\r\n    let resp = await connection.getProgramAccounts(programId, {\r\n      dataSlice: {\r\n        length: 0,\r\n        offset: 0,\r\n      },\r\n      filters: [\r\n        {\r\n          dataSize: STAKE_DATA_SIZE,\r\n        },\r\n        {\r\n          memcmp: {\r\n            offset: 8,\r\n            bytes: wallet.publicKey.toBase58(),\r\n          },\r\n        },\r\n      ],\r\n    });\r\n\r\n    for (let nftAccount of resp) {\r\n      let stakedNft = await program.account.userPool.fetch(nftAccount.pubkey);\r\n      if (stakedNft.itemCount == 0) {\r\n        continue;\r\n      }\r\n\r\n      for (let i = 0; i < stakedNft.itemCount; i++) {\r\n        let mint = stakedNft.nftMintList[i];\r\n        let pda = await getMetadata(mint);\r\n        const accountInfo: any = await connection.getParsedAccountInfo(pda);\r\n        let metadata: any = new Metadata(\r\n          wallet.publicKey.toString(),\r\n          accountInfo.value\r\n        );\r\n        const { data }: any = await axios.get(metadata.data.data.uri);\r\n        const entireData = {\r\n          ...data,\r\n          id: Number(data.name.replace(/^\\D+/g, \"\").split(\" - \")[0]),\r\n        };\r\n        allTokens.push({\r\n          poolKey: nftAccount.pubkey,\r\n          address: mint,\r\n          ...entireData,\r\n        });\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.log(e);\r\n  }\r\n  return allTokens;\r\n};\r\n\r\nconst getPoolInfo = async (wallet: AnchorWallet) => {\r\n  const provider = new anchor.Provider(\r\n    connection,\r\n    wallet,\r\n    anchor.Provider.defaultOptions()\r\n  );\r\n  const program = new anchor.Program(idl, programId, provider);\r\n  let userPoolInfo = null;\r\n  // for (let stakeAccount of resp) {\r\n  let [userPool] = await PublicKey.findProgramAddress(\r\n    [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\r\n    program.programId\r\n  );\r\n  try {\r\n    userPoolInfo = await program.account.userPool.fetch(userPool);\r\n  } catch { }\r\n  return userPoolInfo;\r\n};\r\n\r\nconst getGlobalInfo = async (wallet: AnchorWallet) => {\r\n  const provider = new anchor.Provider(\r\n    connection,\r\n    wallet,\r\n    anchor.Provider.defaultOptions()\r\n  );\r\n  const program = new anchor.Program(idl, programId, provider);\r\n  let globalInfo = null;\r\n  // for (let stakeAccount of resp) {\r\n  let [globalAuthority] = await PublicKey.findProgramAddress(\r\n    [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n    program.programId\r\n  );\r\n\r\n  try {\r\n    globalInfo = await program.account.globalPool.fetch(globalAuthority); //\r\n  } catch (err) {\r\n    console.log(err);\r\n  }\r\n  return globalInfo;\r\n};\r\n\r\nconst _stakeNftList = async (\r\n  wallet: AnchorWallet,\r\n  stakeMode: any,\r\n  nftMintList: any\r\n) => {\r\n  let provider = new anchor.Provider(\r\n    connection,\r\n    wallet,\r\n    anchor.Provider.defaultOptions()\r\n  );\r\n  let program = new anchor.Program(idl, programId, provider);\r\n  let [userPool] = await PublicKey.findProgramAddress(\r\n    [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\r\n    program.programId\r\n  );\r\n  // let transaction = new Transaction();\r\n  // let signers: Keypair[] = [];\r\n\r\n  try {\r\n    const signersMatrix = [];\r\n    const instructionsMatrix = [];\r\n\r\n    let userPoolInfo = await getPoolInfo(wallet);\r\n    let instructions: any[] = [];\r\n    if (userPoolInfo == null) {\r\n      instructions.push(\r\n        await program.instruction.initUserPool({\r\n          accounts: {\r\n            owner: wallet.publicKey,\r\n            userPool: userPool,\r\n            systemProgram: anchor.web3.SystemProgram.programId,\r\n          },\r\n        })\r\n      );\r\n      let keypair = anchor.web3.Keypair.generate();\r\n      let signers = [keypair];\r\n\r\n      signersMatrix.push(signers);\r\n      instructionsMatrix.push(instructions);\r\n    }\r\n\r\n    const [globalAuthority] = await PublicKey.findProgramAddress(\r\n      [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n      program.programId\r\n    );\r\n\r\n    for (let i = 0; i < nftMintList.length; i++) {\r\n      let instructions: any[] = [];\r\n      let nftMint = nftMintList[i];\r\n\r\n      const sourceNftAccount = nftMint.account;\r\n      const destNftAccount = await getTokenWallet(\r\n        globalAuthority,\r\n        nftMint.address\r\n      );\r\n      console.log(\r\n        \"mint-2\",\r\n        nftMint.address.toString(),\r\n        \"sourceNftAccount\",\r\n        sourceNftAccount.toString(),\r\n        \"destNftAccount\",\r\n        destNftAccount.toString()\r\n      );\r\n\r\n      if ((await connection.getAccountInfo(destNftAccount)) == null) {\r\n        // transaction.add(createAssociatedTokenAccountInstruction(destNftAccount, wallet.publicKey, globalAuthority, nftMint.address))\r\n        instructions.push(\r\n          createAssociatedTokenAccountInstruction(\r\n            destNftAccount,\r\n            wallet.publicKey,\r\n            globalAuthority,\r\n            nftMint.address\r\n          )\r\n        );\r\n      }\r\n\r\n      let [userPoolData] = await PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from(USER_POOL_DATA_SEED),\r\n          wallet.publicKey.toBuffer(),\r\n          nftMint.address.toBuffer(),\r\n        ],\r\n        program.programId\r\n      );\r\n\r\n      instructions.push(\r\n        await program.instruction.stakeNft(1,{\r\n          accounts: {\r\n            owner: wallet.publicKey,\r\n            userPool: userPool,\r\n            userPoolData: userPoolData,\r\n            globalAuthority: globalAuthority,\r\n            nftMint: nftMint.address,\r\n            sourceNftAccount: sourceNftAccount,\r\n            destNftAccount: destNftAccount,\r\n            tokenProgram: TOKEN_PROGRAM_ID,\r\n            systemProgram: anchor.web3.SystemProgram.programId,\r\n          },\r\n        })\r\n      );\r\n\r\n      // transaction.add(\r\n      //     await program.instruction.stakeNft({\r\n      //         accounts: {\r\n      //             owner: wallet.publicKey,\r\n      //             userPool: userPool,\r\n      //             userPoolData: userPoolData,\r\n      //             globalAuthority: globalAuthority,\r\n      //             nftMint: nftMint.address,\r\n      //             sourceNftAccount: sourceNftAccount,\r\n      //             destNftAccount: destNftAccount,\r\n      //             tokenProgram: TOKEN_PROGRAM_ID,\r\n      //             systemProgram: anchor.web3.SystemProgram.programId,\r\n      //         }\r\n      //     })\r\n      // );\r\n\r\n      let keypair = anchor.web3.Keypair.generate();\r\n      let signers = [keypair];\r\n\r\n      signersMatrix.push(signers);\r\n      instructionsMatrix.push(instructions);\r\n    }\r\n\r\n    await sendTransactions(\r\n      connection,\r\n      wallet,\r\n      instructionsMatrix,\r\n      signersMatrix\r\n    );\r\n    // await delay(20000);\r\n\r\n    toast.success(\"Transaction succeed.\");\r\n    return 1;\r\n  } catch (err) {\r\n    toast.error(\"Transaction failed.\");\r\n    console.log(err);\r\n    return 0;\r\n  }\r\n  // await sendTransaction(transaction, signers, wallet);\r\n};\r\n\r\nfunction delay(ms: any) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n}\r\n\r\nconst stake = async (\r\n  PoolKey: PublicKey,\r\n  nftMint: PublicKey,\r\n  wallet: AnchorWallet\r\n) => {\r\n  let provider = new anchor.Provider(connection, wallet, confirmOption);\r\n  let program = new anchor.Program(idl, programId, provider);\r\n\r\n  const [globalAuthority, globalBump] = await PublicKey.findProgramAddress(\r\n    [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n    program.programId\r\n  );\r\n\r\n  const sourceNftAccount = await getTokenWallet(wallet.publicKey, nftMint);\r\n  const destNftAccount = await getTokenWallet(globalAuthority, nftMint);\r\n  let transaction = new Transaction();\r\n  let signers: Keypair[] = [];\r\n  let [userPoolData] = await PublicKey.findProgramAddress(\r\n    [\r\n      Buffer.from(USER_POOL_DATA_SEED),\r\n      wallet.publicKey.toBuffer(),\r\n      nftMint.toBuffer(),\r\n    ],\r\n    program.programId\r\n  );\r\n\r\n  if ((await connection.getAccountInfo(destNftAccount)) == null)\r\n    transaction.add(\r\n      createAssociatedTokenAccountInstruction(\r\n        destNftAccount,\r\n        wallet.publicKey,\r\n        globalAuthority,\r\n        nftMint\r\n      )\r\n    );\r\n  transaction.add(\r\n    await program.instruction.stakeNft(1,{\r\n      accounts: {\r\n        owner: wallet.publicKey,\r\n        userPool: PoolKey,\r\n        userPoolData: userPoolData,\r\n        globalAuthority: globalAuthority,\r\n        nftMint: nftMint,\r\n        sourceNftAccount: sourceNftAccount,\r\n        destNftAccount: destNftAccount,\r\n        tokenProgram: TOKEN_PROGRAM_ID,\r\n        systemProgram: anchor.web3.SystemProgram.programId,\r\n      },\r\n    })\r\n  );\r\n  await sendTransaction(transaction, signers, wallet);\r\n};\r\n\r\nconst unStake = async (nfts: any[], wallet: AnchorWallet) => {\r\n  let provider = new anchor.Provider(\r\n    connection,\r\n    wallet,\r\n    anchor.Provider.defaultOptions()\r\n  );\r\n  let program = new anchor.Program(idl, programId, provider);\r\n\r\n  const [globalAuthority, globalBump] = await PublicKey.findProgramAddress(\r\n    [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n    program.programId\r\n  );\r\n\r\n  let [userPool] = await PublicKey.findProgramAddress(\r\n    [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\r\n    program.programId\r\n  );\r\n\r\n  const signersMatrix = [];\r\n  const instructionsMatrix = [];\r\n\r\n  // let transaction = new Transaction();\r\n  for (let i = 0; i < nfts.length; i++) {\r\n    let instructions: any[] = [];\r\n    let destAccount = await getTokenWallet(wallet.publicKey, nfts[i].address);\r\n    let sourceAccount = await getTokenWallet(globalAuthority, nfts[i].address);\r\n\r\n    console.log(\r\n      \"mint-1\",\r\n      nfts[i].address.toString(),\r\n      \"sourceNftAccount\",\r\n      sourceAccount.toString(),\r\n      \"destNftAccount\",\r\n      destAccount.toString()\r\n    );\r\n\r\n    if ((await connection.getAccountInfo(destAccount)) == null) {\r\n      // transaction.add(createAssociatedTokenAccountInstruction(destAccount, wallet.publicKey, wallet.publicKey, nfts[i].address))\r\n      instructions.push(\r\n        createAssociatedTokenAccountInstruction(\r\n          destAccount,\r\n          wallet.publicKey,\r\n          wallet.publicKey,\r\n          nfts[i].address\r\n        )\r\n      );\r\n    }\r\n\r\n    let [userPoolData] = await PublicKey.findProgramAddress(\r\n      [\r\n        Buffer.from(USER_POOL_DATA_SEED),\r\n        wallet.publicKey.toBuffer(),\r\n        nfts[i].address.toBuffer(),\r\n      ],\r\n      program.programId\r\n    );\r\n\r\n    // transaction.add(\r\n    //     await program.instruction.unstakeNft(globalBump, {\r\n    //         accounts: {\r\n    //             owner: wallet.publicKey,\r\n    //             userPool: userPool,\r\n    //             userPoolData: userPoolData,\r\n    //             globalAuthority: globalAuthority,\r\n    //             nftMint: nfts[i].address,\r\n    //             sourceNftAccount: sourceAccount,\r\n    //             destNftAccount: destAccount,\r\n    //             tokenProgram: TOKEN_PROGRAM_ID,\r\n    //         }\r\n    //     })\r\n    // );\r\n\r\n    instructions.push(\r\n      await program.instruction.unstakeNft(globalBump,1, {\r\n        accounts: {\r\n          owner: wallet.publicKey,\r\n          userPool: userPool,\r\n          userPoolData: userPoolData,\r\n          globalAuthority: globalAuthority,\r\n          nftMint: nfts[i].address,\r\n          sourceNftAccount: sourceAccount,\r\n          destNftAccount: destAccount,\r\n          tokenProgram: TOKEN_PROGRAM_ID,\r\n        },\r\n      })\r\n    );\r\n    let keypair = anchor.web3.Keypair.generate();\r\n    let signers = [keypair];\r\n\r\n    signersMatrix.push(signers);\r\n    instructionsMatrix.push(instructions);\r\n  }\r\n\r\n  // await sendTransaction(transaction, [], wallet);\r\n  try {\r\n    await sendTransactions(\r\n      connection,\r\n      wallet,\r\n      instructionsMatrix,\r\n      signersMatrix\r\n    );\r\n    // await delay(20000);\r\n    toast.success(\"Transaction succeed.\");\r\n    return 1;\r\n  } catch (err) {\r\n    toast.error(\"Transaction failed.\");\r\n    console.log(err);\r\n    return 0;\r\n  }\r\n};\r\n\r\nasync function claim(wallet: AnchorWallet) {\r\n\r\n  let provider = new anchor.Provider(connection, wallet, confirmOption);\r\n  let program = new anchor.Program(idl, programId, provider)\r\n\r\n  const [globalAuthority, globalBump] = await PublicKey.findProgramAddress(\r\n      [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n      program.programId\r\n  );\r\n\r\n  var myToken = new Token(\r\n      connection,\r\n      rewardMint,\r\n      TOKEN_PROGRAM_ID,\r\n      wallet as any\r\n  );\r\n  let sourceRewardAccount = await getTokenWallet(globalAuthority, rewardMint);\r\n  let srcAccInfo = await myToken.getAccountInfo(sourceRewardAccount);\r\n  if (!srcAccInfo) {\r\n      return;\r\n  }\r\n\r\n  let transaction = new Transaction();\r\n\r\n  let destRewardAccount = await withFindOrInitAssociatedTokenAccount(\r\n      transaction,\r\n      provider.connection,\r\n      rewardMint,\r\n      wallet.publicKey,\r\n      wallet.publicKey,\r\n      true\r\n  );\r\n\r\n  let [userPool, userBump] = await PublicKey.findProgramAddress(\r\n      [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\r\n      program.programId\r\n  );\r\n\r\n  transaction.add(\r\n      await program.instruction.claimReward({\r\n          accounts: {\r\n              owner: wallet.publicKey,\r\n              userPool: userPool,\r\n              globalAuthority: globalAuthority,\r\n              sourceAccount: sourceRewardAccount,\r\n              destAccount: destRewardAccount,\r\n              tokenProgram: TOKEN_PROGRAM_ID,\r\n          }\r\n      })\r\n  )\r\n  try {\r\n      await sendTransaction(transaction, [], wallet);\r\n  } catch (err: any) {\r\n      printLog(err.reason || err.error?.message || err.message)\r\n  }\r\n}\r\n\r\nconst useNftStake = () => {\r\n  const [balance, setBalance] = useWalletBalance();\r\n  const anchorWallet = useAnchorWallet();\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [stakedNfts, setStakedNfts] = useState<Array<any>>([]);\r\n  // const [claimedAmount, setClaimedAmount] = useState(0);\r\n  // const [dailyReward, setDailyReward] = useState(0);\r\n  const [claimAmount, setClaimAmount] = useState(0);\r\n  const [stakedCount, setStakedCount] = useState(0);\r\n  const [totalStakedNFT, setTotalStakedNFT] = useState(0);\r\n  const [rewardedTime, setRewardedTime] = useState(0);\r\n\r\n  useEffect(() => {\r\n    getStakedNfts();\r\n  }, [anchorWallet, balance]);\r\n\r\n  useEffect(() => {\r\n    // const interval = setInterval(async () => {\r\n    //   try {\r\n    //     if (\r\n    //       !anchorWallet ||\r\n    //       !anchorWallet.publicKey ||\r\n    //       !anchorWallet.signAllTransactions ||\r\n    //       !anchorWallet.signTransaction\r\n    //     ) {\r\n    //       return;\r\n    //     }\r\n    //     let poolInfo = await getPoolInfo(anchorWallet);\r\n    //     if (poolInfo != null) {\r\n    //       // let days = 0;\r\n    //       // if (Math.floor(Date.now() / 1000) > poolInfo.rewardTime.toNumber()) {\r\n    //       //   days =\r\n    //       //     (Math.floor(Date.now() / 1000) - poolInfo.rewardTime.toNumber()) /\r\n    //       //     DAY_TIME;\r\n    //       // }\r\n    //       // let reward = poolInfo.claimable.toNumber() / LAMPORTS_PER_SOL + poolInfo.stakedCount * days;\r\n    //       // setClaimAmount(Math.floor(reward * 100) / 100);\r\n    //       setStakedCount(poolInfo.stakedCount);\r\n    //     }\r\n    //   } catch (err) {\r\n    //     console.log(err);\r\n    //   }\r\n    // }, 10000);\r\n    // return () => clearInterval(interval);\r\n  }, [anchorWallet]);\r\n\r\n  const getStakedNfts = async () => {\r\n    try {\r\n      if (\r\n        !anchorWallet ||\r\n        !anchorWallet.publicKey ||\r\n        !anchorWallet.signAllTransactions ||\r\n        !anchorWallet.signTransaction\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      setIsLoading(true);\r\n      const stakedNftsForOwner = await getStakedNftsForOwner(anchorWallet);\r\n      console.log(\"loaded staked nfts\", stakedNftsForOwner);\r\n      setStakedNfts(stakedNftsForOwner);\r\n      let globalInfo = await getGlobalInfo(anchorWallet);\r\n      console.log(\"globalInfo\", globalInfo);\r\n      setTotalStakedNFT(globalInfo?.stakedCount);\r\n      const poolInfo = await getPoolInfo(anchorWallet);\r\n      console.log(\"poolInfo\", poolInfo);\r\n      if (poolInfo != null) {\r\n        // setClaimAmount(poolInfo.claimableReward.toNumber() / LAMPORTS_PER_SOL);\r\n        // setDailyReward(get_daily_reward(poolInfo.stakedCount));\r\n        console.log(\"claimableReward\", poolInfo.claimableReward.toNumber() / REWARD_TOKEN_DECIMALS);\r\n        console.log(\"durationPoint\", poolInfo.durationPoint.toNumber());\r\n        console.log(\"dailyReward\", poolInfo.dailyReward.toNumber());     \r\n        console.log(\"stakedCount\", poolInfo.stakedCount);     \r\n        console.log(\"gangCreatedTime\", poolInfo.gangCreatedTime.toNumber(), new Date(poolInfo.gangCreatedTime.toNumber()).toUTCString());     \r\n        setClaimAmount(Math.floor(poolInfo.claimableReward.toNumber() / REWARD_TOKEN_DECIMALS * 100) / 100);\r\n        setStakedCount(poolInfo.stakedCount);\r\n        // console.log(\"poolinfo->totalrewards\", poolInfo?.totalReward.toNumber() / LAMPORTS_PER_SOL)\r\n        setRewardedTime(poolInfo.rewardTime.toNumber());\r\n      }\r\n      setIsLoading(false);\r\n    } catch (e){\r\n      console.error(e)\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const get_daily_reward_multiplier = (cnt: number) => {\r\n    let res = 0.0;\r\n    if (cnt == 1) {\r\n      res = 1;\r\n    } else if (cnt == 2) {\r\n      res = 1.25;\r\n    } else if (cnt == 4) {\r\n      res = 1.5;\r\n    } else if (cnt == 6) {\r\n      res = 1.75;\r\n    } else if (cnt == 8) {\r\n      res = 2;\r\n    }\r\n    return res;\r\n  };\r\n\r\n  const get_daily_reward = (staked_count: number) => {\r\n    let rest = staked_count % 8;\r\n    let daily_reward = 0;\r\n    if (rest % 2 == 0) {\r\n      daily_reward =\r\n        8.0 * 2.0 * 2.0 * Math.floor(staked_count / 8) +\r\n        rest * 2.0 * get_daily_reward_multiplier(rest);\r\n    } else {\r\n      daily_reward =\r\n        8.0 * 2.0 * 2.0 * Math.floor(staked_count / 8) +\r\n        (rest - 1) * 2.0 * get_daily_reward_multiplier(rest - 1) +\r\n        1.0 * 2.0 * 1.0;\r\n    }\r\n    // let days = (now - self.reward_time) / DAY_TIME;\r\n    // self.total_reward = self.total_reward + daily_reward as u64 * days as u64 * DECIMAL;\r\n    // self.reward_time = now;\r\n    // Ok(self.total_reward)\r\n    return daily_reward;\r\n  };\r\n\r\n  const updateBalance = async (wallet: AnchorWallet) => {\r\n    const balance = await connection.getBalance(wallet.publicKey);\r\n    setBalance(balance / LAMPORTS_PER_SOL);\r\n  };\r\n\r\n  const stakeNftList = async (stakeMode: any, nftMintList: any) => {\r\n    if (!anchorWallet) {\r\n      toast.error(\"Connect wallet first, please.\");\r\n      return 0;\r\n    }\r\n    setIsLoading(true);\r\n    try {\r\n      const res = await _stakeNftList(anchorWallet, stakeMode, nftMintList);\r\n      // await updateBalance(anchorWallet);\r\n      // if (res == 1) {\r\n      //   const poolInfo = await getPoolInfo(anchorWallet);\r\n      //   console.log(\"poolInfo\", poolInfo);\r\n      //   if (poolInfo != null) {\r\n      //     // setClaimAmount(poolInfo.stakedCount);\r\n      //     console.log(\r\n      //       \"poolInfo->totalReward\",\r\n      //       poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL\r\n      //     );\r\n      //     console.log(\"setClaimAmt3\", poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL)  \r\n      //     setClaimAmount(Math.floor(poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL * 100) / 100);\r\n      //     setRewardedTime(poolInfo.rewardTime.toNumber());\r\n      //   }\r\n      // }\r\n      setIsLoading(false);\r\n      return res;\r\n    } catch (err) {\r\n      setIsLoading(false);\r\n      console.log(err);\r\n      return 0;\r\n    }\r\n  };\r\n\r\n  const stakeNft = async (PoolKey: PublicKey, nftMint: PublicKey) => {\r\n    if (!anchorWallet) {\r\n      toast.error(\"Connect wallet first, please.\");\r\n      return;\r\n    }\r\n\r\n    setIsLoading(true);\r\n\r\n    await stake(PoolKey, nftMint, anchorWallet);\r\n    // await updateBalance(anchorWallet);\r\n\r\n    setIsLoading(false);\r\n  };\r\n\r\n  const unStakeNft = async (nfts: any[]) => {\r\n    if (!anchorWallet) {\r\n      toast.error(\"Connect wallet first, please.\");\r\n      return;\r\n    }\r\n    setIsLoading(true);\r\n    const res = await unStake(nfts, anchorWallet);\r\n    // if (res == 1) {\r\n    //   const poolInfo = await getPoolInfo(anchorWallet);\r\n    //   console.log(\"poolInfo\", poolInfo);\r\n    //   if (poolInfo != null) {\r\n    //     console.log(\r\n    //       \"poolInfo->totalReward\",\r\n    //       poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL\r\n    //     );\r\n    //     console.log(\"setClaimAmt4\", poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL)  \r\n    //     setClaimAmount(Math.floor(poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL * 100) / 100);\r\n    //     setRewardedTime(poolInfo.rewardTime.toNumber());\r\n    //   }\r\n    // }\r\n    setIsLoading(false);\r\n    return res;\r\n  };\r\n\r\n  const claimRewards = async () => {\r\n    if (!anchorWallet) {\r\n      toast.error(\"Connect wallet first, please.\");\r\n      return;\r\n    }\r\n\r\n    setIsLoading(true);\r\n    await claim(anchorWallet);\r\n    setIsLoading(false);\r\n  };\r\n\r\n  return {\r\n    isLoading,\r\n    stakedNfts,\r\n    stakedCount,\r\n    claimAmount,\r\n    totalStakedNFT,\r\n    stakeNftList,\r\n    stakeNft,\r\n    unStakeNft,\r\n    claimRewards,\r\n    getStakedNfts,\r\n    setStakedNfts,\r\n  };\r\n};\r\n\r\nasync function withFindOrInitAssociatedTokenAccount(\r\n  transaction: Transaction,\r\n  connection: Connection,\r\n  mint: PublicKey,\r\n  owner: PublicKey,\r\n  payer: PublicKey,\r\n  allowOwnerOffCurve: boolean\r\n) {\r\n  const associatedAddress = await splToken.Token.getAssociatedTokenAddress(\r\n    splToken.ASSOCIATED_TOKEN_PROGRAM_ID,\r\n    splToken.TOKEN_PROGRAM_ID,\r\n    mint,\r\n    owner,\r\n    allowOwnerOffCurve\r\n  );\r\n  const account = await connection.getAccountInfo(associatedAddress);\r\n  if (!account) {\r\n    transaction.add(\r\n      splToken.Token.createAssociatedTokenAccountInstruction(\r\n        splToken.ASSOCIATED_TOKEN_PROGRAM_ID,\r\n        splToken.TOKEN_PROGRAM_ID,\r\n        mint,\r\n        associatedAddress,\r\n        owner,\r\n        payer\r\n      )\r\n    );\r\n  }\r\n  return associatedAddress;\r\n}\r\n\r\nexport default useNftStake;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}