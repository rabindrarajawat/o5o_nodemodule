{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringTypeMap = exports.utf8String = exports.fixedSizeUtf8String = void 0;\n\nconst types_1 = require(\"../types\");\n\nconst assert_1 = require(\"assert\");\n\nconst numbers_1 = require(\"./numbers\");\n\nconst utils_1 = require(\"../utils\");\n/**\n * De/Serializes a UTF8 string of a particular size.\n *\n * @param stringByteLength the number of bytes of the string\n *\n * @category beet/collection\n */\n\n\nconst fixedSizeUtf8String = stringByteLength => {\n  return {\n    write: function (buf, offset, value) {\n      const stringBuf = Buffer.from(value, 'utf8');\n      assert_1.strict.equal(stringBuf.byteLength, stringByteLength, `${value} has invalid byte size`);\n      numbers_1.u32.write(buf, offset, stringByteLength);\n      stringBuf.copy(buf, offset + 4, 0, stringByteLength);\n    },\n    read: function (buf, offset) {\n      const size = numbers_1.u32.read(buf, offset);\n      assert_1.strict.equal(size, stringByteLength, `invalid byte size`);\n      const stringSlice = buf.slice(offset + 4, offset + 4 + stringByteLength);\n      return stringSlice.toString('utf8');\n    },\n    elementByteSize: 1,\n    length: stringByteLength,\n    lenPrefixByteSize: 4,\n    byteSize: 4 + stringByteLength,\n    description: `Utf8String(4 + ${stringByteLength})`\n  };\n};\n\nexports.fixedSizeUtf8String = fixedSizeUtf8String;\n/**\n * De/Serializes a UTF8 string of any size.\n *\n * @category beet/collection\n */\n\nexports.utf8String = {\n  toFixedFromData(buf, offset) {\n    const len = numbers_1.u32.read(buf, offset);\n    (0, utils_1.logTrace)(`${this.description}[${len}]`);\n    return (0, exports.fixedSizeUtf8String)(len);\n  },\n\n  toFixedFromValue(val) {\n    const len = Buffer.from(val).byteLength;\n    return (0, exports.fixedSizeUtf8String)(len);\n  },\n\n  description: `Utf8String`\n};\n/**\n * Maps string beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexports.stringTypeMap = {\n  fixedSizeString: {\n    beet: 'fixedSizeUtf8String',\n    isFixable: false,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: 'string',\n    arg: types_1.BEET_TYPE_ARG_LEN\n  },\n  string: {\n    beet: 'utf8String',\n    isFixable: true,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: 'string'\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/string.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAOA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AAEA;;;;;;AAMG;;;AACI,MAAM,mBAAmB,GAEM,gBAAD,IAA6B;EAChE,OAAO;IACL,KAAK,EAAE,UAAU,GAAV,EAAuB,MAAvB,EAAuC,KAAvC,EAAoD;MACzD,MAAM,SAAS,GAAG,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,MAAnB,CAAlB;MACA,QAAA,CAAA,MAAA,CAAO,KAAP,CACE,SAAS,CAAC,UADZ,EAEE,gBAFF,EAGE,GAAG,KAAK,wBAHV;MAKA,SAAA,CAAA,GAAA,CAAI,KAAJ,CAAU,GAAV,EAAe,MAAf,EAAuB,gBAAvB;MACA,SAAS,CAAC,IAAV,CAAe,GAAf,EAAoB,MAAM,GAAG,CAA7B,EAAgC,CAAhC,EAAmC,gBAAnC;IACD,CAVI;IAYL,IAAI,EAAE,UAAU,GAAV,EAAuB,MAAvB,EAAqC;MACzC,MAAM,IAAI,GAAG,SAAA,CAAA,GAAA,CAAI,IAAJ,CAAS,GAAT,EAAc,MAAd,CAAb;MACA,QAAA,CAAA,MAAA,CAAO,KAAP,CAAa,IAAb,EAAmB,gBAAnB,EAAqC,mBAArC;MACA,MAAM,WAAW,GAAG,GAAG,CAAC,KAAJ,CAAU,MAAM,GAAG,CAAnB,EAAsB,MAAM,GAAG,CAAT,GAAa,gBAAnC,CAApB;MACA,OAAO,WAAW,CAAC,QAAZ,CAAqB,MAArB,CAAP;IACD,CAjBI;IAkBL,eAAe,EAAE,CAlBZ;IAmBL,MAAM,EAAE,gBAnBH;IAoBL,iBAAiB,EAAE,CApBd;IAqBL,QAAQ,EAAE,IAAI,gBArBT;IAsBL,WAAW,EAAE,kBAAkB,gBAAgB;EAtB1C,CAAP;AAwBD,CA3BM;;AAAM,OAAA,CAAA,mBAAA,GAAmB,mBAAnB;AA6Bb;;;;AAIG;;AACU,OAAA,CAAA,UAAA,GAA0C;EACrD,eAAe,CAAC,GAAD,EAAc,MAAd,EAA4B;IACzC,MAAM,GAAG,GAAG,SAAA,CAAA,GAAA,CAAI,IAAJ,CAAS,GAAT,EAAc,MAAd,CAAZ;IACA,CAAA,GAAA,OAAA,CAAA,QAAA,EAAS,GAAG,KAAK,WAAW,IAAI,GAAG,GAAnC;IACA,OAAO,CAAA,GAAA,OAAA,CAAA,mBAAA,EAAoB,GAApB,CAAP;EACD,CALoD;;EAOrD,gBAAgB,CAAC,GAAD,EAAY;IAC1B,MAAM,GAAG,GAAG,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,UAA7B;IACA,OAAO,CAAA,GAAA,OAAA,CAAA,mBAAA,EAAoB,GAApB,CAAP;EACD,CAVoD;;EAYrD,WAAW,EAAE;AAZwC,CAA1C;AA+Bb;;;;;;AAMG;;AACU,OAAA,CAAA,aAAA,GAA+B;EAC1C,eAAe,EAAE;IACf,IAAI,EAAE,qBADS;IAEf,SAAS,EAAE,KAFI;IAGf,UAAU,EAAE,OAAA,CAAA,YAHG;IAIf,EAAE,EAAE,QAJW;IAKf,GAAG,EAAE,OAAA,CAAA;EALU,CADyB;EAQ1C,MAAM,EAAE;IACN,IAAI,EAAE,YADA;IAEN,SAAS,EAAE,IAFL;IAGN,UAAU,EAAE,OAAA,CAAA,YAHN;IAIN,EAAE,EAAE;EAJE;AARkC,CAA/B","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringTypeMap = exports.utf8String = exports.fixedSizeUtf8String = void 0;\nconst types_1 = require(\"../types\");\nconst assert_1 = require(\"assert\");\nconst numbers_1 = require(\"./numbers\");\nconst utils_1 = require(\"../utils\");\n/**\n * De/Serializes a UTF8 string of a particular size.\n *\n * @param stringByteLength the number of bytes of the string\n *\n * @category beet/collection\n */\nconst fixedSizeUtf8String = (stringByteLength) => {\n    return {\n        write: function (buf, offset, value) {\n            const stringBuf = Buffer.from(value, 'utf8');\n            assert_1.strict.equal(stringBuf.byteLength, stringByteLength, `${value} has invalid byte size`);\n            numbers_1.u32.write(buf, offset, stringByteLength);\n            stringBuf.copy(buf, offset + 4, 0, stringByteLength);\n        },\n        read: function (buf, offset) {\n            const size = numbers_1.u32.read(buf, offset);\n            assert_1.strict.equal(size, stringByteLength, `invalid byte size`);\n            const stringSlice = buf.slice(offset + 4, offset + 4 + stringByteLength);\n            return stringSlice.toString('utf8');\n        },\n        elementByteSize: 1,\n        length: stringByteLength,\n        lenPrefixByteSize: 4,\n        byteSize: 4 + stringByteLength,\n        description: `Utf8String(4 + ${stringByteLength})`,\n    };\n};\nexports.fixedSizeUtf8String = fixedSizeUtf8String;\n/**\n * De/Serializes a UTF8 string of any size.\n *\n * @category beet/collection\n */\nexports.utf8String = {\n    toFixedFromData(buf, offset) {\n        const len = numbers_1.u32.read(buf, offset);\n        (0, utils_1.logTrace)(`${this.description}[${len}]`);\n        return (0, exports.fixedSizeUtf8String)(len);\n    },\n    toFixedFromValue(val) {\n        const len = Buffer.from(val).byteLength;\n        return (0, exports.fixedSizeUtf8String)(len);\n    },\n    description: `Utf8String`,\n};\n/**\n * Maps string beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.stringTypeMap = {\n    fixedSizeString: {\n        beet: 'fixedSizeUtf8String',\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: 'string',\n        arg: types_1.BEET_TYPE_ARG_LEN,\n    },\n    string: {\n        beet: 'utf8String',\n        isFixable: true,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: 'string',\n    },\n};\n//# sourceMappingURL=string.js.map"]},"metadata":{},"sourceType":"script"}