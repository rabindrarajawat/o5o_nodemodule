{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { candyMachineBeet, CandyMachine } from '@metaplex-foundation/mpl-candy-machine-core';\nimport { CANDY_MACHINE_HIDDEN_SECTION } from '../constants.mjs';\nimport { deserializeCandyMachineHiddenSection } from './CandyMachineHiddenSection.mjs';\nimport assert from '../../../utils/assert.mjs';\nimport { isModel, assertModel } from '../../../types/Model.mjs';\nimport { createSerializerFromSolitaType, deserializeAccount } from '../../../types/Serializer.mjs';\nimport { toBigNumber } from '../../../types/BigNumber.mjs';\nimport { toAccountInfo } from '../../../types/Account.mjs';\nimport { removeEmptyChars } from '../../../utils/common.mjs';\nimport { deserializeFeatureFlags } from '../../../types/FeatureFlags.mjs';\n/**\n * This model contains all the relevant information about a Candy Machine.\n * This includes its settings but also all of the items (a.k.a. config lines)\n * loaded inside the Candy Machine along with some statistics about the items.\n *\n * @group Models\n */\n\n/** @group Model Helpers */\n\nconst isCandyMachine = value => isModel('candyMachine', value);\n/** @group Model Helpers */\n\n\nfunction assertCandyMachine(value) {\n  assertModel(isCandyMachine(value), `Expected CandyMachine model`);\n}\n/** @group Model Helpers */\n\n\nconst toCandyMachine = function (account) {\n  let candyGuard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const serializer = createSerializerFromSolitaType(CandyMachine, candyMachineBeet.description);\n  const parsedAccount = deserializeAccount(account, serializer);\n  const itemsAvailable = toBigNumber(parsedAccount.data.data.itemsAvailable);\n  const itemsMinted = toBigNumber(parsedAccount.data.itemsRedeemed);\n  const itemsRemaining = toBigNumber(itemsAvailable.sub(itemsMinted));\n  let items = [];\n  let itemsLoaded = 0;\n  let isFullyLoaded = true;\n  const {\n    hiddenSettings\n  } = parsedAccount.data.data;\n  const {\n    configLineSettings\n  } = parsedAccount.data.data;\n  let itemSettings;\n\n  if (hiddenSettings) {\n    itemSettings = { ...hiddenSettings,\n      type: 'hidden'\n    };\n  } else {\n    assert(!!configLineSettings, 'Expected either hidden or config line settings');\n    itemSettings = { ...configLineSettings,\n      type: 'configLines'\n    };\n    const hiddenSection = deserializeCandyMachineHiddenSection(account.data, itemsAvailable.toNumber(), itemsRemaining.toNumber(), itemSettings, CANDY_MACHINE_HIDDEN_SECTION);\n    items = hiddenSection.items;\n    itemsLoaded = hiddenSection.itemsLoaded;\n    isFullyLoaded = hiddenSection.itemsLoaded >= itemsAvailable.toNumber();\n  }\n\n  return {\n    model: 'candyMachine',\n    address: account.publicKey,\n    accountInfo: toAccountInfo(account),\n    authorityAddress: parsedAccount.data.authority,\n    mintAuthorityAddress: parsedAccount.data.mintAuthority,\n    collectionMintAddress: parsedAccount.data.collectionMint,\n    symbol: removeEmptyChars(parsedAccount.data.data.symbol),\n    sellerFeeBasisPoints: parsedAccount.data.data.sellerFeeBasisPoints,\n    isMutable: parsedAccount.data.data.isMutable,\n    maxEditionSupply: toBigNumber(parsedAccount.data.data.maxSupply),\n    creators: parsedAccount.data.data.creators.map(creator => ({ ...creator,\n      share: creator.percentageShare\n    })),\n    items,\n    itemsAvailable,\n    itemsMinted,\n    itemsRemaining,\n    itemsLoaded,\n    isFullyLoaded,\n    itemSettings,\n    featureFlags: deserializeFeatureFlags(toBigNumber(parsedAccount.data.features).toArrayLike(Buffer, 'le', 8).reverse(), 64),\n    candyGuard\n  };\n};\n\nconst toCandyMachineData = candyMachine => {\n  return {\n    itemsAvailable: candyMachine.itemsAvailable,\n    symbol: candyMachine.symbol,\n    sellerFeeBasisPoints: candyMachine.sellerFeeBasisPoints,\n    maxSupply: candyMachine.maxEditionSupply,\n    isMutable: candyMachine.isMutable,\n    creators: candyMachine.creators.map(creator => ({ ...creator,\n      verified: false,\n      percentageShare: creator.share\n    })),\n    configLineSettings: candyMachine.itemSettings.type === 'configLines' ? candyMachine.itemSettings : null,\n    hiddenSettings: candyMachine.itemSettings.type === 'hidden' ? candyMachine.itemSettings : null\n  };\n};\n\nconst getCandyMachineSize = data => {\n  if (data.hiddenSettings) {\n    return CANDY_MACHINE_HIDDEN_SECTION;\n  } // This should not happen as the candy machine input type\n  // ensures exactly on of them is provided.\n\n\n  assert(!!data.configLineSettings, 'No config line settings nor hidden settings were provided. ' + 'Please provide one of them.');\n  const itemsAvailable = toBigNumber(data.itemsAvailable).toNumber();\n  const configLineSize = data.configLineSettings.nameLength + data.configLineSettings.uriLength;\n  return Math.ceil(CANDY_MACHINE_HIDDEN_SECTION + // Number of currently items inserted.\n  4 + // Config line data.\n  itemsAvailable * configLineSize + ( // Bit mask to keep track of which ConfigLines have been added.\n  4 + Math.floor(itemsAvailable / 8) + 1) + ( // Mint indices.\n  4 + itemsAvailable * 4));\n};\n\nexport { assertCandyMachine, getCandyMachineSize, isCandyMachine, toCandyMachine, toCandyMachineData };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineModule/models/CandyMachine.ts"],"names":["isCandyMachine","value","isModel","assertCandyMachine","assertModel","toCandyMachine","account","candyGuard","serializer","createSerializerFromSolitaType","MplCandyMachine","candyMachineBeet","description","parsedAccount","deserializeAccount","itemsAvailable","toBigNumber","data","itemsMinted","itemsRedeemed","itemsRemaining","sub","items","itemsLoaded","isFullyLoaded","hiddenSettings","configLineSettings","itemSettings","type","assert","hiddenSection","deserializeCandyMachineHiddenSection","toNumber","CANDY_MACHINE_HIDDEN_SECTION","model","address","publicKey","accountInfo","toAccountInfo","authorityAddress","authority","mintAuthorityAddress","mintAuthority","collectionMintAddress","collectionMint","symbol","removeEmptyChars","sellerFeeBasisPoints","isMutable","maxEditionSupply","maxSupply","creators","map","creator","share","percentageShare","featureFlags","deserializeFeatureFlags","features","toArrayLike","Buffer","reverse","toCandyMachineData","candyMachine","verified","getCandyMachineSize","configLineSize","nameLength","uriLength","Math","ceil","floor"],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\nimport {\n  CandyMachine as MplCandyMachine,\n  candyMachineBeet,\n  CandyMachineData,\n} from '@metaplex-foundation/mpl-candy-machine-core';\nimport { CANDY_MACHINE_HIDDEN_SECTION } from '../constants';\nimport { CandyGuardsSettings, DefaultCandyGuardSettings } from '../guards';\nimport { deserializeCandyMachineHiddenSection } from './CandyMachineHiddenSection';\nimport { CandyMachineItem } from './CandyMachineItem';\nimport { CandyGuard } from './CandyGuard';\nimport {\n  AccountInfo,\n  assertModel,\n  BigNumber,\n  createSerializerFromSolitaType,\n  Creator,\n  deserializeAccount,\n  deserializeFeatureFlags,\n  FeatureFlags,\n  isModel,\n  Model,\n  PublicKey,\n  toAccountInfo,\n  toBigNumber,\n  UnparsedAccount,\n} from '@/types';\nimport { assert, Option, removeEmptyChars } from '@/utils';\n\n/**\n * This model contains all the relevant information about a Candy Machine.\n * This includes its settings but also all of the items (a.k.a. config lines)\n * loaded inside the Candy Machine along with some statistics about the items.\n *\n * @group Models\n */\nexport type CandyMachine<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n> = Model<'candyMachine'> & {\n  /** The address of the Candy Machine account. */\n  readonly address: PublicKey;\n\n  /** Blockchain data of the Candy Machine account. */\n  readonly accountInfo: AccountInfo;\n\n  /**\n   * Refers to the authority that is allowed to manage the Candy Machine.\n   * This includes updating its data, authorities, inserting items, etc.\n   */\n  readonly authorityAddress: PublicKey;\n\n  /**\n   * Refers to the only authority that is allowed to mint from\n   * this Candy Machine. This will refer to the address of the Candy\n   * Guard associated with the Candy Machine if any.\n   */\n  readonly mintAuthorityAddress: PublicKey;\n\n  /**\n   * The mint address of the collection NFT that should be associated with\n   * minted NFTs. When `null`, it means NFTs will not be part of a\n   * collection when minted.\n   */\n  readonly collectionMintAddress: PublicKey;\n\n  /**\n   * The symbol to use when minting NFTs (e.g. \"MYPROJECT\")\n   *\n   * This can be any string up to 10 bytes and can be made optional\n   * by providing an empty string.\n   */\n  readonly symbol: string;\n\n  /**\n   * The royalties that should be set on minted NFTs in basis points\n   * (i.e. 250 is 2.5%).\n   */\n  readonly sellerFeeBasisPoints: number;\n\n  /**\n   * Whether the minted NFTs should be mutable or not.\n   *\n   * We recommend setting this to `true` unless you have a specific reason.\n   * You can always make NFTs immutable in the future but you cannot make\n   * immutable NFTs mutable ever again.\n   */\n  readonly isMutable: boolean;\n\n  /**\n   * The maximum number of editions that can be printed from the\n   * minted NFTs.\n   *\n   * For most use cases, you'd want to set this to `0` to prevent\n   * minted NFTs to be printed multiple times.\n   *\n   * Note that you cannot set this to `null` which means unlimited editions\n   * are not supported by the Candy Machine program.\n   */\n  readonly maxEditionSupply: BigNumber;\n\n  /**\n   * Array of creators that should be set on minted NFTs.\n   * creators can only verify NFTs after they have been minted.\n   * Thus, all the provided creators will have `verified` set to `false`.\n   *\n   * @see {@link Creator}\n   */\n  readonly creators: Omit<Creator, 'verified'>[];\n\n  /**\n   * The parsed items that are loaded in the Candy Machine.\n   *\n   * If the Candy Machine is using hidden settings,\n   * this will be an empty array.\n   */\n  readonly items: CandyMachineItem[];\n\n  /**\n   * The total number of items availble in the Candy Machine, minted or not.\n   */\n  readonly itemsAvailable: BigNumber;\n\n  /**\n   * The number of items that have been minted on this Candy Machine so far.\n   */\n  readonly itemsMinted: BigNumber;\n\n  /**\n   * The number of remaining items in the Candy Machine that can still be minted.\n   */\n  readonly itemsRemaining: BigNumber;\n\n  /**\n   * The number of items that have been inserted in the Candy Machine by\n   * its update authority. If this number if lower than the number of items\n   * available, the Candy Machine is not ready and cannot be minted from.\n   *\n   * This field is irrelevant if the Candy Machine is using hidden settings.\n   */\n  readonly itemsLoaded: number;\n\n  /**\n   * Whether all items in the Candy Machine have been inserted by\n   * its authority.\n   *\n   * This field is irrelevant if the Candy Machine is using hidden settings.\n   */\n  readonly isFullyLoaded: boolean;\n\n  /**\n   * Settings related to the Candy Machine's items.\n   *\n   * These can either be inserted manually within the Candy Machine or\n   * they can be infered from a set of hidden settings.\n   *\n   * - If `type` is `hidden`, the Candy Machine is using hidden settings.\n   * - If `type` is `configLines`, the Candy Machine is using config line settings.\n   *\n   * @see {@link CandyMachineHiddenSettings}\n   * @see {@link CandyMachineConfigLineSettings}\n   */\n  readonly itemSettings:\n    | CandyMachineHiddenSettings\n    | CandyMachineConfigLineSettings;\n\n  /**\n   * This array of booleans is used to keep track of which\n   * new features have been enabled on the Candy Machine.\n   */\n  readonly featureFlags: FeatureFlags;\n\n  /**\n   * The Candy Guard associted with the Candy Machine if any.\n   */\n  readonly candyGuard: Option<CandyGuard<T>>;\n};\n\n/**\n * Settings that makes items in the Candy Machine hidden by\n * providing a single URI for all minted NFTs and the hash of a file that\n * maps mint number to actual NFT URIs.\n *\n * Hidden settings serve two purposes.\n * - First, it allows the creation of larger drops (20k+), since\n *   the JSON metadata URIs are not stored on-chain for each item.\n * - In turn, this also allows the creation of hide-and-reveal drops,\n *   where users discover which items they minted after the mint is complete.\n *\n * Once hidden settings are enabled, every minted NFT will have the same URI and the\n * name will be created by appending the mint number (e.g., “#45”) to the specified\n * name. The hash is expected to be a 32 character string corresponding to\n * the hash of a cache file that has the mapping between a mint number and the\n * actual metadata URI. This allows the order of the mint to be verified by\n * others after the mint is complete.\n *\n * Since the metadata URIs are not on-chain, it is possible to create very large\n * drops. The only caveat is that there is a need for an off-chain process to\n * update the metadata for each item. This is important otherwise all items\n * will have the same metadata.\n *\n * @group Models\n */\nexport type CandyMachineHiddenSettings = {\n  /** Identifier used to distinguish the various types of item settings. */\n  readonly type: 'hidden';\n\n  /**\n   * The base name for all minted NFTs.\n   *\n   * You can use the following variables in the name:\n   * - `$ID$`: The index of the item (starting at 0).\n   * - `$ID+1$`: The number of the item (starting at 1).\n   */\n  readonly name: string;\n\n  /**\n   * The URI shared by all minted NFTs.\n   *\n   * You can use the following variables in the URI:\n   * - `$ID$`: The index of the item (starting at 0).\n   * - `$ID+1$`: The number of the item (starting at 1).\n   */\n  readonly uri: string;\n\n  /**\n   * A 32-character hash. In most cases this is the hash of the\n   * cache file with the mapping between mint numbers and metadata URIs\n   * so that the order can be verified when the mint is complete.\n   */\n  readonly hash: number[];\n};\n\n/**\n * A set of settings that aim to reduce the size of the Candy Machine\n * whilst allowing items to be manually inserted for more flexibility.\n *\n * This introduces `name` and `uri` prefixes that will be used for each\n * item inserted.\n *\n * @example\n * For instance, say all inserted items will have the following structure,\n * where zeros represent the dynamic part of the name and URI:\n * - name: \"My NFT Project #0000\"\n * - uri: \"https://arweave.net/00000000000000000000\"\n *\n * Then we can use the following prefixes:\n * - prefixName: \"My NFT Project #\"\n * - prefixUri: \"https://arweave.net/\"\n *\n * And the following lengths:\n * - nameLength: 4 (assuming we'll never have more than 9999 items)\n * - uriLength: 20\n *\n * We could even go one step further and set the `nameLength` to zero by\n * relying on template variables in the name prefix:\n * - prefixName: \"My NFT Project #$ID+1$\"\n * - nameLength: 0\n *\n * Now, the program will automatically append the item number to the\n * name of each minted NFT.\n *\n * @group Models\n */\nexport type CandyMachineConfigLineSettings = {\n  /** Identifier used to distinguish the various types of item settings. */\n  readonly type: 'configLines';\n\n  /**\n   * The prefix of the name of each item.\n   *\n   * The following template variables can be used:\n   * - `$ID$`: The index of the item (starting at 0).\n   * - `$ID+1$`: The number of the item (starting at 1).\n   */\n  readonly prefixName: string;\n\n  /**\n   * The maximum length to use for the name of inserted items\n   * excluding the length of the prefix.\n   *\n   * For instance, if the name prefix is \"My NFT Project #\" and we want to\n   * add item numbers up to 9999, we would set this value to 4.\n   */\n  readonly nameLength: number;\n\n  /**\n   * The prefix of the URI of each item.\n   *\n   * The following template variables can be used:\n   * - `$ID$`: The index of the item (starting at 0).\n   * - `$ID+1$`: The number of the item (starting at 1).\n   */\n  readonly prefixUri: string;\n\n  /**\n   * The maximum length to use for the URI of inserted items\n   * excluding the length of the prefix.\n   *\n   * For instance, if the URI prefix is \"https://arweave.net/\" and we assume\n   * Arweave identifiers are 20 characters long max, we would set this value to 20.\n   */\n  readonly uriLength: number;\n\n  /**\n   * Indicates whether to use a sequential index generator or not.\n   * When set to `true`, NFTs will be minted sequentially.\n   * When set to `false`, NFTs will be minted in a random order.\n   */\n  readonly isSequential: boolean;\n};\n\n/** @group Model Helpers */\nexport const isCandyMachine = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  value: any\n): value is CandyMachine<T> => isModel('candyMachine', value);\n\n/** @group Model Helpers */\nexport function assertCandyMachine<\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(value: any): asserts value is CandyMachine<T> {\n  assertModel(isCandyMachine(value), `Expected CandyMachine model`);\n}\n\n/** @group Model Helpers */\nexport const toCandyMachine = <\n  T extends CandyGuardsSettings = DefaultCandyGuardSettings\n>(\n  account: UnparsedAccount,\n  candyGuard: Option<CandyGuard<T>> = null\n): CandyMachine<T> => {\n  const serializer = createSerializerFromSolitaType(\n    MplCandyMachine,\n    candyMachineBeet.description\n  );\n  const parsedAccount = deserializeAccount(account, serializer);\n\n  const itemsAvailable = toBigNumber(parsedAccount.data.data.itemsAvailable);\n  const itemsMinted = toBigNumber(parsedAccount.data.itemsRedeemed);\n  const itemsRemaining = toBigNumber(itemsAvailable.sub(itemsMinted));\n\n  let items: CandyMachineItem[] = [];\n  let itemsLoaded = 0;\n  let isFullyLoaded = true;\n\n  const { hiddenSettings } = parsedAccount.data.data;\n  const { configLineSettings } = parsedAccount.data.data;\n  let itemSettings: CandyMachineHiddenSettings | CandyMachineConfigLineSettings;\n  if (hiddenSettings) {\n    itemSettings = { ...hiddenSettings, type: 'hidden' };\n  } else {\n    assert(\n      !!configLineSettings,\n      'Expected either hidden or config line settings'\n    );\n    itemSettings = { ...configLineSettings, type: 'configLines' };\n    const hiddenSection = deserializeCandyMachineHiddenSection(\n      account.data,\n      itemsAvailable.toNumber(),\n      itemsRemaining.toNumber(),\n      itemSettings,\n      CANDY_MACHINE_HIDDEN_SECTION\n    );\n\n    items = hiddenSection.items;\n    itemsLoaded = hiddenSection.itemsLoaded;\n    isFullyLoaded = hiddenSection.itemsLoaded >= itemsAvailable.toNumber();\n  }\n\n  return {\n    model: 'candyMachine',\n    address: account.publicKey,\n    accountInfo: toAccountInfo(account),\n    authorityAddress: parsedAccount.data.authority,\n    mintAuthorityAddress: parsedAccount.data.mintAuthority,\n    collectionMintAddress: parsedAccount.data.collectionMint,\n    symbol: removeEmptyChars(parsedAccount.data.data.symbol),\n    sellerFeeBasisPoints: parsedAccount.data.data.sellerFeeBasisPoints,\n    isMutable: parsedAccount.data.data.isMutable,\n    maxEditionSupply: toBigNumber(parsedAccount.data.data.maxSupply),\n    creators: parsedAccount.data.data.creators.map(\n      (creator): Creator => ({ ...creator, share: creator.percentageShare })\n    ),\n    items,\n    itemsAvailable,\n    itemsMinted,\n    itemsRemaining,\n    itemsLoaded,\n    isFullyLoaded,\n    itemSettings,\n    featureFlags: deserializeFeatureFlags(\n      toBigNumber(parsedAccount.data.features)\n        .toArrayLike(Buffer, 'le', 8)\n        .reverse(),\n      64\n    ),\n    candyGuard,\n  };\n};\n\nexport const toCandyMachineData = (\n  candyMachine: Pick<\n    CandyMachine,\n    | 'itemsAvailable'\n    | 'symbol'\n    | 'sellerFeeBasisPoints'\n    | 'maxEditionSupply'\n    | 'isMutable'\n    | 'creators'\n    | 'itemSettings'\n  >\n): CandyMachineData => {\n  return {\n    itemsAvailable: candyMachine.itemsAvailable,\n    symbol: candyMachine.symbol,\n    sellerFeeBasisPoints: candyMachine.sellerFeeBasisPoints,\n    maxSupply: candyMachine.maxEditionSupply,\n    isMutable: candyMachine.isMutable,\n    creators: candyMachine.creators.map((creator) => ({\n      ...creator,\n      verified: false,\n      percentageShare: creator.share,\n    })),\n    configLineSettings:\n      candyMachine.itemSettings.type === 'configLines'\n        ? candyMachine.itemSettings\n        : null,\n    hiddenSettings:\n      candyMachine.itemSettings.type === 'hidden'\n        ? candyMachine.itemSettings\n        : null,\n  };\n};\n\nexport const getCandyMachineSize = (data: CandyMachineData): number => {\n  if (data.hiddenSettings) {\n    return CANDY_MACHINE_HIDDEN_SECTION;\n  }\n\n  // This should not happen as the candy machine input type\n  // ensures exactly on of them is provided.\n  assert(\n    !!data.configLineSettings,\n    'No config line settings nor hidden settings were provided. ' +\n      'Please provide one of them.'\n  );\n\n  const itemsAvailable = toBigNumber(data.itemsAvailable).toNumber();\n  const configLineSize =\n    data.configLineSettings.nameLength + data.configLineSettings.uriLength;\n\n  return Math.ceil(\n    CANDY_MACHINE_HIDDEN_SECTION +\n      // Number of currently items inserted.\n      4 +\n      // Config line data.\n      itemsAvailable * configLineSize +\n      // Bit mask to keep track of which ConfigLines have been added.\n      (4 + Math.floor(itemsAvailable / 8) + 1) +\n      // Mint indices.\n      (4 + itemsAvailable * 4)\n  );\n};\n"]},"metadata":{},"sourceType":"module"}