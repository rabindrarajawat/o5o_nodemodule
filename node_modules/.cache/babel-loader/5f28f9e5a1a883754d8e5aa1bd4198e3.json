{"ast":null,"code":"import { strict as assert } from 'assert';\nimport { assertFixedSizeBeet, BEET_TYPE_ARG_INNER } from '../types';\nimport { BEET_PACKAGE } from '../types';\nimport { logTrace } from '../utils';\nimport { fixBeetFromData, fixBeetFromValue } from '../beet.fixable';\nconst NONE = 0;\nconst SOME = 1;\n/**\n * @private\n */\n\nexport function isSomeBuffer(buf, offset) {\n  return buf[offset] === SOME;\n}\n/**\n * @private\n */\n\nexport function isNoneBuffer(buf, offset) {\n  return buf[offset] === NONE;\n}\n/**\n * De/Serializes `None` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `0`.\n * This matches the `COption::None` type borsh representation.\n *\n * @template T inner option type\n * @param description the description of the inner type\n *\n * @category beet/option\n */\n\nexport function coptionNone(description) {\n  logTrace(`coptionNone(${description})`);\n  return {\n    write: function (buf, offset, value) {\n      assert(value == null, 'coptionNone can only handle `null` values');\n      buf[offset] = NONE;\n    },\n    read: function (buf, offset) {\n      assert(isNoneBuffer(buf, offset), 'coptionNone can only handle `NONE` data');\n      return null;\n    },\n    byteSize: 1,\n    description: `COption<None(${description})>`\n  };\n}\n/**\n * De/Serializes `Some` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `1`.\n * This matches the `COption::Some` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\n\nexport function coptionSome(inner) {\n  const byteSize = 1 + inner.byteSize;\n  const beet = {\n    write: function (buf, offset, value) {\n      assertFixedSizeBeet(inner, `coption inner type ${inner.description} needs to be fixed before calling write`);\n      assert(value != null, 'coptionSome cannot handle `null` values');\n      buf[offset] = SOME;\n      inner.write(buf, offset + 1, value);\n    },\n    read: function (buf, offset) {\n      assertFixedSizeBeet(inner, `coption inner type ${inner.description} needs to be fixed before calling read`);\n      assert(isSomeBuffer(buf, offset), 'coptionSome can only handle `SOME` data');\n      return inner.read(buf, offset + 1);\n    },\n    description: `COption<${inner.description}>[1 + ${inner.byteSize}]`,\n    byteSize,\n    inner\n  };\n  logTrace(beet.description);\n  return beet;\n}\n/**\n * De/Serializes an _Option_ of type {@link T} represented by {@link COption}.\n *\n * The de/serialized type is prefixed with `1` if the inner value is present\n * and with `0` if not.\n * This matches the `COption` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\n\nexport function coption(inner) {\n  return {\n    toFixedFromData(buf, offset) {\n      if (isSomeBuffer(buf, offset)) {\n        const innerFixed = fixBeetFromData(inner, buf, offset + 1);\n        return coptionSome(innerFixed);\n      } else {\n        assert(isNoneBuffer(buf, offset), `Expected ${buf} to hold a COption`);\n        return coptionNone(inner.description);\n      }\n    },\n\n    toFixedFromValue(val) {\n      return val == null ? coptionNone(inner.description) : coptionSome(fixBeetFromValue(inner, val));\n    },\n\n    description: `COption<${inner.description}>`\n  };\n}\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexport const compositesTypeMap = {\n  option: {\n    beet: 'coption',\n    isFixable: true,\n    sourcePack: BEET_PACKAGE,\n    ts: 'COption<Inner>',\n    arg: BEET_TYPE_ARG_INNER,\n    pack: BEET_PACKAGE\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/composites.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { strict as assert } from 'assert';\nimport { assertFixedSizeBeet, BEET_TYPE_ARG_INNER, } from '../types';\nimport { BEET_PACKAGE } from '../types';\nimport { logTrace } from '../utils';\nimport { fixBeetFromData, fixBeetFromValue } from '../beet.fixable';\nconst NONE = 0;\nconst SOME = 1;\n/**\n * @private\n */\nexport function isSomeBuffer(buf, offset) {\n    return buf[offset] === SOME;\n}\n/**\n * @private\n */\nexport function isNoneBuffer(buf, offset) {\n    return buf[offset] === NONE;\n}\n/**\n * De/Serializes `None` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `0`.\n * This matches the `COption::None` type borsh representation.\n *\n * @template T inner option type\n * @param description the description of the inner type\n *\n * @category beet/option\n */\nexport function coptionNone(description) {\n    logTrace(`coptionNone(${description})`);\n    return {\n        write: function (buf, offset, value) {\n            assert(value == null, 'coptionNone can only handle `null` values');\n            buf[offset] = NONE;\n        },\n        read: function (buf, offset) {\n            assert(isNoneBuffer(buf, offset), 'coptionNone can only handle `NONE` data');\n            return null;\n        },\n        byteSize: 1,\n        description: `COption<None(${description})>`,\n    };\n}\n/**\n * De/Serializes `Some` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `1`.\n * This matches the `COption::Some` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\nexport function coptionSome(inner) {\n    const byteSize = 1 + inner.byteSize;\n    const beet = {\n        write: function (buf, offset, value) {\n            assertFixedSizeBeet(inner, `coption inner type ${inner.description} needs to be fixed before calling write`);\n            assert(value != null, 'coptionSome cannot handle `null` values');\n            buf[offset] = SOME;\n            inner.write(buf, offset + 1, value);\n        },\n        read: function (buf, offset) {\n            assertFixedSizeBeet(inner, `coption inner type ${inner.description} needs to be fixed before calling read`);\n            assert(isSomeBuffer(buf, offset), 'coptionSome can only handle `SOME` data');\n            return inner.read(buf, offset + 1);\n        },\n        description: `COption<${inner.description}>[1 + ${inner.byteSize}]`,\n        byteSize,\n        inner,\n    };\n    logTrace(beet.description);\n    return beet;\n}\n/**\n * De/Serializes an _Option_ of type {@link T} represented by {@link COption}.\n *\n * The de/serialized type is prefixed with `1` if the inner value is present\n * and with `0` if not.\n * This matches the `COption` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\nexport function coption(inner) {\n    return {\n        toFixedFromData(buf, offset) {\n            if (isSomeBuffer(buf, offset)) {\n                const innerFixed = fixBeetFromData(inner, buf, offset + 1);\n                return coptionSome(innerFixed);\n            }\n            else {\n                assert(isNoneBuffer(buf, offset), `Expected ${buf} to hold a COption`);\n                return coptionNone(inner.description);\n            }\n        },\n        toFixedFromValue(val) {\n            return val == null\n                ? coptionNone(inner.description)\n                : coptionSome(fixBeetFromValue(inner, val));\n        },\n        description: `COption<${inner.description}>`,\n    };\n}\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexport const compositesTypeMap = {\n    option: {\n        beet: 'coption',\n        isFixable: true,\n        sourcePack: BEET_PACKAGE,\n        ts: 'COption<Inner>',\n        arg: BEET_TYPE_ARG_INNER,\n        pack: BEET_PACKAGE,\n    },\n};\n//# sourceMappingURL=composites.js.map"]},"metadata":{},"sourceType":"module"}