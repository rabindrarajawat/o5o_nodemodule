{"ast":null,"code":"import * as beet from '@metaplex-foundation/beet';\nimport { deserializeFeatureFlags } from '../../../types/FeatureFlags.mjs';\nimport { removeEmptyChars } from '../../../utils/common.mjs';\n/** @internal */\n\n/** @internal */\n\nconst deserializeCandyMachineHiddenSection = function (buffer, itemsAvailable, itemsRemaining, configLineSettings) {\n  let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  // Items loaded.\n  const itemsLoaded = beet.u32.read(buffer, offset);\n  offset += 4; // Raw config lines.\n\n  const {\n    nameLength\n  } = configLineSettings;\n  const {\n    uriLength\n  } = configLineSettings;\n  const configLineSize = nameLength + uriLength;\n  const configLinesSize = configLineSize * itemsAvailable;\n  const rawConfigLines = buffer.slice(offset, offset + configLinesSize);\n  offset += configLinesSize; // Items loaded map.\n\n  const itemsLoadedBuffer = buffer.slice(offset, offset + itemsAvailable);\n  const itemsLoadedMap = deserializeFeatureFlags(itemsLoadedBuffer, itemsAvailable);\n  const itemsLoadedMapSize = Math.floor(itemsAvailable / 8) + 1;\n  offset += itemsLoadedMapSize; // Items left to mint for random order only.\n\n  const itemsLeftToMint = beet.uniformFixedSizeArray(beet.u32, itemsAvailable).read(buffer, offset).slice(0, itemsRemaining); // Helper function to figure out if an item has been minted.\n\n  const itemsMinted = itemsAvailable - itemsRemaining;\n\n  const isMinted = index => configLineSettings.isSequential ? index < itemsMinted : !itemsLeftToMint.includes(index); // Parse config lines.\n\n\n  const items = [];\n  itemsLoadedMap.forEach((loaded, index) => {\n    if (!loaded) return;\n    const namePosition = index * configLineSize;\n    const uriPosition = namePosition + nameLength;\n    const name = rawConfigLines.slice(namePosition, namePosition + nameLength).toString('utf8');\n    const uri = rawConfigLines.slice(uriPosition, uriPosition + uriLength).toString('utf8');\n    const prefixName = replaceCandyMachineItemPattern(configLineSettings.prefixName, index);\n    const prefixUri = replaceCandyMachineItemPattern(configLineSettings.prefixUri, index);\n    items.push({\n      index,\n      minted: isMinted(index),\n      name: prefixName + removeEmptyChars(name),\n      uri: prefixUri + removeEmptyChars(uri)\n    });\n  });\n  return {\n    itemsLoaded,\n    items,\n    itemsLoadedMap,\n    itemsLeftToMint\n  };\n};\n/** @internal */\n\n\nconst replaceCandyMachineItemPattern = (value, index) => {\n  return value.replace('$ID+1$', `${index + 1}`).replace('$ID$', `${index}`);\n};\n\nexport { deserializeCandyMachineHiddenSection, replaceCandyMachineItemPattern };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineModule/models/CandyMachineHiddenSection.ts"],"names":["deserializeCandyMachineHiddenSection","buffer","itemsAvailable","itemsRemaining","configLineSettings","offset","itemsLoaded","beet","u32","read","nameLength","uriLength","configLineSize","configLinesSize","rawConfigLines","slice","itemsLoadedBuffer","itemsLoadedMap","deserializeFeatureFlags","itemsLoadedMapSize","Math","floor","itemsLeftToMint","uniformFixedSizeArray","itemsMinted","isMinted","index","isSequential","includes","items","forEach","loaded","namePosition","uriPosition","name","toString","uri","prefixName","replaceCandyMachineItemPattern","prefixUri","push","minted","removeEmptyChars","value","replace"],"mappings":"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","sourcesContent":["import * as beet from '@metaplex-foundation/beet';\nimport { CandyMachineConfigLineSettings, CandyMachineItem } from '..';\nimport { deserializeFeatureFlags } from '@/types';\nimport { removeEmptyChars } from '@/utils';\n\n/** @internal */\nexport type CandyMachineHiddenSection = {\n  itemsLoaded: number;\n  items: CandyMachineItem[];\n  itemsLoadedMap: boolean[];\n  itemsLeftToMint: number[];\n};\n\n/** @internal */\nexport const deserializeCandyMachineHiddenSection = (\n  buffer: Buffer,\n  itemsAvailable: number,\n  itemsRemaining: number,\n  configLineSettings: CandyMachineConfigLineSettings,\n  offset = 0\n): CandyMachineHiddenSection => {\n  // Items loaded.\n  const itemsLoaded = beet.u32.read(buffer, offset);\n  offset += 4;\n\n  // Raw config lines.\n  const { nameLength } = configLineSettings;\n  const { uriLength } = configLineSettings;\n  const configLineSize = nameLength + uriLength;\n  const configLinesSize = configLineSize * itemsAvailable;\n  const rawConfigLines = buffer.slice(offset, offset + configLinesSize);\n  offset += configLinesSize;\n\n  // Items loaded map.\n  const itemsLoadedBuffer = buffer.slice(offset, offset + itemsAvailable);\n  const itemsLoadedMap = deserializeFeatureFlags(\n    itemsLoadedBuffer,\n    itemsAvailable\n  );\n  const itemsLoadedMapSize = Math.floor(itemsAvailable / 8) + 1;\n  offset += itemsLoadedMapSize;\n\n  // Items left to mint for random order only.\n  const itemsLeftToMint = beet\n    .uniformFixedSizeArray(beet.u32, itemsAvailable)\n    .read(buffer, offset)\n    .slice(0, itemsRemaining);\n\n  // Helper function to figure out if an item has been minted.\n  const itemsMinted = itemsAvailable - itemsRemaining;\n  const isMinted = (index: number): boolean =>\n    configLineSettings.isSequential\n      ? index < itemsMinted\n      : !itemsLeftToMint.includes(index);\n\n  // Parse config lines.\n  const items: CandyMachineItem[] = [];\n  itemsLoadedMap.forEach((loaded, index) => {\n    if (!loaded) return;\n\n    const namePosition = index * configLineSize;\n    const uriPosition = namePosition + nameLength;\n    const name = rawConfigLines\n      .slice(namePosition, namePosition + nameLength)\n      .toString('utf8');\n    const uri = rawConfigLines\n      .slice(uriPosition, uriPosition + uriLength)\n      .toString('utf8');\n\n    const prefixName = replaceCandyMachineItemPattern(\n      configLineSettings.prefixName,\n      index\n    );\n    const prefixUri = replaceCandyMachineItemPattern(\n      configLineSettings.prefixUri,\n      index\n    );\n\n    items.push({\n      index,\n      minted: isMinted(index),\n      name: prefixName + removeEmptyChars(name),\n      uri: prefixUri + removeEmptyChars(uri),\n    });\n  });\n\n  return {\n    itemsLoaded,\n    items,\n    itemsLoadedMap,\n    itemsLeftToMint,\n  };\n};\n\n/** @internal */\nexport const replaceCandyMachineItemPattern = (\n  value: string,\n  index: number\n): string => {\n  return value.replace('$ID+1$', `${index + 1}`).replace('$ID$', `${index}`);\n};\n"]},"metadata":{},"sourceType":"module"}