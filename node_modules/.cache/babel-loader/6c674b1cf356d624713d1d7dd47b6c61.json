{"ast":null,"code":"import { associatedTokenProgram } from '../program.mjs';\nimport assert from '../../../utils/assert.mjs';\nimport { Pda } from '../../../types/Pda.mjs';\nimport { token, amount } from '../../../types/Amount.mjs';\n/**\n * This model represents a token account.\n *\n * @group Models\n */\n\n/** @group Model Helpers */\n\nconst isToken = value => typeof value === 'object' && value.model === 'token';\n/** @group Model Helpers */\n\n\nfunction assertToken(value) {\n  assert(isToken(value), `Expected Token model`);\n}\n/** @group Model Helpers */\n\n\nconst toToken = account => {\n  const associatedTokenAddress = Pda.find(associatedTokenProgram.address, [account.data.owner.toBuffer(), account.owner.toBuffer(), account.data.mint.toBuffer()]);\n  const isAssociatedToken = associatedTokenAddress.equals(account.publicKey);\n  return {\n    model: 'token',\n    address: isAssociatedToken ? associatedTokenAddress : account.publicKey,\n    isAssociatedToken,\n    mintAddress: account.data.mint,\n    ownerAddress: account.data.owner,\n    amount: token(account.data.amount.toString()),\n    closeAuthorityAddress: account.data.closeAuthorityOption ? account.data.closeAuthority : null,\n    delegateAddress: account.data.delegateOption ? account.data.delegate : null,\n    delegateAmount: token(account.data.delegatedAmount.toString()),\n    state: account.data.state\n  };\n};\n/** @group Models */\n\n/** @group Model Helpers */\n\n\nconst isTokenWithMint = value => typeof value === 'object' && value.model === 'tokenWithMint';\n/** @group Model Helpers */\n\n\nfunction assertTokenWithMint(value) {\n  assert(isTokenWithMint(value), `Expected TokenWithMint model`);\n}\n/** @group Model Helpers */\n\n\nconst toTokenWithMint = (tokenAccount, mintModel) => {\n  const token = toToken(tokenAccount);\n  return { ...token,\n    model: 'tokenWithMint',\n    mint: mintModel,\n    amount: amount(token.amount.basisPoints, mintModel.currency),\n    delegateAmount: amount(token.delegateAmount.basisPoints, mintModel.currency)\n  };\n};\n\nexport { assertToken, assertTokenWithMint, isToken, isTokenWithMint, toToken, toTokenWithMint };","map":{"version":3,"sources":["../../../../../src/plugins/tokenModule/models/Token.ts"],"names":["isToken","value","model","assertToken","assert","toToken","account","associatedTokenAddress","Pda","find","associatedTokenProgram","address","data","owner","toBuffer","mint","isAssociatedToken","equals","publicKey","mintAddress","ownerAddress","amount","token","toString","closeAuthorityAddress","closeAuthorityOption","closeAuthority","delegateAddress","delegateOption","delegate","delegateAmount","delegatedAmount","state","isTokenWithMint","assertTokenWithMint","toTokenWithMint","tokenAccount","mintModel","basisPoints","currency"],"mappings":";;;;AAQA;AACA;AACA;AACA;AACA;;AAuDA;;AACaA,MAAAA,OAAO,GAAIC,KAAU,IAChC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACC,KAAND,KAAgB,OADlCD;AAGb;;;AACO,SAASG,WAAT,CAAqBF,KAArB,EAAyD;EAC9DG,MAAM,CAACJ,OAAO,CAACC,KAAD,CAAR,EAAkB,sBAAlB,CAANG;AACF;AAEA;;;AACaC,MAAAA,OAAO,GAAIC,OAAqB,IAAY;EACvD,MAAMC,sBAAsB,GAAGC,GAAG,CAACC,IAAJD,CAASE,sBAAsB,CAACC,OAAhCH,EAAyC,CACtEF,OAAO,CAACM,IAARN,CAAaO,KAAbP,CAAmBQ,QAAnBR,EADsE,EAEtEA,OAAO,CAACO,KAARP,CAAcQ,QAAdR,EAFsE,EAGtEA,OAAO,CAACM,IAARN,CAAaS,IAAbT,CAAkBQ,QAAlBR,EAHsE,CAAzCE,CAA/B;EAKA,MAAMQ,iBAAiB,GAAGT,sBAAsB,CAACU,MAAvBV,CAA8BD,OAAO,CAACY,SAAtCX,CAA1B;EAEA,OAAO;IACLL,KAAK,EAAE,OADF;IAELS,OAAO,EAAEK,iBAAiB,GAAGT,sBAAH,GAA4BD,OAAO,CAACY,SAFzD;IAGLF,iBAHK;IAILG,WAAW,EAAEb,OAAO,CAACM,IAARN,CAAaS,IAJrB;IAKLK,YAAY,EAAEd,OAAO,CAACM,IAARN,CAAaO,KALtB;IAMLQ,MAAM,EAAEC,KAAK,CAAChB,OAAO,CAACM,IAARN,CAAae,MAAbf,CAAoBiB,QAApBjB,EAAD,CANR;IAOLkB,qBAAqB,EAAElB,OAAO,CAACM,IAARN,CAAamB,oBAAbnB,GACnBA,OAAO,CAACM,IAARN,CAAaoB,cADMpB,GAEnB,IATC;IAULqB,eAAe,EAAErB,OAAO,CAACM,IAARN,CAAasB,cAAbtB,GAA8BA,OAAO,CAACM,IAARN,CAAauB,QAA3CvB,GAAsD,IAVlE;IAWLwB,cAAc,EAAER,KAAK,CAAChB,OAAO,CAACM,IAARN,CAAayB,eAAbzB,CAA6BiB,QAA7BjB,EAAD,CAXhB;IAYL0B,KAAK,EAAE1B,OAAO,CAACM,IAARN,CAAa0B;EAZf,CAAP;AAcF,CAtBa3B;AAwBb;;AAOA;;;AACa4B,MAAAA,eAAe,GAAIhC,KAAU,IACxC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACC,KAAND,KAAgB,eADlCgC;AAGb;;;AACO,SAASC,mBAAT,CACLjC,KADK,EAE2B;EAChCG,MAAM,CAAC6B,eAAe,CAAChC,KAAD,CAAhB,EAA0B,8BAA1B,CAANG;AACF;AAEA;;;MACa+B,eAAe,GAAG,CAC7BC,YAD6B,EAE7BC,SAF6B,KAGX;EAClB,MAAMf,KAAK,GAAGjB,OAAO,CAAC+B,YAAD,CAArB;EACA,OAAO,EACL,GAAGd,KADE;IAELpB,KAAK,EAAE,eAFF;IAGLa,IAAI,EAAEsB,SAHD;IAILhB,MAAM,EAAEA,MAAM,CAACC,KAAK,CAACD,MAANC,CAAagB,WAAd,EAA2BD,SAAS,CAACE,QAArC,CAJT;IAKLT,cAAc,EAAET,MAAM,CACpBC,KAAK,CAACQ,cAANR,CAAqBgB,WADD,EAEpBD,SAAS,CAACE,QAFU;EALjB,CAAP;AAUF,C","sourcesContent":["import type { PublicKey } from '@solana/web3.js';\nimport { AccountState } from '@solana/spl-token';\nimport { TokenAccount } from '../accounts';\nimport { associatedTokenProgram } from '../program';\nimport { Mint } from './Mint';\nimport { amount, Pda, SplTokenAmount, token } from '@/types';\nimport { assert, Option } from '@/utils';\n\n/**\n * This model represents a token account.\n *\n * @group Models\n */\nexport type Token = {\n  /** A model identifier to distinguish models in the SDK. */\n  readonly model: 'token';\n\n  /** The address of the token account. */\n  readonly address: PublicKey | Pda;\n\n  /** Whether or not this is an associated token account. */\n  readonly isAssociatedToken: boolean;\n\n  /** The address of the mint account. */\n  readonly mintAddress: PublicKey;\n\n  /** The address of the owner of this token account. */\n  readonly ownerAddress: PublicKey;\n\n  /** The amount of tokens held in this account. */\n  readonly amount: SplTokenAmount;\n\n  /**\n   * The address of the authority that can close the account.\n   * This field is optional and may be `null`.\n   */\n  readonly closeAuthorityAddress: Option<PublicKey>;\n\n  /**\n   * The address of the authority that can act on behalf of the owner\n   * of the account. This field is optional and may be `null`.\n   */\n  readonly delegateAddress: Option<PublicKey>;\n\n  /**\n   * The amount of tokens that were delegated to the delegate authority.\n   * This means the delegate authority cannot transfer more tokens\n   * than this amount even if the token account has more tokens available.\n   *\n   * This field is only relevant if the account has a delegate authority.\n   */\n  readonly delegateAmount: SplTokenAmount;\n\n  /**\n   * The state of the token account.\n   * It is mostly used to determine whether or not the account is frozen.\n   *\n   * It can be one of the following:\n   * - `AccountState.Uninitialized`: The account has not been initialized.\n   *   This should never happen in this model since the SDK would fail to\n   *   parse this model if it were uninitialized.\n   * - `AccountState.Initialized`: The account has been initialized and is not frozen.\n   * - `AccountState.Frozen`: The account has been initialized and is frozen.\n   */\n  readonly state: AccountState;\n};\n\n/** @group Model Helpers */\nexport const isToken = (value: any): value is Token =>\n  typeof value === 'object' && value.model === 'token';\n\n/** @group Model Helpers */\nexport function assertToken(value: any): asserts value is Token {\n  assert(isToken(value), `Expected Token model`);\n}\n\n/** @group Model Helpers */\nexport const toToken = (account: TokenAccount): Token => {\n  const associatedTokenAddress = Pda.find(associatedTokenProgram.address, [\n    account.data.owner.toBuffer(),\n    account.owner.toBuffer(),\n    account.data.mint.toBuffer(),\n  ]);\n  const isAssociatedToken = associatedTokenAddress.equals(account.publicKey);\n\n  return {\n    model: 'token',\n    address: isAssociatedToken ? associatedTokenAddress : account.publicKey,\n    isAssociatedToken,\n    mintAddress: account.data.mint,\n    ownerAddress: account.data.owner,\n    amount: token(account.data.amount.toString()),\n    closeAuthorityAddress: account.data.closeAuthorityOption\n      ? account.data.closeAuthority\n      : null,\n    delegateAddress: account.data.delegateOption ? account.data.delegate : null,\n    delegateAmount: token(account.data.delegatedAmount.toString()),\n    state: account.data.state,\n  };\n};\n\n/** @group Models */\nexport type TokenWithMint = Omit<Token, 'model' | 'mintAddress'> &\n  Readonly<{\n    model: 'tokenWithMint';\n    mint: Mint;\n  }>;\n\n/** @group Model Helpers */\nexport const isTokenWithMint = (value: any): value is TokenWithMint =>\n  typeof value === 'object' && value.model === 'tokenWithMint';\n\n/** @group Model Helpers */\nexport function assertTokenWithMint(\n  value: any\n): asserts value is TokenWithMint {\n  assert(isTokenWithMint(value), `Expected TokenWithMint model`);\n}\n\n/** @group Model Helpers */\nexport const toTokenWithMint = (\n  tokenAccount: TokenAccount,\n  mintModel: Mint\n): TokenWithMint => {\n  const token = toToken(tokenAccount);\n  return {\n    ...token,\n    model: 'tokenWithMint',\n    mint: mintModel,\n    amount: amount(token.amount.basisPoints, mintModel.currency),\n    delegateAmount: amount(\n      token.delegateAmount.basisPoints,\n      mintModel.currency\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}