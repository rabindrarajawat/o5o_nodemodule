{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst react_1 = require(\"react\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst types_1 = require(\"../types\");\n\nconst useChain_1 = __importDefault(require(\"./useChain\"));\n\nconst useRefresh_1 = __importDefault(require(\"./useRefresh\"));\n\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\n\nconst actionCreator_1 = require(\"../actionCreator\");\n\nconst usePOWO_1 = __importDefault(require(\"./usePOWO\"));\n\nconst useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\n\nconst useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\n\nconst networkConfig_1 = __importDefault(require(\"../networkConfig\"));\n\nconst useCivicPass_1 = __importDefault(require(\"./useCivicPass\"));\n\nconst useCivicPassEventListener_1 = __importDefault(require(\"./useCivicPassEventListener\"));\n\nconst status_1 = require(\"../utils/status\");\n\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\n\n\nconst useOrchestration = (_ref, state, dispatch) => {\n  let {\n    wallet,\n    stage,\n    chainImplementation,\n    gatekeeperClient\n  } = _ref;\n  const {\n    expectWalletConnected\n  } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n  const {\n    gatewayToken,\n    walletToRefresh,\n    civicPass,\n    refreshTokenState,\n    gatewayStatus,\n    gatekeeperNetworkAddress,\n    ownerSigns,\n    renderIframe,\n    refreshTimeoutId\n  } = state;\n  const networkConfig = (0, networkConfig_1.default)({\n    gatekeeperNetworkAddress,\n    stage\n  }); // Register our hooks here\n\n  const {\n    waitForConfirmPOWO,\n    waitForPOWO,\n    waitForTransactionConfirm,\n    waitForHandleTransaction\n  } = (0, usePOWO_1.default)({\n    wallet,\n    chainImplementation\n  }, state, dispatch);\n  const gatekeeperEndpoint = chainImplementation.httpConfig.baseUrl;\n  const {\n    waitForGatekeeperIssuanceRequest\n  } = (0, useGatekeeper_1.default)({\n    wallet,\n    stage,\n    gatekeeperClient\n  }, state, dispatch);\n  const {\n    checkForRefreshWithTimeout,\n    refreshToken,\n    waitForUnexpiredGatewayToken\n  } = (0, useRefresh_1.default)({\n    stage,\n    gatekeeperClient,\n    networkConfig\n  }, state, dispatch);\n  (0, useCivicPass_1.default)({\n    wallet\n  }, state, dispatch);\n  (0, useCivicPassEventListener_1.default)({\n    wallet,\n    chainImplementation\n  });\n  (0, useChain_1.default)({\n    wallet,\n    chainImplementation,\n    networkConfig\n  }, state, dispatch);\n  (0, useGatekeeperRecord_1.default)({\n    wallet,\n    gatekeeperClient,\n    httpConfig: chainImplementation.httpConfig,\n    networkConfig\n  }, state, dispatch);\n  /**\n   * Refresh Flows ----------------------------------------------------------------\n   */\n\n  /**\n   * wait until we have a payload that has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n\n  const waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(() => {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n    const result = new Promise(resolve => {\n      const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      const refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n      logger_1.default.debug('Refresh payload...', {\n        refreshPayload,\n        refreshPayloadState: refreshPayload === undefined\n      });\n\n      if (refreshPayload !== undefined) {\n        logger_1.default.debug('Refreshing token...');\n        resolve(refreshPayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * When we have a token start check the next expiration so we can prompt the user to refresh\n   */\n\n  (0, react_1.useEffect)(() => {\n    logger_1.default.debug('useOrchestration', {\n      gatewayStatus: gatewayStatus && (0, status_1.statusDisplayValue)(gatewayStatus),\n      refreshTokenState: refreshTokenState && types_1.RefreshTokenState[refreshTokenState]\n    });\n\n    if (gatewayStatus === types_1.GatewayStatus.ACTIVE || refreshTokenState === types_1.RefreshTokenState.COMPLETED) {\n      logger_1.default.debug('Start polling for the refresh interval');\n      checkForRefreshWithTimeout(wallet);\n    }\n  }, [gatewayStatus, refreshTokenState, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, renderIframe]);\n  /**\n   * Whenever the iFrame is rendered, clear the timeout\n   */\n\n  (0, react_1.useEffect)(() => {\n    if (renderIframe && refreshTimeoutId) {\n      logger_1.default.debug('useEffect:dispatch refresh_clear_timeout');\n      clearTimeout(refreshTimeoutId);\n      dispatch({\n        type: 'refresh_clear_timeout'\n      });\n    }\n  }, [renderIframe, refreshTimeoutId]);\n  /**\n   * Issuance Flows ----------------------------------------------------------------\n   */\n\n  /**\n   * poll until a gatekeeper record is found, once active check the chain for a token\n   * then dispatch a tokenChange event that will result in the token getting saved to state\n   * start token refresh polling once a valid token is set\n   */\n\n  const waitForOnChainToken = (0, react_1.useCallback)(async () => {\n    if (wallet) {\n      logger_1.default.debug('waitForOnChainToken');\n      const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n        wallet,\n        chainImplementation,\n        gatekeeperClient,\n        dispatch,\n        networkConfig,\n        ownerSigns\n      });\n      await actionCreator.waitForGatewayToken();\n    }\n\n    return null;\n  }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n  /**\n   * wait until a presentation request id has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n\n  const waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(() => {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n    const result = new Promise(resolve => {\n      const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      const issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n      logger_1.default.debug('Issuance payload...', issuancePayload);\n\n      if (issuancePayload !== undefined) {\n        resolve(issuancePayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * wait until the user has requested a gateway token before resolving the promise\n   */\n\n  const checkForRequiredProof = (0, react_1.useCallback)(async _ref2 => {\n    let {\n      requiresProofOfWalletOwnership,\n      payload\n    } = _ref2;\n    logger_1.default.debug('Checking for required proof', {\n      requiresProofOfWalletOwnership,\n      payload\n    });\n\n    if (requiresProofOfWalletOwnership) {\n      const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\n      return result;\n    }\n\n    return {\n      payload\n    };\n  }, [waitForConfirmPOWO, waitForPOWO]);\n  /**\n   * New token request flow !ownerSigns:\n   * wait for the user to request a new token\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to request a new token issuance\n   * wait for a gatekeeper record to be created\n   * once this flow is complete a new Gatekeeper token should be available and set in state\n   */\n\n  (0, react_1.useEffect)(() => {\n    if (!ownerSigns) {\n      logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload !ownerSigns');\n      waitForCivicPassIssuanceResponsePayload().then(checkForRequiredProof).then(waitForGatekeeperIssuanceRequest).then(waitForOnChainToken).then(() => checkForRefreshWithTimeout(wallet)).catch(error => {\n        dispatch({\n          type: 'civicPass_issuance_failure'\n        });\n        logger_1.default.error('ERROR newTokenRequestFlow', error);\n      });\n    }\n  }, [waitForCivicPassIssuanceResponsePayload, checkForRequiredProof, waitForGatekeeperIssuanceRequest, waitForOnChainToken, ownerSigns]);\n  /** Wrapper to pass through expected parameters when waiting for owner signs confirmation */\n\n  const confirmOwnerTransaction = (0, react_1.useCallback)(async _ref3 => {\n    let {\n      payload\n    } = _ref3;\n    await waitForTransactionConfirm();\n    return {\n      payload\n    };\n  }, [waitForTransactionConfirm]);\n  /**\n   * Trigger the waiting for owner transaction state\n   * this function is a promise so it can be thenable\n   */\n\n  const showAwaitingOwnerTransaction = async () => {\n    logger_1.default.debug('showAwaitingOwnerTransaction');\n    dispatch({\n      type: 'civicPass_awaiting_owner_transaction'\n    });\n    return Promise.resolve();\n  };\n  /**\n   * New token request flow ownerSigns:\n   * wait for the user to request a new token\n   * wait for the iframe to return a payload\n   * wait for the user to confirm the transaction that they need to sign\n   * wait for a call to the gatekeeper to request a new token issuance\n   * wait for the handle transaction callback\n   * wait for a gatekeeper record to be created on chain\n   * once this flow is complete a new Gatekeeper token should be available and set in state\n   */\n\n\n  (0, react_1.useEffect)(() => {\n    if (ownerSigns) {\n      logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload ownerSigns');\n      waitForCivicPassIssuanceResponsePayload().then(confirmOwnerTransaction).then(waitForGatekeeperIssuanceRequest).then(waitForHandleTransaction).then(showAwaitingOwnerTransaction).then(waitForOnChainToken).then(() => checkForRefreshWithTimeout(wallet)).catch(error => {\n        // chain transaction errors will be handled using a different flow and dispatch event\n        if (!(error instanceof types_1.ChainTransactionError)) {\n          dispatch({\n            type: 'civicPass_issuance_failure'\n          });\n        }\n\n        logger_1.default.error('ERROR newTokenRequestFlow', error);\n      });\n    }\n  }, [waitForCivicPassIssuanceResponsePayload, confirmOwnerTransaction, waitForGatekeeperIssuanceRequest, waitForHandleTransaction, waitForOnChainToken, ownerSigns]);\n  /**\n   * Refresh start flow !ownerSigns:\n   * Triggered when we have a refreshResponse payload\n   * wait refresh to be triggered from the iFrame\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to refresh the token\n   * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below\n   */\n\n  (0, react_1.useEffect)(() => {\n    if (!ownerSigns) {\n      logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload !ownerSigns');\n      const useWallet = walletToRefresh || wallet;\n      waitForCivicPassRefreshResponsePayload().then(checkForRequiredProof).then(refreshToken(useWallet)).then(() => dispatch({\n        type: 'refresh_token_success'\n      })).catch(error => {\n        logger_1.default.error('refreshFlow', error);\n        dispatch({\n          type: 'civicPass_refresh_failure'\n        });\n      });\n    }\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, ownerSigns]);\n  /**\n   * Refresh start flow ownerSigns:\n   * Triggered when we have a refreshResponse payload\n   * wait refresh to be triggered from the iFrame\n   * wait for the iframe to return a payload\n   * wait for the handle transaction callback\n   * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below\n   */\n\n  (0, react_1.useEffect)(() => {\n    if (ownerSigns) {\n      logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload ownerSigns');\n      const useWallet = walletToRefresh || wallet;\n      waitForCivicPassRefreshResponsePayload().then(refreshToken(useWallet)).then(waitForHandleTransaction).then(() => dispatch({\n        type: 'refresh_token_success'\n      })).catch(error => {\n        // chain transaction errors will be handled using a different flow and dispatch event\n        if (!(error instanceof types_1.ChainTransactionError)) {\n          dispatch({\n            type: 'civicPass_refresh_failure'\n          });\n        }\n\n        logger_1.default.error('ERROR tokenRefreshFlow ownerSigns', error);\n      });\n    }\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, ownerSigns]);\n  /**\n   * Refresh complete flow:\n   * Triggered by token change event triggered from a call to the gatekeeper to refresh the token\n   * for owner signs case, dispatch an event to show the iframe chain-transaction confirming screen\n   * wait until the token is unexpired and clear timeout if token is not expired\n   * Complete the refresh event and clear the refresh response payload\n   */\n\n  (0, react_1.useEffect)(() => {\n    const useWallet = walletToRefresh || wallet;\n\n    if (refreshTokenState === types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN) {\n      logger_1.default.debug('useEffect: Refresh complete flow', {\n        expiryTime: gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime,\n        hasExpired: (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) ? (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime) : 'unknown'\n      }); // if the dApp handles the transaction we shouldn't assume that the final state is 'unexpired' token\n\n      const optionalCheckUnexpired = chainImplementation.dAppHandlesTransactions && ownerSigns ? () => Promise.resolve() : waitForUnexpiredGatewayToken;\n      optionalCheckUnexpired().then(() => checkForRefreshWithTimeout(useWallet)).then(() => {\n        dispatch({\n          type: 'refresh_complete'\n        });\n        dispatch({\n          type: 'civicPass_check_token_status'\n        });\n      }).catch(error => {\n        logger_1.default.error('refreshFlow', error);\n        dispatch({\n          type: 'civicPass_refresh_failure'\n        });\n      });\n    }\n  }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.identifier, gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, refreshTokenState, walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, ownerSigns]);\n};\n\nexports.default = useOrchestration;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","react_1","require","logger_1","types_1","useChain_1","useRefresh_1","useWalletHooks_1","actionCreator_1","usePOWO_1","useGatekeeper_1","useGatekeeperRecord_1","networkConfig_1","useCivicPass_1","useCivicPassEventListener_1","status_1","tokenUtils_1","useOrchestration","state","dispatch","wallet","stage","chainImplementation","gatekeeperClient","expectWalletConnected","default","gatewayToken","walletToRefresh","civicPass","refreshTokenState","gatewayStatus","gatekeeperNetworkAddress","ownerSigns","renderIframe","refreshTimeoutId","networkConfig","waitForConfirmPOWO","waitForPOWO","waitForTransactionConfirm","waitForHandleTransaction","gatekeeperEndpoint","httpConfig","baseUrl","waitForGatekeeperIssuanceRequest","checkForRefreshWithTimeout","refreshToken","waitForUnexpiredGatewayToken","waitForCivicPassRefreshResponsePayload","useCallback","debug","result","Promise","resolve","responsePayload","refreshPayload","CivicPassMessageAction","REFRESH","refreshPayloadState","undefined","useEffect","statusDisplayValue","RefreshTokenState","GatewayStatus","ACTIVE","COMPLETED","publicKey","clearTimeout","type","waitForOnChainToken","actionCreator","gatewayTokenActionCreator","waitForGatewayToken","waitForCivicPassIssuanceResponsePayload","issuancePayload","ISSUANCE","checkForRequiredProof","requiresProofOfWalletOwnership","payload","then","catch","error","confirmOwnerTransaction","showAwaitingOwnerTransaction","ChainTransactionError","useWallet","WAIT_FOR_ON_CHAIN","expiryTime","hasExpired","optionalCheckUnexpired","dAppHandlesTransactions","identifier"],"sources":["D:/software/o5o BNB/o5o-staking-frontend/node_modules/@civic/common-gateway-react/dist/esm/useHooks/useOrchestration.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst react_1 = require(\"react\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst useChain_1 = __importDefault(require(\"./useChain\"));\nconst useRefresh_1 = __importDefault(require(\"./useRefresh\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst actionCreator_1 = require(\"../actionCreator\");\nconst usePOWO_1 = __importDefault(require(\"./usePOWO\"));\nconst useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\nconst useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\nconst networkConfig_1 = __importDefault(require(\"../networkConfig\"));\nconst useCivicPass_1 = __importDefault(require(\"./useCivicPass\"));\nconst useCivicPassEventListener_1 = __importDefault(require(\"./useCivicPassEventListener\"));\nconst status_1 = require(\"../utils/status\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\nconst useOrchestration = ({ wallet, stage, chainImplementation, gatekeeperClient, }, state, dispatch) => {\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    const { gatewayToken, walletToRefresh, civicPass, refreshTokenState, gatewayStatus, gatekeeperNetworkAddress, ownerSigns, renderIframe, refreshTimeoutId, } = state;\n    const networkConfig = (0, networkConfig_1.default)({ gatekeeperNetworkAddress, stage });\n    // Register our hooks here\n    const { waitForConfirmPOWO, waitForPOWO, waitForTransactionConfirm, waitForHandleTransaction } = (0, usePOWO_1.default)({ wallet, chainImplementation }, state, dispatch);\n    const gatekeeperEndpoint = chainImplementation.httpConfig.baseUrl;\n    const { waitForGatekeeperIssuanceRequest } = (0, useGatekeeper_1.default)({ wallet, stage, gatekeeperClient }, state, dispatch);\n    const { checkForRefreshWithTimeout, refreshToken, waitForUnexpiredGatewayToken } = (0, useRefresh_1.default)({ stage, gatekeeperClient, networkConfig }, state, dispatch);\n    (0, useCivicPass_1.default)({ wallet }, state, dispatch);\n    (0, useCivicPassEventListener_1.default)({ wallet, chainImplementation });\n    (0, useChain_1.default)({ wallet, chainImplementation, networkConfig }, state, dispatch);\n    (0, useGatekeeperRecord_1.default)({ wallet, gatekeeperClient, httpConfig: chainImplementation.httpConfig, networkConfig }, state, dispatch);\n    /**\n     * Refresh Flows ----------------------------------------------------------------\n     */\n    /**\n     * wait until we have a payload that has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n            logger_1.default.debug('Refresh payload...', {\n                refreshPayload,\n                refreshPayloadState: refreshPayload === undefined,\n            });\n            if (refreshPayload !== undefined) {\n                logger_1.default.debug('Refreshing token...');\n                resolve(refreshPayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * When we have a token start check the next expiration so we can prompt the user to refresh\n     */\n    (0, react_1.useEffect)(() => {\n        logger_1.default.debug('useOrchestration', {\n            gatewayStatus: gatewayStatus && (0, status_1.statusDisplayValue)(gatewayStatus),\n            refreshTokenState: refreshTokenState && types_1.RefreshTokenState[refreshTokenState],\n        });\n        if (gatewayStatus === types_1.GatewayStatus.ACTIVE || refreshTokenState === types_1.RefreshTokenState.COMPLETED) {\n            logger_1.default.debug('Start polling for the refresh interval');\n            checkForRefreshWithTimeout(wallet);\n        }\n    }, [gatewayStatus, refreshTokenState, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, renderIframe]);\n    /**\n     * Whenever the iFrame is rendered, clear the timeout\n     */\n    (0, react_1.useEffect)(() => {\n        if (renderIframe && refreshTimeoutId) {\n            logger_1.default.debug('useEffect:dispatch refresh_clear_timeout');\n            clearTimeout(refreshTimeoutId);\n            dispatch({ type: 'refresh_clear_timeout' });\n        }\n    }, [renderIframe, refreshTimeoutId]);\n    /**\n     * Issuance Flows ----------------------------------------------------------------\n     */\n    /**\n     * poll until a gatekeeper record is found, once active check the chain for a token\n     * then dispatch a tokenChange event that will result in the token getting saved to state\n     * start token refresh polling once a valid token is set\n     */\n    const waitForOnChainToken = (0, react_1.useCallback)(async () => {\n        if (wallet) {\n            logger_1.default.debug('waitForOnChainToken');\n            const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n                wallet,\n                chainImplementation,\n                gatekeeperClient,\n                dispatch,\n                networkConfig,\n                ownerSigns,\n            });\n            await actionCreator.waitForGatewayToken();\n        }\n        return null;\n    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n    /**\n     * wait until a presentation request id has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n            logger_1.default.debug('Issuance payload...', issuancePayload);\n            if (issuancePayload !== undefined) {\n                resolve(issuancePayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * wait until the user has requested a gateway token before resolving the promise\n     */\n    const checkForRequiredProof = (0, react_1.useCallback)(async ({ requiresProofOfWalletOwnership, payload, }) => {\n        logger_1.default.debug('Checking for required proof', { requiresProofOfWalletOwnership, payload });\n        if (requiresProofOfWalletOwnership) {\n            const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\n            return result;\n        }\n        return { payload };\n    }, [waitForConfirmPOWO, waitForPOWO]);\n    /**\n     * New token request flow !ownerSigns:\n     * wait for the user to request a new token\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to request a new token issuance\n     * wait for a gatekeeper record to be created\n     * once this flow is complete a new Gatekeeper token should be available and set in state\n     */\n    (0, react_1.useEffect)(() => {\n        if (!ownerSigns) {\n            logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload !ownerSigns');\n            waitForCivicPassIssuanceResponsePayload()\n                .then(checkForRequiredProof)\n                .then(waitForGatekeeperIssuanceRequest)\n                .then(waitForOnChainToken)\n                .then(() => checkForRefreshWithTimeout(wallet))\n                .catch((error) => {\n                dispatch({ type: 'civicPass_issuance_failure' });\n                logger_1.default.error('ERROR newTokenRequestFlow', error);\n            });\n        }\n    }, [\n        waitForCivicPassIssuanceResponsePayload,\n        checkForRequiredProof,\n        waitForGatekeeperIssuanceRequest,\n        waitForOnChainToken,\n        ownerSigns,\n    ]);\n    /** Wrapper to pass through expected parameters when waiting for owner signs confirmation */\n    const confirmOwnerTransaction = (0, react_1.useCallback)(async ({ payload }) => {\n        await waitForTransactionConfirm();\n        return { payload };\n    }, [waitForTransactionConfirm]);\n    /**\n     * Trigger the waiting for owner transaction state\n     * this function is a promise so it can be thenable\n     */\n    const showAwaitingOwnerTransaction = async () => {\n        logger_1.default.debug('showAwaitingOwnerTransaction');\n        dispatch({ type: 'civicPass_awaiting_owner_transaction' });\n        return Promise.resolve();\n    };\n    /**\n     * New token request flow ownerSigns:\n     * wait for the user to request a new token\n     * wait for the iframe to return a payload\n     * wait for the user to confirm the transaction that they need to sign\n     * wait for a call to the gatekeeper to request a new token issuance\n     * wait for the handle transaction callback\n     * wait for a gatekeeper record to be created on chain\n     * once this flow is complete a new Gatekeeper token should be available and set in state\n     */\n    (0, react_1.useEffect)(() => {\n        if (ownerSigns) {\n            logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload ownerSigns');\n            waitForCivicPassIssuanceResponsePayload()\n                .then(confirmOwnerTransaction)\n                .then(waitForGatekeeperIssuanceRequest)\n                .then(waitForHandleTransaction)\n                .then(showAwaitingOwnerTransaction)\n                .then(waitForOnChainToken)\n                .then(() => checkForRefreshWithTimeout(wallet))\n                .catch((error) => {\n                // chain transaction errors will be handled using a different flow and dispatch event\n                if (!(error instanceof types_1.ChainTransactionError)) {\n                    dispatch({ type: 'civicPass_issuance_failure' });\n                }\n                logger_1.default.error('ERROR newTokenRequestFlow', error);\n            });\n        }\n    }, [\n        waitForCivicPassIssuanceResponsePayload,\n        confirmOwnerTransaction,\n        waitForGatekeeperIssuanceRequest,\n        waitForHandleTransaction,\n        waitForOnChainToken,\n        ownerSigns,\n    ]);\n    /**\n     * Refresh start flow !ownerSigns:\n     * Triggered when we have a refreshResponse payload\n     * wait refresh to be triggered from the iFrame\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to refresh the token\n     * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below\n     */\n    (0, react_1.useEffect)(() => {\n        if (!ownerSigns) {\n            logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload !ownerSigns');\n            const useWallet = walletToRefresh || wallet;\n            waitForCivicPassRefreshResponsePayload()\n                .then(checkForRequiredProof)\n                .then(refreshToken(useWallet))\n                .then(() => dispatch({ type: 'refresh_token_success' }))\n                .catch((error) => {\n                logger_1.default.error('refreshFlow', error);\n                dispatch({ type: 'civicPass_refresh_failure' });\n            });\n        }\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, ownerSigns]);\n    /**\n     * Refresh start flow ownerSigns:\n     * Triggered when we have a refreshResponse payload\n     * wait refresh to be triggered from the iFrame\n     * wait for the iframe to return a payload\n     * wait for the handle transaction callback\n     * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below\n     */\n    (0, react_1.useEffect)(() => {\n        if (ownerSigns) {\n            logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload ownerSigns');\n            const useWallet = walletToRefresh || wallet;\n            waitForCivicPassRefreshResponsePayload()\n                .then(refreshToken(useWallet))\n                .then(waitForHandleTransaction)\n                .then(() => dispatch({ type: 'refresh_token_success' }))\n                .catch((error) => {\n                // chain transaction errors will be handled using a different flow and dispatch event\n                if (!(error instanceof types_1.ChainTransactionError)) {\n                    dispatch({ type: 'civicPass_refresh_failure' });\n                }\n                logger_1.default.error('ERROR tokenRefreshFlow ownerSigns', error);\n            });\n        }\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, ownerSigns]);\n    /**\n     * Refresh complete flow:\n     * Triggered by token change event triggered from a call to the gatekeeper to refresh the token\n     * for owner signs case, dispatch an event to show the iframe chain-transaction confirming screen\n     * wait until the token is unexpired and clear timeout if token is not expired\n     * Complete the refresh event and clear the refresh response payload\n     */\n    (0, react_1.useEffect)(() => {\n        const useWallet = walletToRefresh || wallet;\n        if (refreshTokenState === types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN) {\n            logger_1.default.debug('useEffect: Refresh complete flow', {\n                expiryTime: gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime,\n                hasExpired: (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) ? (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime) : 'unknown',\n            });\n            // if the dApp handles the transaction we shouldn't assume that the final state is 'unexpired' token\n            const optionalCheckUnexpired = chainImplementation.dAppHandlesTransactions && ownerSigns\n                ? () => Promise.resolve()\n                : waitForUnexpiredGatewayToken;\n            optionalCheckUnexpired()\n                .then(() => checkForRefreshWithTimeout(useWallet))\n                .then(() => {\n                dispatch({ type: 'refresh_complete' });\n                dispatch({ type: 'civicPass_check_token_status' });\n            })\n                .catch((error) => {\n                logger_1.default.error('refreshFlow', error);\n                dispatch({ type: 'civicPass_refresh_failure' });\n            });\n        }\n    }, [\n        gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.identifier,\n        gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime,\n        refreshTokenState,\n        walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey,\n        wallet === null || wallet === void 0 ? void 0 : wallet.publicKey,\n        ownerSigns,\n    ]);\n};\nexports.default = useOrchestration;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}