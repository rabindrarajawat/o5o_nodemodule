{"ast":null,"code":"import { chunk } from './common.mjs';\n\nclass GmaBuilder {\n  constructor(metaplex, publicKeys) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.metaplex = metaplex;\n    this.chunkSize = options.chunkSize ?? 100;\n    this.commitment = options.commitment;\n    this.publicKeys = publicKeys;\n  }\n\n  static make(metaplex, publicKeys) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new GmaBuilder(metaplex, publicKeys, options);\n  }\n\n  chunkBy(n) {\n    this.chunkSize = n;\n    return this;\n  }\n\n  addPublicKeys(publicKeys) {\n    this.publicKeys.push(...publicKeys);\n    return this;\n  }\n\n  getPublicKeys() {\n    return this.publicKeys;\n  }\n\n  getUniquePublicKeys() {\n    // TODO: Only send unique keys and reconciliate after call.\n    return this.getPublicKeys();\n  }\n\n  async getFirst(n) {\n    const end = this.boundNumber(n ?? 1);\n    return this.getChunks(this.getPublicKeys().slice(0, end));\n  }\n\n  async getLast(n) {\n    const start = this.boundNumber(n ?? 1);\n    return this.getChunks(this.getPublicKeys().slice(-start));\n  }\n\n  async getBetween(start, end) {\n    start = this.boundNumber(start);\n    end = this.boundNumber(end);\n    [start, end] = start > end ? [end, start] : [start, end];\n    return this.getChunks(this.getPublicKeys().slice(start, end));\n  }\n\n  async getPage(page, perPage) {\n    return this.getBetween((page - 1) * perPage, page * perPage);\n  }\n\n  async get() {\n    return this.getChunks(this.getPublicKeys());\n  }\n\n  async getAndMap(callback) {\n    return (await this.get()).map(callback);\n  }\n\n  async getChunks(publicKeys) {\n    const chunks = chunk(publicKeys, this.chunkSize);\n    const chunkPromises = chunks.map(chunk => this.getChunk(chunk));\n    const resolvedChunks = await Promise.all(chunkPromises);\n    return resolvedChunks.flat();\n  }\n\n  async getChunk(publicKeys) {\n    try {\n      // TODO(loris): Use lower level RPC call to add dataSlice support.\n      return await this.metaplex.rpc().getMultipleAccounts(publicKeys, this.commitment);\n    } catch (error) {\n      // TODO(loris): Custom error instead.\n      throw error;\n    }\n  }\n\n  boundNumber(n) {\n    return this.boundIndex(n - 1) + 1;\n  }\n\n  boundIndex(index) {\n    index = index < 0 ? 0 : index;\n    index = index >= this.publicKeys.length ? this.publicKeys.length - 1 : index;\n    return index;\n  }\n\n}\n\nexport { GmaBuilder };","map":{"version":3,"sources":["../../../src/utils/GmaBuilder.ts"],"names":["GmaBuilder","constructor","metaplex","publicKeys","options","chunkSize","commitment","make","chunkBy","n","addPublicKeys","push","getPublicKeys","getUniquePublicKeys","getFirst","end","boundNumber","getChunks","slice","getLast","start","getBetween","getPage","page","perPage","get","getAndMap","callback","map","chunks","chunk","chunkPromises","getChunk","resolvedChunks","Promise","all","flat","rpc","getMultipleAccounts","error","boundIndex","index","length"],"mappings":"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","sourcesContent":["import { Commitment, PublicKey } from '@solana/web3.js';\nimport { chunk } from './common';\nimport { Metaplex } from '@/Metaplex';\nimport { UnparsedMaybeAccount } from '@/types';\n\nexport type GmaBuilderOptions = {\n  chunkSize?: number;\n\n  /** The level of commitment desired when querying the blockchain. */\n  commitment?: Commitment;\n};\n\nexport class GmaBuilder {\n  protected readonly metaplex: Metaplex;\n  protected readonly publicKeys: PublicKey[];\n  protected readonly commitment?: Commitment;\n  protected chunkSize: number;\n\n  constructor(\n    metaplex: Metaplex,\n    publicKeys: PublicKey[],\n    options: GmaBuilderOptions = {}\n  ) {\n    this.metaplex = metaplex;\n    this.chunkSize = options.chunkSize ?? 100;\n    this.commitment = options.commitment;\n    this.publicKeys = publicKeys;\n  }\n\n  static make(\n    metaplex: Metaplex,\n    publicKeys: PublicKey[],\n    options: GmaBuilderOptions = {}\n  ) {\n    return new GmaBuilder(metaplex, publicKeys, options);\n  }\n\n  chunkBy(n: number) {\n    this.chunkSize = n;\n\n    return this;\n  }\n\n  addPublicKeys(publicKeys: PublicKey[]) {\n    this.publicKeys.push(...publicKeys);\n\n    return this;\n  }\n\n  getPublicKeys(): PublicKey[] {\n    return this.publicKeys;\n  }\n\n  getUniquePublicKeys(): PublicKey[] {\n    // TODO: Only send unique keys and reconciliate after call.\n    return this.getPublicKeys();\n  }\n\n  async getFirst(n?: number): Promise<UnparsedMaybeAccount[]> {\n    const end = this.boundNumber(n ?? 1);\n\n    return this.getChunks(this.getPublicKeys().slice(0, end));\n  }\n\n  async getLast(n?: number): Promise<UnparsedMaybeAccount[]> {\n    const start = this.boundNumber(n ?? 1);\n\n    return this.getChunks(this.getPublicKeys().slice(-start));\n  }\n\n  async getBetween(\n    start: number,\n    end: number\n  ): Promise<UnparsedMaybeAccount[]> {\n    start = this.boundNumber(start);\n    end = this.boundNumber(end);\n    [start, end] = start > end ? [end, start] : [start, end];\n\n    return this.getChunks(this.getPublicKeys().slice(start, end));\n  }\n\n  async getPage(\n    page: number,\n    perPage: number\n  ): Promise<UnparsedMaybeAccount[]> {\n    return this.getBetween((page - 1) * perPage, page * perPage);\n  }\n\n  async get(): Promise<UnparsedMaybeAccount[]> {\n    return this.getChunks(this.getPublicKeys());\n  }\n\n  async getAndMap<T>(\n    callback: (account: UnparsedMaybeAccount) => T\n  ): Promise<T[]> {\n    return (await this.get()).map(callback);\n  }\n\n  protected async getChunks(\n    publicKeys: PublicKey[]\n  ): Promise<UnparsedMaybeAccount[]> {\n    const chunks = chunk(publicKeys, this.chunkSize);\n    const chunkPromises = chunks.map((chunk) => this.getChunk(chunk));\n    const resolvedChunks = await Promise.all(chunkPromises);\n\n    return resolvedChunks.flat();\n  }\n\n  protected async getChunk(\n    publicKeys: PublicKey[]\n  ): Promise<UnparsedMaybeAccount[]> {\n    try {\n      // TODO(loris): Use lower level RPC call to add dataSlice support.\n      return await this.metaplex\n        .rpc()\n        .getMultipleAccounts(publicKeys, this.commitment);\n    } catch (error) {\n      // TODO(loris): Custom error instead.\n      throw error;\n    }\n  }\n\n  protected boundNumber(n: number): number {\n    return this.boundIndex(n - 1) + 1;\n  }\n\n  protected boundIndex(index: number): number {\n    index = index < 0 ? 0 : index;\n    index =\n      index >= this.publicKeys.length ? this.publicKeys.length - 1 : index;\n\n    return index;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}