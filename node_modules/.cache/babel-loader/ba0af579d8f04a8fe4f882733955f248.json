{"ast":null,"code":"import { createUpdateMetadataAccountV2Instruction } from '@metaplex-foundation/mpl-token-metadata';\nimport isEqual from 'lodash.isequal';\nimport { NoInstructionsToSendError } from '../../../errors/SdkError.mjs';\nimport { useOperation } from '../../../types/Operation.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'UpdateNftOperation';\n/**\n * Updates an existing NFT or SFT.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .update({ nftOrSft, name: \"My new NFT name\" };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst updateNftOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst updateNftOperationHandler = {\n  handle: async (operation, metaplex, scope) => {\n    const builder = updateNftBuilder(metaplex, operation.input, scope);\n\n    if (builder.isEmpty()) {\n      throw new NoInstructionsToSendError(Key);\n    }\n\n    return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n  }\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Updates an existing NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .update({ nftOrSft, name: \"My new NFT name\" });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst updateNftBuilder = function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    nftOrSft,\n    updateAuthority = metaplex.identity()\n  } = params; // Programs.\n\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const updateInstructionDataWithoutChanges = toInstructionData(nftOrSft);\n  const updateInstructionData = toInstructionData(nftOrSft, params);\n  const shouldSendUpdateInstruction = !isEqual(updateInstructionData, updateInstructionDataWithoutChanges);\n  const isRemovingVerifiedCollection = !!nftOrSft.collection && !!nftOrSft.collection.verified && params.collection === null;\n  const isOverridingVerifiedCollection = !!nftOrSft.collection && !!nftOrSft.collection.verified && !!params.collection && !params.collection.equals(nftOrSft.collection.address);\n  const shouldUnverifyCurrentCollection = isRemovingVerifiedCollection || isOverridingVerifiedCollection;\n  const creatorsInput = params.creators ?? nftOrSft.creators;\n  const verifyAdditionalCreatorInstructions = creatorsInput.filter(creator => {\n    const currentCreator = nftOrSft.creators.find(_ref => {\n      let {\n        address\n      } = _ref;\n      return address.equals(creator.address);\n    });\n    const currentlyVerified = currentCreator?.verified ?? false;\n    return !!creator.authority && !currentlyVerified;\n  }).map(creator => {\n    return metaplex.nfts().builders().verifyCreator({\n      mintAddress: nftOrSft.address,\n      creator: creator.authority\n    }, {\n      payer,\n      programs\n    });\n  });\n  return TransactionBuilder.make().setFeePayer(payer) // Unverify current collection before overriding it.\n  // Otherwise, the previous collection size will not be properly decremented.\n  .when(shouldUnverifyCurrentCollection, builder => builder.add(metaplex.nfts().builders().unverifyCollection({\n    mintAddress: nftOrSft.address,\n    collectionMintAddress: nftOrSft.collection?.address,\n    collectionAuthority: params.oldCollectionAuthority ?? updateAuthority,\n    isSizedCollection: params.oldCollectionIsSized ?? true\n  }, {\n    programs,\n    payer\n  }))) // Update the metadata account.\n  .when(shouldSendUpdateInstruction, builder => builder.add({\n    instruction: createUpdateMetadataAccountV2Instruction({\n      metadata: metaplex.nfts().pdas().metadata({\n        mint: nftOrSft.address,\n        programs\n      }),\n      updateAuthority: updateAuthority.publicKey\n    }, {\n      updateMetadataAccountArgsV2: updateInstructionData\n    }, tokenMetadataProgram.address),\n    signers: [updateAuthority],\n    key: params.updateMetadataInstructionKey ?? 'updateMetadata'\n  })) // Verify additional creators.\n  .add(...verifyAdditionalCreatorInstructions) // Verify collection.\n  .when(!!params.collection && !!params.collectionAuthority, builder => builder.add(metaplex.nfts().builders().verifyCollection({\n    mintAddress: nftOrSft.address,\n    collectionMintAddress: params.collection,\n    collectionAuthority: params.collectionAuthority,\n    isDelegated: params.collectionAuthorityIsDelegated ?? false,\n    isSizedCollection: params.collectionIsSized ?? true\n  }, {\n    programs,\n    payer\n  })));\n};\n\nconst toInstructionData = function (nftOrSft) {\n  let input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const creators = input.creators === undefined ? nftOrSft.creators : input.creators.map(creator => {\n    const currentCreator = nftOrSft.creators.find(_ref2 => {\n      let {\n        address\n      } = _ref2;\n      return address.equals(creator.address);\n    });\n    return { ...creator,\n      verified: currentCreator?.verified ?? false\n    };\n  });\n  const currentCollection = nftOrSft.collection ? { ...nftOrSft.collection,\n    key: nftOrSft.collection.address\n  } : null;\n  const newCollection = input.collection ? {\n    key: input.collection,\n    verified: false\n  } : null;\n  return {\n    updateAuthority: input.newUpdateAuthority ?? null,\n    primarySaleHappened: input.primarySaleHappened ?? null,\n    isMutable: input.isMutable ?? null,\n    data: {\n      name: input.name ?? nftOrSft.name,\n      symbol: input.symbol ?? nftOrSft.symbol,\n      uri: input.uri ?? nftOrSft.uri,\n      sellerFeeBasisPoints: input.sellerFeeBasisPoints ?? nftOrSft.sellerFeeBasisPoints,\n      creators: creators.length > 0 ? creators : null,\n      uses: input.uses === undefined ? nftOrSft.uses : input.uses,\n      collection: input.collection === undefined ? currentCollection : newCollection\n    }\n  };\n};\n\nexport { updateNftBuilder, updateNftOperation, updateNftOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/nftModule/operations/updateNft.ts"],"names":["Key","updateNftOperation","useOperation","updateNftOperationHandler","handle","operation","metaplex","scope","builder","updateNftBuilder","input","isEmpty","NoInstructionsToSendError","sendAndConfirm","confirmOptions","params","options","programs","payer","rpc","getDefaultFeePayer","nftOrSft","updateAuthority","identity","tokenMetadataProgram","getTokenMetadata","updateInstructionDataWithoutChanges","toInstructionData","updateInstructionData","shouldSendUpdateInstruction","isEqual","isRemovingVerifiedCollection","collection","verified","isOverridingVerifiedCollection","equals","address","shouldUnverifyCurrentCollection","creatorsInput","creators","verifyAdditionalCreatorInstructions","filter","creator","currentCreator","find","currentlyVerified","authority","map","nfts","builders","verifyCreator","mintAddress","TransactionBuilder","make","setFeePayer","when","add","unverifyCollection","collectionMintAddress","collectionAuthority","oldCollectionAuthority","isSizedCollection","oldCollectionIsSized","instruction","createUpdateMetadataAccountV2Instruction","metadata","pdas","mint","publicKey","updateMetadataAccountArgsV2","signers","key","updateMetadataInstructionKey","verifyCollection","isDelegated","collectionAuthorityIsDelegated","collectionIsSized","undefined","currentCollection","newCollection","newUpdateAuthority","primarySaleHappened","isMutable","data","name","symbol","uri","sellerFeeBasisPoints","length","uses"],"mappings":"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","sourcesContent":["import {\n  createUpdateMetadataAccountV2Instruction,\n  UpdateMetadataAccountArgsV2,\n  Uses,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport isEqual from 'lodash.isequal';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Sft } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  CreatorInput,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\nimport { NoInstructionsToSendError } from '@/errors';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UpdateNftOperation' as const;\n\n/**\n * Updates an existing NFT or SFT.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .update({ nftOrSft, name: \"My new NFT name\" };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const updateNftOperation = useOperation<UpdateNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UpdateNftOperation = Operation<\n  typeof Key,\n  UpdateNftInput,\n  UpdateNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UpdateNftInput = {\n  /**\n   * The NFT or SFT to update.\n   * We only need a subset of the `Sft` (or `Nft`) model to figure out\n   * the current values for the data of the metadata account and only update\n   * the parts that are different.\n   */\n  nftOrSft: Pick<\n    Sft,\n    | 'address'\n    | 'collection'\n    | 'creators'\n    | 'name'\n    | 'symbol'\n    | 'uri'\n    | 'sellerFeeBasisPoints'\n    | 'uses'\n  >;\n\n  /**\n   * The current update authority of the asset as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The address of the new update authority to set for the asset\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newUpdateAuthority?: PublicKey;\n\n  /**\n   * The new on-chain name of the asset.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  name?: string;\n\n  /**\n   * The new on-chain symbol of the asset.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  symbol?: string;\n\n  /**\n   * The new on-chain uri of the asset.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  uri?: string;\n\n  /**\n   * The new royalties of the asset in percent basis point\n   * (i.e. 250 is 2.5%) that should be paid to the creators\n   * on each secondary sale.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  sellerFeeBasisPoints?: number;\n\n  /**\n   * The new creators for the asset.\n   * For each creator, if an `authority` Signer is provided,\n   * the creator will be marked as verified.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the asset has already been sold to its first buyer.\n   * This can only be flipped from `false` to `true`.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  primarySaleHappened?: boolean;\n\n  /**\n   * Whether or not the asset is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   * This can only be flipped from `true` to `false`.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  isMutable?: boolean;\n\n  /**\n   * When this field is not `null`, it indicates that the asset\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * The new Collection NFT that this asset belongs to.\n   * When `null`, this will remove the asset from its current collection.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the asset\n   * to prove that it is part of the newly provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n\n  /**\n   * Whether or not the newly provided `collection` is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  collectionIsSized?: boolean;\n\n  /**\n   * The authority of the asset's current collection.\n   * This may be required if the current collection is being removed\n   * or updated and needs to be unverified before doing so.\n   *\n   * @defaultValue `updateAuthority`\n   */\n  oldCollectionAuthority?: Signer;\n\n  /**\n   * Whether or not the asset's current collection is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  oldCollectionIsSized?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UpdateNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const updateNftOperationHandler: OperationHandler<UpdateNftOperation> = {\n  handle: async (\n    operation: UpdateNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<UpdateNftOutput> => {\n    const builder = updateNftBuilder(metaplex, operation.input, scope);\n\n    if (builder.isEmpty()) {\n      throw new NoInstructionsToSendError(Key);\n    }\n\n    return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UpdateNftBuilderParams = Omit<UpdateNftInput, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that updates the metadata account. */\n  updateMetadataInstructionKey?: string;\n};\n\n/**\n * Updates an existing NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .update({ nftOrSft, name: \"My new NFT name\" });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const updateNftBuilder = (\n  metaplex: Metaplex,\n  params: UpdateNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { nftOrSft, updateAuthority = metaplex.identity() } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  const updateInstructionDataWithoutChanges = toInstructionData(nftOrSft);\n  const updateInstructionData = toInstructionData(nftOrSft, params);\n  const shouldSendUpdateInstruction = !isEqual(\n    updateInstructionData,\n    updateInstructionDataWithoutChanges\n  );\n\n  const isRemovingVerifiedCollection =\n    !!nftOrSft.collection &&\n    !!nftOrSft.collection.verified &&\n    params.collection === null;\n  const isOverridingVerifiedCollection =\n    !!nftOrSft.collection &&\n    !!nftOrSft.collection.verified &&\n    !!params.collection &&\n    !params.collection.equals(nftOrSft.collection.address);\n  const shouldUnverifyCurrentCollection =\n    isRemovingVerifiedCollection || isOverridingVerifiedCollection;\n\n  const creatorsInput: CreatorInput[] = params.creators ?? nftOrSft.creators;\n  const verifyAdditionalCreatorInstructions = creatorsInput\n    .filter((creator) => {\n      const currentCreator = nftOrSft.creators.find(({ address }) =>\n        address.equals(creator.address)\n      );\n      const currentlyVerified = currentCreator?.verified ?? false;\n      return !!creator.authority && !currentlyVerified;\n    })\n    .map((creator) => {\n      return metaplex.nfts().builders().verifyCreator(\n        {\n          mintAddress: nftOrSft.address,\n          creator: creator.authority,\n        },\n        { payer, programs }\n      );\n    });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Unverify current collection before overriding it.\n      // Otherwise, the previous collection size will not be properly decremented.\n      .when(shouldUnverifyCurrentCollection, (builder) =>\n        builder.add(\n          metaplex\n            .nfts()\n            .builders()\n            .unverifyCollection(\n              {\n                mintAddress: nftOrSft.address,\n                collectionMintAddress: nftOrSft.collection\n                  ?.address as PublicKey,\n                collectionAuthority:\n                  params.oldCollectionAuthority ?? updateAuthority,\n                isSizedCollection: params.oldCollectionIsSized ?? true,\n              },\n              { programs, payer }\n            )\n        )\n      )\n\n      // Update the metadata account.\n      .when(shouldSendUpdateInstruction, (builder) =>\n        builder.add({\n          instruction: createUpdateMetadataAccountV2Instruction(\n            {\n              metadata: metaplex.nfts().pdas().metadata({\n                mint: nftOrSft.address,\n                programs,\n              }),\n              updateAuthority: updateAuthority.publicKey,\n            },\n            { updateMetadataAccountArgsV2: updateInstructionData },\n            tokenMetadataProgram.address\n          ),\n          signers: [updateAuthority],\n          key: params.updateMetadataInstructionKey ?? 'updateMetadata',\n        })\n      )\n\n      // Verify additional creators.\n      .add(...verifyAdditionalCreatorInstructions)\n\n      // Verify collection.\n      .when(!!params.collection && !!params.collectionAuthority, (builder) =>\n        builder.add(\n          metaplex\n            .nfts()\n            .builders()\n            .verifyCollection(\n              {\n                mintAddress: nftOrSft.address,\n                collectionMintAddress: params.collection as PublicKey,\n                collectionAuthority: params.collectionAuthority as Signer,\n                isDelegated: params.collectionAuthorityIsDelegated ?? false,\n                isSizedCollection: params.collectionIsSized ?? true,\n              },\n              { programs, payer }\n            )\n        )\n      )\n  );\n};\n\nconst toInstructionData = (\n  nftOrSft: Pick<\n    Sft,\n    | 'address'\n    | 'collection'\n    | 'creators'\n    | 'name'\n    | 'symbol'\n    | 'uri'\n    | 'sellerFeeBasisPoints'\n    | 'uses'\n  >,\n  input: Partial<UpdateNftInput> = {}\n): UpdateMetadataAccountArgsV2 => {\n  const creators =\n    input.creators === undefined\n      ? nftOrSft.creators\n      : input.creators.map((creator) => {\n          const currentCreator = nftOrSft.creators.find(({ address }) =>\n            address.equals(creator.address)\n          );\n          return {\n            ...creator,\n            verified: currentCreator?.verified ?? false,\n          };\n        });\n\n  const currentCollection = nftOrSft.collection\n    ? { ...nftOrSft.collection, key: nftOrSft.collection.address }\n    : null;\n  const newCollection = input.collection\n    ? { key: input.collection, verified: false }\n    : null;\n\n  return {\n    updateAuthority: input.newUpdateAuthority ?? null,\n    primarySaleHappened: input.primarySaleHappened ?? null,\n    isMutable: input.isMutable ?? null,\n    data: {\n      name: input.name ?? nftOrSft.name,\n      symbol: input.symbol ?? nftOrSft.symbol,\n      uri: input.uri ?? nftOrSft.uri,\n      sellerFeeBasisPoints:\n        input.sellerFeeBasisPoints ?? nftOrSft.sellerFeeBasisPoints,\n      creators: creators.length > 0 ? creators : null,\n      uses: input.uses === undefined ? nftOrSft.uses : input.uses,\n      collection:\n        input.collection === undefined ? currentCollection : newCollection,\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"module"}