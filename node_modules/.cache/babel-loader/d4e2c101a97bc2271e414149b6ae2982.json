{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapsTypeMap = exports.map = void 0;\n\nconst types_1 = require(\"../types\");\n\nconst numbers_1 = require(\"./numbers\");\n\nconst utils_1 = require(\"../utils\");\n\nconst assert_1 = require(\"assert\");\n/**\n * De/Serializes a map with a specific number of key/values of type {@link K}\n * and {@link V} respectively.\n *\n * NOTE: that it is not exported as no fixed size map exists but will have to\n * be derived from data or value instead.\n *\n * @template K type of key elements held in the map\n * @template V type of value elements held in the map\n *\n * @param keyElement the De/Serializers for the key element types\n * @param valElement the De/Serializers for the value element types\n * @param len amount of entries in the map\n *\n * @category beet/composite\n * @private\n */\n\n\nfunction fixedSizeMap(keyElement, valElement, fixedElements, len) {\n  const keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n  const valElementFixed = (0, types_1.isFixedSizeBeet)(valElement);\n\n  function determineSizes() {\n    if (keyElementFixed && valElementFixed) {\n      const elementByteSize = keyElement.byteSize + valElement.byteSize;\n      return {\n        elementByteSize,\n        byteSize: 4 + len * elementByteSize\n      };\n    } else if (keyElementFixed) {\n      let valsByteSize = 0;\n\n      for (const [_, v] of fixedElements.values()) {\n        valsByteSize += v.byteSize;\n      } // If any element has a dynamic size all we can do here is take an average\n\n\n      const elementByteSize = keyElement.byteSize + Math.ceil(valsByteSize / len);\n      return {\n        elementByteSize,\n        byteSize: 4 + keyElement.byteSize * len + valsByteSize\n      };\n    } else if (valElementFixed) {\n      let keysByteSize = 0;\n\n      for (const [k, _] of fixedElements.values()) {\n        keysByteSize += k.byteSize;\n      }\n\n      const elementByteSize = Math.ceil(keysByteSize / len) + valElement.byteSize;\n      return {\n        elementByteSize,\n        byteSize: 4 + keysByteSize + valElement.byteSize * len\n      };\n    } else {\n      let keysByteSize = 0;\n      let valsByteSize = 0;\n\n      for (const [k, v] of fixedElements.values()) {\n        keysByteSize += k.byteSize;\n        valsByteSize += v.byteSize;\n      }\n\n      const elementByteSize = Math.ceil(keysByteSize / len + valsByteSize / len);\n      return {\n        elementByteSize,\n        byteSize: 4 + keysByteSize + valsByteSize\n      };\n    }\n  }\n\n  const {\n    elementByteSize,\n    byteSize\n  } = determineSizes();\n  return {\n    write: function (buf, offset, map) {\n      // Write the values first and then the size as it comes clear while we do the former\n      let cursor = offset + 4;\n      let size = 0;\n\n      for (const [k, v] of map.entries()) {\n        let fixedKey = keyElementFixed ? keyElement : null;\n        let fixedVal = valElementFixed ? valElement : null;\n\n        if (fixedKey == null || fixedVal == null) {\n          // When we write the value we know the key and an just pull the\n          // matching fixed beet for key/val from the provided map which is\n          // faster than fixing it by value\n          const els = fixedElements.get(k);\n          (0, assert_1.strict)(els != null, `Should be able to find beet els for ${(0, utils_1.stringify)(k)}, but could not`);\n          fixedKey !== null && fixedKey !== void 0 ? fixedKey : fixedKey = els[0];\n          fixedVal !== null && fixedVal !== void 0 ? fixedVal : fixedVal = els[1];\n        }\n\n        fixedKey.write(buf, cursor, k);\n        cursor += fixedKey.byteSize;\n        fixedVal.write(buf, cursor, v);\n        cursor += fixedVal.byteSize;\n        size++;\n      }\n\n      numbers_1.u32.write(buf, offset, size);\n      assert_1.strict.equal(size, len, `Expected map to have size ${len}, but has ${size}.`);\n    },\n    read: function (buf, offset) {\n      const size = numbers_1.u32.read(buf, offset);\n      assert_1.strict.equal(size, len, `Expected map to have size ${len}, but has ${size}.`);\n      let cursor = offset + 4;\n      const map = new Map();\n\n      for (let i = 0; i < size; i++) {\n        // When we read the value from a buffer we don't know the key we're\n        // reading yet and thus cannot use the provided map of fixed\n        // de/serializers.\n        // Therefore we obtain it by fixing it by data instead.\n        const fixedKey = keyElementFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n        const k = fixedKey.read(buf, cursor);\n        cursor += fixedKey.byteSize;\n        const fixedVal = valElementFixed ? valElement : valElement.toFixedFromData(buf, cursor);\n        const v = fixedVal.read(buf, cursor);\n        cursor += fixedVal.byteSize;\n        map.set(k, v);\n      }\n\n      return map;\n    },\n    elementByteSize,\n    byteSize,\n    length: len,\n    lenPrefixByteSize: 4,\n    description: `Map<${keyElement.description}, ${valElement.description}>`\n  };\n}\n/**\n * De/Serializes a map with a specific number of key/values of type {@link K}\n * and {@link V} respectively.\n *\n * @template K type of key elements held in the map\n * @template V type of value elements held in the map\n *\n * @param keyElement the _fixable_ or _fixed_ de/serializers for the key element types\n * @param valElement the _fixable_ or _fixed_ de/serializers for the value element types\n *\n * @category beet/composite\n */\n\n\nfunction map(keyElement, valElement) {\n  const keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n  const valIsFixed = (0, types_1.isFixedSizeBeet)(valElement);\n  return {\n    toFixedFromData(buf, offset) {\n      const len = numbers_1.u32.read(buf, offset);\n      let cursor = offset + 4; // Shortcut for the case that both key and value are fixed size beets\n\n      if (keyIsFixed && valIsFixed) {\n        return fixedSizeMap(keyElement, valElement, new Map(), len);\n      } // If either key or val are not fixed size beets we need to determine the\n      // fixed versions and add them to a map by key\n\n\n      const fixedBeets = new Map();\n\n      for (let i = 0; i < len; i++) {\n        const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n        const key = keyFixed.read(buf, cursor);\n        cursor += keyFixed.byteSize;\n        const valFixed = valIsFixed ? valElement : valElement.toFixedFromData(buf, cursor);\n        cursor += valFixed.byteSize;\n        fixedBeets.set(key, [keyFixed, valFixed]);\n      }\n\n      return fixedSizeMap(keyElement, valElement, fixedBeets, len);\n    },\n\n    toFixedFromValue(mapVal) {\n      const len = mapVal.size; // As above shortcut for the optimal case and build a map for all others\n\n      if (keyIsFixed && valIsFixed) {\n        return fixedSizeMap(keyElement, valElement, new Map(), len);\n      }\n\n      const fixedBeets = new Map();\n\n      for (const [k, v] of mapVal) {\n        const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromValue(k);\n        const valFixed = valIsFixed ? valElement : valElement.toFixedFromValue(v);\n        fixedBeets.set(k, [keyFixed, valFixed]);\n      }\n\n      return fixedSizeMap(keyElement, valElement, fixedBeets, len);\n    },\n\n    description: `FixableMap<${keyElement.description}, ${valElement.description}>`\n  };\n}\n\nexports.map = map;\n/**\n * Maps maps beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexports.mapsTypeMap = {\n  Map: {\n    beet: 'map',\n    isFixable: true,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: 'Map'\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/maps.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapsTypeMap = exports.map = void 0;\nconst types_1 = require(\"../types\");\nconst numbers_1 = require(\"./numbers\");\nconst utils_1 = require(\"../utils\");\nconst assert_1 = require(\"assert\");\n/**\n * De/Serializes a map with a specific number of key/values of type {@link K}\n * and {@link V} respectively.\n *\n * NOTE: that it is not exported as no fixed size map exists but will have to\n * be derived from data or value instead.\n *\n * @template K type of key elements held in the map\n * @template V type of value elements held in the map\n *\n * @param keyElement the De/Serializers for the key element types\n * @param valElement the De/Serializers for the value element types\n * @param len amount of entries in the map\n *\n * @category beet/composite\n * @private\n */\nfunction fixedSizeMap(keyElement, valElement, fixedElements, len) {\n    const keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n    const valElementFixed = (0, types_1.isFixedSizeBeet)(valElement);\n    function determineSizes() {\n        if (keyElementFixed && valElementFixed) {\n            const elementByteSize = keyElement.byteSize + valElement.byteSize;\n            return {\n                elementByteSize,\n                byteSize: 4 + len * elementByteSize,\n            };\n        }\n        else if (keyElementFixed) {\n            let valsByteSize = 0;\n            for (const [_, v] of fixedElements.values()) {\n                valsByteSize += v.byteSize;\n            }\n            // If any element has a dynamic size all we can do here is take an average\n            const elementByteSize = keyElement.byteSize + Math.ceil(valsByteSize / len);\n            return {\n                elementByteSize,\n                byteSize: 4 + keyElement.byteSize * len + valsByteSize,\n            };\n        }\n        else if (valElementFixed) {\n            let keysByteSize = 0;\n            for (const [k, _] of fixedElements.values()) {\n                keysByteSize += k.byteSize;\n            }\n            const elementByteSize = Math.ceil(keysByteSize / len) + valElement.byteSize;\n            return {\n                elementByteSize,\n                byteSize: 4 + keysByteSize + valElement.byteSize * len,\n            };\n        }\n        else {\n            let keysByteSize = 0;\n            let valsByteSize = 0;\n            for (const [k, v] of fixedElements.values()) {\n                keysByteSize += k.byteSize;\n                valsByteSize += v.byteSize;\n            }\n            const elementByteSize = Math.ceil(keysByteSize / len + valsByteSize / len);\n            return {\n                elementByteSize,\n                byteSize: 4 + keysByteSize + valsByteSize,\n            };\n        }\n    }\n    const { elementByteSize, byteSize } = determineSizes();\n    return {\n        write: function (buf, offset, map) {\n            // Write the values first and then the size as it comes clear while we do the former\n            let cursor = offset + 4;\n            let size = 0;\n            for (const [k, v] of map.entries()) {\n                let fixedKey = keyElementFixed ? keyElement : null;\n                let fixedVal = valElementFixed ? valElement : null;\n                if (fixedKey == null || fixedVal == null) {\n                    // When we write the value we know the key and an just pull the\n                    // matching fixed beet for key/val from the provided map which is\n                    // faster than fixing it by value\n                    const els = fixedElements.get(k);\n                    (0, assert_1.strict)(els != null, `Should be able to find beet els for ${(0, utils_1.stringify)(k)}, but could not`);\n                    fixedKey !== null && fixedKey !== void 0 ? fixedKey : (fixedKey = els[0]);\n                    fixedVal !== null && fixedVal !== void 0 ? fixedVal : (fixedVal = els[1]);\n                }\n                fixedKey.write(buf, cursor, k);\n                cursor += fixedKey.byteSize;\n                fixedVal.write(buf, cursor, v);\n                cursor += fixedVal.byteSize;\n                size++;\n            }\n            numbers_1.u32.write(buf, offset, size);\n            assert_1.strict.equal(size, len, `Expected map to have size ${len}, but has ${size}.`);\n        },\n        read: function (buf, offset) {\n            const size = numbers_1.u32.read(buf, offset);\n            assert_1.strict.equal(size, len, `Expected map to have size ${len}, but has ${size}.`);\n            let cursor = offset + 4;\n            const map = new Map();\n            for (let i = 0; i < size; i++) {\n                // When we read the value from a buffer we don't know the key we're\n                // reading yet and thus cannot use the provided map of fixed\n                // de/serializers.\n                // Therefore we obtain it by fixing it by data instead.\n                const fixedKey = keyElementFixed\n                    ? keyElement\n                    : keyElement.toFixedFromData(buf, cursor);\n                const k = fixedKey.read(buf, cursor);\n                cursor += fixedKey.byteSize;\n                const fixedVal = valElementFixed\n                    ? valElement\n                    : valElement.toFixedFromData(buf, cursor);\n                const v = fixedVal.read(buf, cursor);\n                cursor += fixedVal.byteSize;\n                map.set(k, v);\n            }\n            return map;\n        },\n        elementByteSize,\n        byteSize,\n        length: len,\n        lenPrefixByteSize: 4,\n        description: `Map<${keyElement.description}, ${valElement.description}>`,\n    };\n}\n/**\n * De/Serializes a map with a specific number of key/values of type {@link K}\n * and {@link V} respectively.\n *\n * @template K type of key elements held in the map\n * @template V type of value elements held in the map\n *\n * @param keyElement the _fixable_ or _fixed_ de/serializers for the key element types\n * @param valElement the _fixable_ or _fixed_ de/serializers for the value element types\n *\n * @category beet/composite\n */\nfunction map(keyElement, valElement) {\n    const keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n    const valIsFixed = (0, types_1.isFixedSizeBeet)(valElement);\n    return {\n        toFixedFromData(buf, offset) {\n            const len = numbers_1.u32.read(buf, offset);\n            let cursor = offset + 4;\n            // Shortcut for the case that both key and value are fixed size beets\n            if (keyIsFixed && valIsFixed) {\n                return fixedSizeMap(keyElement, valElement, new Map(), len);\n            }\n            // If either key or val are not fixed size beets we need to determine the\n            // fixed versions and add them to a map by key\n            const fixedBeets = new Map();\n            for (let i = 0; i < len; i++) {\n                const keyFixed = keyIsFixed\n                    ? keyElement\n                    : keyElement.toFixedFromData(buf, cursor);\n                const key = keyFixed.read(buf, cursor);\n                cursor += keyFixed.byteSize;\n                const valFixed = valIsFixed\n                    ? valElement\n                    : valElement.toFixedFromData(buf, cursor);\n                cursor += valFixed.byteSize;\n                fixedBeets.set(key, [keyFixed, valFixed]);\n            }\n            return fixedSizeMap(keyElement, valElement, fixedBeets, len);\n        },\n        toFixedFromValue(mapVal) {\n            const len = mapVal.size;\n            // As above shortcut for the optimal case and build a map for all others\n            if (keyIsFixed && valIsFixed) {\n                return fixedSizeMap(keyElement, valElement, new Map(), len);\n            }\n            const fixedBeets = new Map();\n            for (const [k, v] of mapVal) {\n                const keyFixed = keyIsFixed\n                    ? keyElement\n                    : keyElement.toFixedFromValue(k);\n                const valFixed = valIsFixed\n                    ? valElement\n                    : valElement.toFixedFromValue(v);\n                fixedBeets.set(k, [keyFixed, valFixed]);\n            }\n            return fixedSizeMap(keyElement, valElement, fixedBeets, len);\n        },\n        description: `FixableMap<${keyElement.description}, ${valElement.description}>`,\n    };\n}\nexports.map = map;\n/**\n * Maps maps beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.mapsTypeMap = {\n    Map: {\n        beet: 'map',\n        isFixable: true,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: 'Map',\n    },\n};\n//# sourceMappingURL=maps.js.map"]},"metadata":{},"sourceType":"script"}