{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fixBeetFromValue = exports.fixBeetFromData = void 0;\n\nconst types_1 = require(\"./types\");\n\nconst utils_1 = require(\"./utils\");\n/**\n * Converts the provided beet into a {@link FixedBeet} unless it already is.\n * The sizes for {@link FixableBeet}s are determined from the provided data.\n *\n * @param beet to convert\n * @param buf containing serialized data that the fixed beet needs to process\n * @param offset at which the data for the beet starts\n *\n * @category beet\n */\n\n\nfunction fixBeetFromData(beet, buf, offset) {\n  if ((0, types_1.isFixedSizeBeet)(beet)) {\n    return beet;\n  }\n\n  if ((0, types_1.isFixableBeet)(beet)) {\n    return beet.toFixedFromData(buf, offset);\n  }\n\n  throw new utils_1.UnreachableCaseError(beet);\n}\n\nexports.fixBeetFromData = fixBeetFromData;\n/**\n * Converts the provided beet into a {@link FixedBeet} unless it already is.\n * The sizes for {@link FixableBeet}s are determined from the provided value.\n *\n * @param beet to convert\n * @param val value that the fixed beet needs to process\n *\n * @category beet\n */\n\nfunction fixBeetFromValue(beet, val) {\n  if ((0, types_1.isFixedSizeBeet)(beet)) {\n    return beet;\n  }\n\n  if ((0, types_1.isFixableBeet)(beet)) {\n    return beet.toFixedFromValue(val);\n  }\n\n  throw new utils_1.UnreachableCaseError(beet);\n}\n\nexports.fixBeetFromValue = fixBeetFromValue;","map":{"version":3,"sources":["../../../src/beet.fixable.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;;;;;;;;AASG;;;AACH,SAAgB,eAAhB,CACE,IADF,EAEE,GAFF,EAGE,MAHF,EAGgB;EAEd,IAAI,CAAA,GAAA,OAAA,CAAA,eAAA,EAAgB,IAAhB,CAAJ,EAA2B;IACzB,OAAO,IAAP;EACD;;EACD,IAAI,CAAA,GAAA,OAAA,CAAA,aAAA,EAAc,IAAd,CAAJ,EAAyB;IACvB,OAAO,IAAI,CAAC,eAAL,CAAqB,GAArB,EAA0B,MAA1B,CAAP;EACD;;EACD,MAAM,IAAI,OAAA,CAAA,oBAAJ,CAAyB,IAAzB,CAAN;AACD;;AAZD,OAAA,CAAA,eAAA,GAAA,eAAA;AAcA;;;;;;;;AAQG;;AACH,SAAgB,gBAAhB,CACE,IADF,EAEE,GAFF,EAEQ;EAEN,IAAI,CAAA,GAAA,OAAA,CAAA,eAAA,EAAsB,IAAtB,CAAJ,EAAiC;IAC/B,OAAO,IAAP;EACD;;EACD,IAAI,CAAA,GAAA,OAAA,CAAA,aAAA,EAAc,IAAd,CAAJ,EAAyB;IACvB,OAAO,IAAI,CAAC,gBAAL,CAAsB,GAAtB,CAAP;EACD;;EACD,MAAM,IAAI,OAAA,CAAA,oBAAJ,CAAyB,IAAzB,CAAN;AACD;;AAXD,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fixBeetFromValue = exports.fixBeetFromData = void 0;\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\n/**\n * Converts the provided beet into a {@link FixedBeet} unless it already is.\n * The sizes for {@link FixableBeet}s are determined from the provided data.\n *\n * @param beet to convert\n * @param buf containing serialized data that the fixed beet needs to process\n * @param offset at which the data for the beet starts\n *\n * @category beet\n */\nfunction fixBeetFromData(beet, buf, offset) {\n    if ((0, types_1.isFixedSizeBeet)(beet)) {\n        return beet;\n    }\n    if ((0, types_1.isFixableBeet)(beet)) {\n        return beet.toFixedFromData(buf, offset);\n    }\n    throw new utils_1.UnreachableCaseError(beet);\n}\nexports.fixBeetFromData = fixBeetFromData;\n/**\n * Converts the provided beet into a {@link FixedBeet} unless it already is.\n * The sizes for {@link FixableBeet}s are determined from the provided value.\n *\n * @param beet to convert\n * @param val value that the fixed beet needs to process\n *\n * @category beet\n */\nfunction fixBeetFromValue(beet, val) {\n    if ((0, types_1.isFixedSizeBeet)(beet)) {\n        return beet;\n    }\n    if ((0, types_1.isFixableBeet)(beet)) {\n        return beet.toFixedFromValue(val);\n    }\n    throw new utils_1.UnreachableCaseError(beet);\n}\nexports.fixBeetFromValue = fixBeetFromValue;\n//# sourceMappingURL=beet.fixable.js.map"]},"metadata":{},"sourceType":"script"}