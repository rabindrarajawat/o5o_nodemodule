{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _AppReadyEvent_detail;\n\nlet wallets = undefined;\nconst registered = new Set();\nconst listeners = {};\n/**\n * Get an API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and\n * {@link Wallets.register | registering} {@link \"@wallet-standard/base\".Wallet | Wallets}.\n *\n * When called for the first time --\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowAppReadyEvent} to notify each Wallet that the app is ready\n * to register it.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to listen for a notification\n * from each Wallet that the Wallet is ready to be registered by the app.\n *\n * This combination of event dispatch and listener guarantees that each Wallet will be registered synchronously as soon\n * as the app is ready whether the app loads before or after each Wallet.\n *\n * @return API for getting, listening for, and registering Wallets.\n *\n * @group App\n */\n\nexport function getWallets() {\n  if (wallets) return wallets;\n  wallets = Object.freeze({\n    register: register,\n    get: get,\n    on: on\n  });\n  if (typeof window === 'undefined') return wallets;\n  const api = Object.freeze({\n    register: register\n  });\n\n  try {\n    window.addEventListener('wallet-standard:register-wallet', _ref => {\n      let {\n        detail: callback\n      } = _ref;\n      return callback(api);\n    });\n  } catch (error) {\n    console.error('wallet-standard:register-wallet event listener could not be added\\n', error);\n  }\n\n  try {\n    window.dispatchEvent(new AppReadyEvent(api));\n  } catch (error) {\n    console.error('wallet-standard:app-ready event could not be dispatched\\n', error);\n  }\n\n  return wallets;\n}\n\nfunction register() {\n  var _listeners$register;\n\n  for (var _len = arguments.length, wallets = new Array(_len), _key = 0; _key < _len; _key++) {\n    wallets[_key] = arguments[_key];\n  }\n\n  // Filter out wallets that have already been registered.\n  // This prevents the same wallet from being registered twice, but it also prevents wallets from being\n  // unregistered by reusing a reference to the wallet to obtain the unregister function for it.\n  wallets = wallets.filter(wallet => !registered.has(wallet)); // If there are no new wallets to register, just return a no-op unregister function.\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n  if (!wallets.length) return () => {};\n  wallets.forEach(wallet => registered.add(wallet));\n  (_listeners$register = listeners['register']) === null || _listeners$register === void 0 ? void 0 : _listeners$register.forEach(listener => guard(() => listener(...wallets))); // Return a function that unregisters the registered wallets.\n\n  return function unregister() {\n    var _listeners$unregister;\n\n    wallets.forEach(wallet => registered.delete(wallet));\n    (_listeners$unregister = listeners['unregister']) === null || _listeners$unregister === void 0 ? void 0 : _listeners$unregister.forEach(listener => guard(() => listener(...wallets)));\n  };\n}\n\nfunction get() {\n  return [...registered];\n}\n\nfunction on(event, listener) {\n  var _listeners$event;\n\n  ((_listeners$event = listeners[event]) === null || _listeners$event === void 0 ? void 0 : _listeners$event.push(listener)) || (listeners[event] = [listener]); // Return a function that removes the event listener.\n\n  return function off() {\n    var _listeners$event2;\n\n    listeners[event] = (_listeners$event2 = listeners[event]) === null || _listeners$event2 === void 0 ? void 0 : _listeners$event2.filter(existingListener => listener !== existingListener);\n  };\n}\n\nfunction guard(callback) {\n  try {\n    callback();\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nclass AppReadyEvent extends Event {\n  constructor(api) {\n    super('wallet-standard:app-ready', {\n      bubbles: false,\n      cancelable: false,\n      composed: false\n    });\n\n    _AppReadyEvent_detail.set(this, void 0);\n\n    __classPrivateFieldSet(this, _AppReadyEvent_detail, api, \"f\");\n  }\n\n  get detail() {\n    return __classPrivateFieldGet(this, _AppReadyEvent_detail, \"f\");\n  }\n\n  get type() {\n    return 'wallet-standard:app-ready';\n  }\n  /** @deprecated */\n\n\n  preventDefault() {\n    throw new Error('preventDefault cannot be called');\n  }\n  /** @deprecated */\n\n\n  stopImmediatePropagation() {\n    throw new Error('stopImmediatePropagation cannot be called');\n  }\n  /** @deprecated */\n\n\n  stopPropagation() {\n    throw new Error('stopPropagation cannot be called');\n  }\n\n}\n\n_AppReadyEvent_detail = new WeakMap();\n/**\n * @deprecated Use {@link getWallets} instead.\n *\n * @group Deprecated\n */\n\nexport function DEPRECATED_getWallets() {\n  if (wallets) return wallets;\n  wallets = getWallets();\n  if (typeof window === 'undefined') return wallets;\n  const callbacks = window.navigator.wallets || [];\n\n  if (!Array.isArray(callbacks)) {\n    console.error('window.navigator.wallets is not an array');\n    return wallets;\n  }\n\n  const {\n    register: register\n  } = wallets;\n\n  const push = function () {\n    for (var _len2 = arguments.length, callbacks = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      callbacks[_key2] = arguments[_key2];\n    }\n\n    return callbacks.forEach(callback => guard(() => callback({\n      register: register\n    })));\n  };\n\n  try {\n    Object.defineProperty(window.navigator, 'wallets', {\n      value: Object.freeze({\n        push: push\n      })\n    });\n  } catch (error) {\n    console.error('window.navigator.wallets could not be set');\n    return wallets;\n  }\n\n  push(...callbacks);\n  return wallets;\n}","map":{"version":3,"sources":["../../src/wallets.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AppReadyEvent_detail;\nlet wallets = undefined;\nconst registered = new Set();\nconst listeners = {};\n/**\n * Get an API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and\n * {@link Wallets.register | registering} {@link \"@wallet-standard/base\".Wallet | Wallets}.\n *\n * When called for the first time --\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowAppReadyEvent} to notify each Wallet that the app is ready\n * to register it.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to listen for a notification\n * from each Wallet that the Wallet is ready to be registered by the app.\n *\n * This combination of event dispatch and listener guarantees that each Wallet will be registered synchronously as soon\n * as the app is ready whether the app loads before or after each Wallet.\n *\n * @return API for getting, listening for, and registering Wallets.\n *\n * @group App\n */\nexport function getWallets() {\n    if (wallets)\n        return wallets;\n    wallets = Object.freeze({ register, get, on });\n    if (typeof window === 'undefined')\n        return wallets;\n    const api = Object.freeze({ register });\n    try {\n        window.addEventListener('wallet-standard:register-wallet', ({ detail: callback }) => callback(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:register-wallet event listener could not be added\\n', error);\n    }\n    try {\n        window.dispatchEvent(new AppReadyEvent(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:app-ready event could not be dispatched\\n', error);\n    }\n    return wallets;\n}\nfunction register(...wallets) {\n    // Filter out wallets that have already been registered.\n    // This prevents the same wallet from being registered twice, but it also prevents wallets from being\n    // unregistered by reusing a reference to the wallet to obtain the unregister function for it.\n    wallets = wallets.filter((wallet) => !registered.has(wallet));\n    // If there are no new wallets to register, just return a no-op unregister function.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    if (!wallets.length)\n        return () => { };\n    wallets.forEach((wallet) => registered.add(wallet));\n    listeners['register']?.forEach((listener) => guard(() => listener(...wallets)));\n    // Return a function that unregisters the registered wallets.\n    return function unregister() {\n        wallets.forEach((wallet) => registered.delete(wallet));\n        listeners['unregister']?.forEach((listener) => guard(() => listener(...wallets)));\n    };\n}\nfunction get() {\n    return [...registered];\n}\nfunction on(event, listener) {\n    listeners[event]?.push(listener) || (listeners[event] = [listener]);\n    // Return a function that removes the event listener.\n    return function off() {\n        listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener);\n    };\n}\nfunction guard(callback) {\n    try {\n        callback();\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\nclass AppReadyEvent extends Event {\n    constructor(api) {\n        super('wallet-standard:app-ready', {\n            bubbles: false,\n            cancelable: false,\n            composed: false,\n        });\n        _AppReadyEvent_detail.set(this, void 0);\n        __classPrivateFieldSet(this, _AppReadyEvent_detail, api, \"f\");\n    }\n    get detail() {\n        return __classPrivateFieldGet(this, _AppReadyEvent_detail, \"f\");\n    }\n    get type() {\n        return 'wallet-standard:app-ready';\n    }\n    /** @deprecated */\n    preventDefault() {\n        throw new Error('preventDefault cannot be called');\n    }\n    /** @deprecated */\n    stopImmediatePropagation() {\n        throw new Error('stopImmediatePropagation cannot be called');\n    }\n    /** @deprecated */\n    stopPropagation() {\n        throw new Error('stopPropagation cannot be called');\n    }\n}\n_AppReadyEvent_detail = new WeakMap();\n/**\n * @deprecated Use {@link getWallets} instead.\n *\n * @group Deprecated\n */\nexport function DEPRECATED_getWallets() {\n    if (wallets)\n        return wallets;\n    wallets = getWallets();\n    if (typeof window === 'undefined')\n        return wallets;\n    const callbacks = window.navigator.wallets || [];\n    if (!Array.isArray(callbacks)) {\n        console.error('window.navigator.wallets is not an array');\n        return wallets;\n    }\n    const { register } = wallets;\n    const push = (...callbacks) => callbacks.forEach((callback) => guard(() => callback({ register })));\n    try {\n        Object.defineProperty(window.navigator, 'wallets', {\n            value: Object.freeze({ push }),\n        });\n    }\n    catch (error) {\n        console.error('window.navigator.wallets could not be set');\n        return wallets;\n    }\n    push(...callbacks);\n    return wallets;\n}\n//# sourceMappingURL=wallets.js.map"]},"metadata":{},"sourceType":"module"}