{"ast":null,"code":"import { createCreateMetadataAccountV3Instruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair } from '@solana/web3.js';\nimport { assertSft } from '../models/Sft.mjs';\nimport { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { toPublicKey } from '../../../types/PublicKey.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs';\nimport { isSigner } from '../../../types/Signer.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateSftOperation';\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const { sft } = await metaplex\n *   .nfts()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst createSftOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst createSftOperationHandler = {\n  handle: async (operation, metaplex, scope) => {\n    const {\n      useNewMint = Keypair.generate(),\n      useExistingMint,\n      tokenOwner,\n      tokenAddress: tokenSigner\n    } = operation.input;\n    const mintAddress = useExistingMint ?? useNewMint.publicKey;\n    const associatedTokenAddress = tokenOwner ? metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: tokenOwner,\n      programs: scope.programs\n    }) : null;\n    const tokenAddress = tokenSigner ? toPublicKey(tokenSigner) : associatedTokenAddress;\n    let tokenExists;\n\n    if (!!useExistingMint && !!tokenAddress) {\n      const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);\n      tokenExists = tokenAccount.exists;\n    } else {\n      tokenExists = false;\n    }\n\n    const builder = await createSftBuilder(metaplex, { ...operation.input,\n      useNewMint,\n      tokenExists\n    }, scope);\n    scope.throwIfCanceled();\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n    const sft = await metaplex.nfts().findByMint({\n      mintAddress: output.mintAddress,\n      tokenAddress: output.tokenAddress ?? undefined\n    }, scope);\n    scope.throwIfCanceled();\n    assertSft(sft);\n    return { ...output,\n      sft\n    };\n  }\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst createSftBuilder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    useNewMint = Keypair.generate(),\n    updateAuthority = metaplex.identity(),\n    mintAuthority = metaplex.identity()\n  } = params;\n  const mintAndTokenBuilder = await createMintAndTokenForSftBuilder(metaplex, params, {\n    programs,\n    payer\n  }, useNewMint);\n  const {\n    mintAddress,\n    tokenAddress\n  } = mintAndTokenBuilder.getContext();\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const metadataPda = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs\n  });\n  const creatorsInput = params.creators ?? [{\n    address: updateAuthority.publicKey,\n    authority: updateAuthority,\n    share: 100\n  }];\n  const creators = creatorsInput.length > 0 ? creatorsInput.map(creator => ({ ...creator,\n    verified: creator.address.equals(updateAuthority.publicKey)\n  })) : null;\n  const createMetadataInstruction = createCreateMetadataAccountV3Instruction({\n    metadata: metadataPda,\n    mint: mintAddress,\n    mintAuthority: mintAuthority.publicKey,\n    payer: payer.publicKey,\n    updateAuthority: updateAuthority.publicKey\n  }, {\n    createMetadataAccountArgsV3: {\n      data: {\n        name: params.name,\n        symbol: params.symbol ?? '',\n        uri: params.uri,\n        sellerFeeBasisPoints: params.sellerFeeBasisPoints,\n        creators,\n        collection: params.collection ? {\n          key: params.collection,\n          verified: false\n        } : null,\n        uses: params.uses ?? null\n      },\n      isMutable: params.isMutable ?? true,\n      collectionDetails: params.isCollection ? {\n        __kind: 'V1',\n        size: 0\n      } // Program will hardcode size to zero anyway.\n      : null\n    }\n  }, tokenMetadataProgram.address); // When the payer is different than the update authority, the latter will\n  // not be marked as a signer and therefore signing as a creator will fail.\n\n  createMetadataInstruction.keys[4].isSigner = true;\n  const verifyAdditionalCreatorInstructions = creatorsInput.filter(creator => {\n    return !!creator.authority && !creator.address.equals(updateAuthority.publicKey);\n  }).map(creator => {\n    return metaplex.nfts().builders().verifyCreator({\n      mintAddress,\n      creator: creator.authority\n    }, {\n      programs,\n      payer\n    });\n  });\n  return TransactionBuilder.make().setFeePayer(payer).setContext({\n    mintAddress,\n    metadataAddress: metadataPda,\n    tokenAddress\n  }) // Create the mint and token accounts before minting 1 token to the owner.\n  .add(mintAndTokenBuilder) // Create metadata account.\n  .add({\n    instruction: createMetadataInstruction,\n    signers: [payer, mintAuthority, updateAuthority],\n    key: params.createMetadataInstructionKey ?? 'createMetadata'\n  }) // Verify additional creators.\n  .add(...verifyAdditionalCreatorInstructions) // Verify collection.\n  .when(!!params.collection && !!params.collectionAuthority, builder => builder.add(metaplex.nfts().builders().verifyCollection({\n    mintAddress,\n    collectionMintAddress: params.collection,\n    collectionAuthority: params.collectionAuthority,\n    isDelegated: params.collectionAuthorityIsDelegated ?? false,\n    isSizedCollection: params.collectionIsSized ?? true\n  }, {\n    payer,\n    programs\n  })));\n};\n\nconst createMintAndTokenForSftBuilder = async (metaplex, params, options, useNewMint) => {\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    mintAuthority = metaplex.identity(),\n    freezeAuthority = metaplex.identity().publicKey,\n    tokenExists = false\n  } = params;\n  const mintAddress = params.useExistingMint ?? useNewMint.publicKey;\n  const associatedTokenAddress = params.tokenOwner ? metaplex.tokens().pdas().associatedTokenAccount({\n    mint: mintAddress,\n    owner: params.tokenOwner,\n    programs\n  }) : null;\n  const tokenAddress = params.tokenAddress ? toPublicKey(params.tokenAddress) : associatedTokenAddress;\n  const builder = TransactionBuilder.make().setFeePayer(payer).setContext({\n    mintAddress,\n    tokenAddress\n  }); // Create the mint account if it doesn't exist.\n\n  if (!params.useExistingMint) {\n    builder.add(await metaplex.tokens().builders().createMint({\n      decimals: params.decimals ?? 0,\n      mint: useNewMint,\n      mintAuthority: mintAuthority.publicKey,\n      freezeAuthority,\n      createAccountInstructionKey: params.createMintAccountInstructionKey,\n      initializeMintInstructionKey: params.initializeMintInstructionKey\n    }, {\n      programs,\n      payer\n    }));\n  } // Create the token account if it doesn't exist.\n\n\n  const isNewToken = !!params.tokenAddress && isSigner(params.tokenAddress);\n  const isNewAssociatedToken = !!params.tokenOwner;\n\n  if (!tokenExists && (isNewToken || isNewAssociatedToken)) {\n    builder.add(await metaplex.tokens().builders().createToken({\n      mint: mintAddress,\n      owner: params.tokenOwner,\n      token: params.tokenAddress,\n      createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey,\n      createAccountInstructionKey: params.createTokenAccountInstructionKey,\n      initializeTokenInstructionKey: params.initializeTokenInstructionKey\n    }, {\n      programs,\n      payer\n    }));\n  } // Mint provided amount to the token account.\n\n\n  if (tokenAddress && params.tokenAmount) {\n    builder.add(await metaplex.tokens().builders().mint({\n      mintAddress,\n      toToken: tokenAddress,\n      toTokenExists: true,\n      amount: params.tokenAmount,\n      mintAuthority,\n      mintTokensInstructionKey: params.mintTokensInstructionKey\n    }, {\n      programs,\n      payer\n    }));\n  }\n\n  return builder;\n};\n\nexport { createSftBuilder, createSftOperation, createSftOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/nftModule/operations/createSft.ts"],"names":["Key","createSftOperation","useOperation","createSftOperationHandler","handle","operation","metaplex","scope","useNewMint","Keypair","generate","useExistingMint","tokenOwner","tokenAddress","tokenSigner","input","mintAddress","publicKey","associatedTokenAddress","tokens","pdas","associatedTokenAccount","mint","owner","programs","toPublicKey","tokenExists","tokenAccount","rpc","getAccount","exists","builder","createSftBuilder","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","sft","nfts","findByMint","undefined","assertSft","params","options","payer","getDefaultFeePayer","updateAuthority","identity","mintAuthority","mintAndTokenBuilder","createMintAndTokenForSftBuilder","getContext","tokenMetadataProgram","getTokenMetadata","metadataPda","metadata","creatorsInput","creators","address","authority","share","length","map","creator","verified","equals","createMetadataInstruction","createCreateMetadataAccountV3Instruction","createMetadataAccountArgsV3","data","name","symbol","uri","sellerFeeBasisPoints","collection","key","uses","isMutable","collectionDetails","isCollection","__kind","size","keys","isSigner","verifyAdditionalCreatorInstructions","filter","builders","verifyCreator","TransactionBuilder","make","setFeePayer","setContext","metadataAddress","add","instruction","signers","createMetadataInstructionKey","when","collectionAuthority","verifyCollection","collectionMintAddress","isDelegated","collectionAuthorityIsDelegated","isSizedCollection","collectionIsSized","freezeAuthority","createMint","decimals","createAccountInstructionKey","createMintAccountInstructionKey","initializeMintInstructionKey","isNewToken","isNewAssociatedToken","createToken","token","createAssociatedTokenAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","tokenAmount","toToken","toTokenExists","amount","mintTokensInstructionKey"],"mappings":"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","sourcesContent":["import {\n  createCreateMetadataAccountV3Instruction,\n  Uses,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertSft, Sft, SftWithToken } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Creator,\n  CreatorInput,\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateSftOperation' as const;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const { sft } = await metaplex\n *   .nfts()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createSftOperation = useOperation<CreateSftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateSftOperation = Operation<\n  typeof Key,\n  CreateSftInput,\n  CreateSftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateSftInput = {\n  /**\n   * The authority that will be able to make changes\n   * to the created SFT.\n   *\n   * This is required as a Signer because creating the\n   * metadata account requires the update authority to be part\n   * of the creators array as a verified creator.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The authority allowed to mint new tokens for the mint account\n   * that is either explicitly provided or about to be created.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: Signer;\n\n  /**\n   * The authority allowed to freeze token account associated with the\n   * mint account that is either explicitly provided or about to be created.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  freezeAuthority?: Option<PublicKey>;\n\n  /**\n   * The address of the new mint account as a Signer.\n   * This is useful if you already have a generated Keypair\n   * for the mint account of the SFT to create.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  useNewMint?: Signer;\n\n  /**\n   * The address of the existing mint account that should be converted\n   * into an SFT. The account at this address should have the right\n   * requirements to become an SFT, e.g. it shouldn't already have\n   * a metadata account associated with it.\n   *\n   * @defaultValue Defaults to creating a new mint account with the\n   * right requirements.\n   */\n  useExistingMint?: PublicKey;\n\n  /**\n   * The owner of a token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account. When provided, an associated\n   * token account will be created from the given owner.\n   *\n   * You may alternatively pass the `tokenAddress` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * An explicit token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account.\n   *\n   * When provided, the token account will be created if and only\n   * if no account exists at the given address. When that's the case,\n   * the `tokenAddress` must be provided as a Signer as we're creating\n   * and initializing the account at this address.\n   *\n   * You may alternatively pass the `tokenOwner` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenAddress?: PublicKey | Signer;\n\n  /**\n   * The amount of tokens to mint to the token account initially\n   * if a token account is created.\n   *\n   * This is only relevant if either the `tokenOwner` or `tokenAddress`\n   * is provided.\n   *\n   * @defaultValue Defaults to not minting any tokens.\n   */\n  tokenAmount?: SplTokenAmount;\n\n  /**\n   * The number of decimal points used to define token amounts.\n   *\n   * @defaultValue `0`\n   */\n  decimals?: number;\n\n  /** The URI that points to the JSON metadata of the asset. */\n  uri: string;\n\n  /** The on-chain name of the asset, e.g. \"My SFT\". */\n  name: string;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYSFT\".\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * {@inheritDoc CreatorInput}\n   * @defaultValue\n   * Defaults to using the provided `updateAuthority` as the only verified creator.\n   * ```ts\n   * [{\n   *   address: updateAuthority.publicKey,\n   *   authority: updateAuthority,\n   *   share: 100,\n   * }]\n   * ```\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the SFT's metadata is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * When this field is not `null`, it indicates that the SFT\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue `null`\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * Whether the created SFT is a Collection SFT.\n   * When set to `true`, the SFT will be created as a\n   * Sized Collection SFT with an initial size of 0.\n   *\n   * @defaultValue `false`\n   */\n  isCollection?: boolean;\n\n  /**\n   * The Collection NFT that this new SFT belongs to.\n   * When `null`, the created SFT will not be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the created SFT\n   * to prove that it is part of the provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n\n  /**\n   * Whether or not the provided `collection` is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  collectionIsSized?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateSftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created SFT and, potentially, its associated token. */\n  sft: Sft | SftWithToken;\n\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the metadata account. */\n  metadataAddress: PublicKey;\n\n  /** The address of the token account if any. */\n  tokenAddress: PublicKey | null;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createSftOperationHandler: OperationHandler<CreateSftOperation> = {\n  handle: async (\n    operation: CreateSftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ) => {\n    const {\n      useNewMint = Keypair.generate(),\n      useExistingMint,\n      tokenOwner,\n      tokenAddress: tokenSigner,\n    } = operation.input;\n\n    const mintAddress = useExistingMint ?? useNewMint.publicKey;\n    const associatedTokenAddress = tokenOwner\n      ? metaplex.tokens().pdas().associatedTokenAccount({\n          mint: mintAddress,\n          owner: tokenOwner,\n          programs: scope.programs,\n        })\n      : null;\n    const tokenAddress = tokenSigner\n      ? toPublicKey(tokenSigner)\n      : associatedTokenAddress;\n\n    let tokenExists: boolean;\n    if (!!useExistingMint && !!tokenAddress) {\n      const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);\n      tokenExists = tokenAccount.exists;\n    } else {\n      tokenExists = false;\n    }\n\n    const builder = await createSftBuilder(\n      metaplex,\n      { ...operation.input, useNewMint, tokenExists },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n      metaplex,\n      scope.confirmOptions\n    );\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    const sft = await metaplex.nfts().findByMint(\n      {\n        mintAddress: output.mintAddress,\n        tokenAddress: output.tokenAddress ?? undefined,\n      },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    assertSft(sft);\n    return { ...output, sft };\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateSftBuilderParams = Omit<CreateSftInput, 'confirmOptions'> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the metadata account. */\n  createMetadataInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateSftBuilderContext = Omit<CreateSftOutput, 'response' | 'sft'>;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createSftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateSftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateSftBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    useNewMint = Keypair.generate(),\n    updateAuthority = metaplex.identity(),\n    mintAuthority = metaplex.identity(),\n  } = params;\n\n  const mintAndTokenBuilder = await createMintAndTokenForSftBuilder(\n    metaplex,\n    params,\n    { programs, payer },\n    useNewMint\n  );\n  const { mintAddress, tokenAddress } = mintAndTokenBuilder.getContext();\n\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const metadataPda = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const creatorsInput: CreatorInput[] = params.creators ?? [\n    {\n      address: updateAuthority.publicKey,\n      authority: updateAuthority,\n      share: 100,\n    },\n  ];\n  const creators: Option<Creator[]> =\n    creatorsInput.length > 0\n      ? creatorsInput.map((creator) => ({\n          ...creator,\n          verified: creator.address.equals(updateAuthority.publicKey),\n        }))\n      : null;\n\n  const createMetadataInstruction = createCreateMetadataAccountV3Instruction(\n    {\n      metadata: metadataPda,\n      mint: mintAddress,\n      mintAuthority: mintAuthority.publicKey,\n      payer: payer.publicKey,\n      updateAuthority: updateAuthority.publicKey,\n    },\n    {\n      createMetadataAccountArgsV3: {\n        data: {\n          name: params.name,\n          symbol: params.symbol ?? '',\n          uri: params.uri,\n          sellerFeeBasisPoints: params.sellerFeeBasisPoints,\n          creators,\n          collection: params.collection\n            ? { key: params.collection, verified: false }\n            : null,\n          uses: params.uses ?? null,\n        },\n        isMutable: params.isMutable ?? true,\n        collectionDetails: params.isCollection\n          ? { __kind: 'V1', size: 0 } // Program will hardcode size to zero anyway.\n          : null,\n      },\n    },\n    tokenMetadataProgram.address\n  );\n\n  // When the payer is different than the update authority, the latter will\n  // not be marked as a signer and therefore signing as a creator will fail.\n  createMetadataInstruction.keys[4].isSigner = true;\n\n  const verifyAdditionalCreatorInstructions = creatorsInput\n    .filter((creator) => {\n      return (\n        !!creator.authority &&\n        !creator.address.equals(updateAuthority.publicKey)\n      );\n    })\n    .map((creator) => {\n      return metaplex.nfts().builders().verifyCreator(\n        {\n          mintAddress,\n          creator: creator.authority,\n        },\n        { programs, payer }\n      );\n    });\n\n  return (\n    TransactionBuilder.make<CreateSftBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintAddress,\n        metadataAddress: metadataPda,\n        tokenAddress,\n      })\n\n      // Create the mint and token accounts before minting 1 token to the owner.\n      .add(mintAndTokenBuilder)\n\n      // Create metadata account.\n      .add({\n        instruction: createMetadataInstruction,\n        signers: [payer, mintAuthority, updateAuthority],\n        key: params.createMetadataInstructionKey ?? 'createMetadata',\n      })\n\n      // Verify additional creators.\n      .add(...verifyAdditionalCreatorInstructions)\n\n      // Verify collection.\n      .when(!!params.collection && !!params.collectionAuthority, (builder) =>\n        builder.add(\n          metaplex\n            .nfts()\n            .builders()\n            .verifyCollection(\n              {\n                mintAddress,\n                collectionMintAddress: params.collection as PublicKey,\n                collectionAuthority: params.collectionAuthority as Signer,\n                isDelegated: params.collectionAuthorityIsDelegated ?? false,\n                isSizedCollection: params.collectionIsSized ?? true,\n              },\n              { payer, programs }\n            )\n        )\n      )\n  );\n};\n\nconst createMintAndTokenForSftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateSftBuilderParams,\n  options: TransactionBuilderOptions,\n  useNewMint: Signer\n): Promise<\n  TransactionBuilder<{ mintAddress: PublicKey; tokenAddress: PublicKey | null }>\n> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAuthority = metaplex.identity(),\n    freezeAuthority = metaplex.identity().publicKey,\n    tokenExists = false,\n  } = params;\n\n  const mintAddress = params.useExistingMint ?? useNewMint.publicKey;\n  const associatedTokenAddress = params.tokenOwner\n    ? metaplex.tokens().pdas().associatedTokenAccount({\n        mint: mintAddress,\n        owner: params.tokenOwner,\n        programs,\n      })\n    : null;\n  const tokenAddress = params.tokenAddress\n    ? toPublicKey(params.tokenAddress)\n    : associatedTokenAddress;\n\n  const builder = TransactionBuilder.make<{\n    mintAddress: PublicKey;\n    tokenAddress: PublicKey | null;\n  }>()\n    .setFeePayer(payer)\n    .setContext({\n      mintAddress,\n      tokenAddress,\n    });\n\n  // Create the mint account if it doesn't exist.\n  if (!params.useExistingMint) {\n    builder.add(\n      await metaplex\n        .tokens()\n        .builders()\n        .createMint(\n          {\n            decimals: params.decimals ?? 0,\n            mint: useNewMint,\n            mintAuthority: mintAuthority.publicKey,\n            freezeAuthority,\n            createAccountInstructionKey: params.createMintAccountInstructionKey,\n            initializeMintInstructionKey: params.initializeMintInstructionKey,\n          },\n          { programs, payer }\n        )\n    );\n  }\n\n  // Create the token account if it doesn't exist.\n  const isNewToken = !!params.tokenAddress && isSigner(params.tokenAddress);\n  const isNewAssociatedToken = !!params.tokenOwner;\n  if (!tokenExists && (isNewToken || isNewAssociatedToken)) {\n    builder.add(\n      await metaplex\n        .tokens()\n        .builders()\n        .createToken(\n          {\n            mint: mintAddress,\n            owner: params.tokenOwner,\n            token: params.tokenAddress as Signer | undefined,\n            createAssociatedTokenAccountInstructionKey:\n              params.createAssociatedTokenAccountInstructionKey,\n            createAccountInstructionKey:\n              params.createTokenAccountInstructionKey,\n            initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n          },\n          { programs, payer }\n        )\n    );\n  }\n\n  // Mint provided amount to the token account.\n  if (tokenAddress && params.tokenAmount) {\n    builder.add(\n      await metaplex.tokens().builders().mint(\n        {\n          mintAddress,\n          toToken: tokenAddress,\n          toTokenExists: true,\n          amount: params.tokenAmount,\n          mintAuthority,\n          mintTokensInstructionKey: params.mintTokensInstructionKey,\n        },\n        { programs, payer }\n      )\n    );\n  }\n\n  return builder;\n};\n"]},"metadata":{},"sourceType":"module"}