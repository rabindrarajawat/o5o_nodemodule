{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { WalletNotConnectedError } from './errors.js';\nexport { EventEmitter };\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\n\nexport var WalletReadyState;\n\n(function (WalletReadyState) {\n  /**\n   * User-installable wallets can typically be detected by scanning for an API\n   * that they've injected into the global context. If such an API is present,\n   * we consider the wallet to have been installed.\n   */\n  WalletReadyState[\"Installed\"] = \"Installed\";\n  WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n  /**\n   * Loadable wallets are always available to you. Since you can load them at\n   * any time, it's meaningless to say that they have been detected.\n   */\n\n  WalletReadyState[\"Loadable\"] = \"Loadable\";\n  /**\n   * If a wallet is not supported on a given platform (eg. server-rendering, or\n   * mobile) then it will stay in the `Unsupported` state.\n   */\n\n  WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\n\nexport class BaseWalletAdapter extends EventEmitter {\n  get connected() {\n    return !!this.publicKey;\n  }\n\n  async autoConnect() {\n    await this.connect();\n  }\n\n  async prepareTransaction(transaction, connection) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const publicKey = this.publicKey;\n    if (!publicKey) throw new WalletNotConnectedError();\n    transaction.feePayer = transaction.feePayer || publicKey;\n    transaction.recentBlockhash = transaction.recentBlockhash || (await connection.getLatestBlockhash({\n      commitment: options.preflightCommitment,\n      minContextSlot: options.minContextSlot\n    })).blockhash;\n    return transaction;\n  }\n\n}\nexport function scopePollingDetectionStrategy(detect) {\n  // Early return when server-side rendering\n  if (typeof window === 'undefined' || typeof document === 'undefined') return;\n  const disposers = [];\n\n  function detectAndDispose() {\n    const detected = detect();\n\n    if (detected) {\n      for (const dispose of disposers) {\n        dispose();\n      }\n    }\n  } // Strategy #1: Try detecting every second.\n\n\n  const interval = // TODO: #334 Replace with idle callback strategy.\n  setInterval(detectAndDispose, 1000);\n  disposers.push(() => clearInterval(interval)); // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n\n  if ( // Implies that `DOMContentLoaded` has not yet fired.\n  document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', detectAndDispose, {\n      once: true\n    });\n    disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n  } // Strategy #3: Detect after the `window` has fully loaded.\n\n\n  if ( // If the `complete` state has been reached, we're too late.\n  document.readyState !== 'complete') {\n    window.addEventListener('load', detectAndDispose, {\n      once: true\n    });\n    disposers.push(() => window.removeEventListener('load', detectAndDispose));\n  } // Strategy #4: Detect synchronously, now.\n\n\n  detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */\n\nexport function isIosAndRedirectable() {\n  // SSR: return false\n  if (!navigator) return false;\n  const userAgent = navigator.userAgent.toLowerCase(); // if on iOS the user agent will contain either iPhone or iPad\n  // caveat: if requesting desktop site then this won't work\n\n  const isIos = userAgent.includes('iphone') || userAgent.includes('ipad'); // if in a webview then it will not include Safari\n  // note that other iOS browsers also include Safari\n  // so we will redirect only if Safari is also included\n\n  const isSafari = userAgent.includes('safari');\n  return isIos && isSafari;\n}","map":{"version":3,"sources":["../../src/adapter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { WalletNotConnectedError } from './errors.js';\nexport { EventEmitter };\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nexport var WalletReadyState;\n(function (WalletReadyState) {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */\n    WalletReadyState[\"Installed\"] = \"Installed\";\n    WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */\n    WalletReadyState[\"Loadable\"] = \"Loadable\";\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */\n    WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nexport class BaseWalletAdapter extends EventEmitter {\n    get connected() {\n        return !!this.publicKey;\n    }\n    async autoConnect() {\n        await this.connect();\n    }\n    async prepareTransaction(transaction, connection, options = {}) {\n        const publicKey = this.publicKey;\n        if (!publicKey)\n            throw new WalletNotConnectedError();\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash =\n            transaction.recentBlockhash ||\n                (await connection.getLatestBlockhash({\n                    commitment: options.preflightCommitment,\n                    minContextSlot: options.minContextSlot,\n                })).blockhash;\n        return transaction;\n    }\n}\nexport function scopePollingDetectionStrategy(detect) {\n    // Early return when server-side rendering\n    if (typeof window === 'undefined' || typeof document === 'undefined')\n        return;\n    const disposers = [];\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers) {\n                dispose();\n            }\n        }\n    }\n    // Strategy #1: Try detecting every second.\n    const interval = \n    // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n    disposers.push(() => clearInterval(interval));\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (\n    // Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });\n        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n    }\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (\n    // If the `complete` state has been reached, we're too late.\n    document.readyState !== 'complete') {\n        window.addEventListener('load', detectAndDispose, { once: true });\n        disposers.push(() => window.removeEventListener('load', detectAndDispose));\n    }\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */\nexport function isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator)\n        return false;\n    const userAgent = navigator.userAgent.toLowerCase();\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes('iphone') || userAgent.includes('ipad');\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes('safari');\n    return isIos && isSafari;\n}\n//# sourceMappingURL=adapter.js.map"]},"metadata":{},"sourceType":"module"}