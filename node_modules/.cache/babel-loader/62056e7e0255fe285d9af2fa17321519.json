{"ast":null,"code":"import { WalletNotConnectedError, WalletNotReadyError, WalletReadyState } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\nexport function WalletProviderBase(_ref) {\n  let {\n    children: children,\n    wallets: adapters,\n    adapter: adapter,\n    isUnloadingRef: isUnloadingRef,\n    onAutoConnectRequest: onAutoConnectRequest,\n    onConnectError: onConnectError,\n    onError: onError,\n    onSelectWallet: onSelectWallet\n  } = _ref;\n  const isConnectingRef = useRef(false);\n  const [connecting, setConnecting] = useState(false);\n  const isDisconnectingRef = useRef(false);\n  const [disconnecting, setDisconnecting] = useState(false);\n  const [publicKey, setPublicKey] = useState(() => {\n    var _adapter$publicKey;\n\n    return (_adapter$publicKey = adapter === null || adapter === void 0 ? void 0 : adapter.publicKey) !== null && _adapter$publicKey !== void 0 ? _adapter$publicKey : null;\n  });\n  const [connected, setConnected] = useState(() => {\n    var _adapter$connected;\n\n    return (_adapter$connected = adapter === null || adapter === void 0 ? void 0 : adapter.connected) !== null && _adapter$connected !== void 0 ? _adapter$connected : false;\n  });\n  /**\n   * Store the error handlers as refs so that a change in the\n   * custom error handler does not recompute other dependencies.\n   */\n\n  const onErrorRef = useRef(onError);\n  useEffect(() => {\n    onErrorRef.current = onError;\n    return () => {\n      onErrorRef.current = undefined;\n    };\n  }, [onError]);\n  const handleErrorRef = useRef((error, adapter) => {\n    if (!isUnloadingRef.current) {\n      if (onErrorRef.current) {\n        onErrorRef.current(error, adapter);\n      } else {\n        console.error(error, adapter);\n\n        if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n          window.open(adapter.url, '_blank');\n        }\n      }\n    }\n\n    return error;\n  }); // Wrap adapters to conform to the `Wallet` interface\n\n  const [wallets, setWallets] = useState(() => adapters.map(adapter => ({\n    adapter: adapter,\n    readyState: adapter.readyState\n  })).filter(_ref2 => {\n    let {\n      readyState: readyState\n    } = _ref2;\n    return readyState !== WalletReadyState.Unsupported;\n  })); // When the adapters change, start to listen for changes to their `readyState`\n\n  useEffect(() => {\n    // When the adapters change, wrap them to conform to the `Wallet` interface\n    setWallets(wallets => adapters.map((adapter, index) => {\n      const wallet = wallets[index]; // If the wallet hasn't changed, return the same instance\n\n      return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState ? wallet : {\n        adapter: adapter,\n        readyState: adapter.readyState\n      };\n    }).filter(_ref3 => {\n      let {\n        readyState: readyState\n      } = _ref3;\n      return readyState !== WalletReadyState.Unsupported;\n    }));\n\n    function handleReadyStateChange(readyState) {\n      setWallets(prevWallets => {\n        const index = prevWallets.findIndex(_ref4 => {\n          let {\n            adapter: adapter\n          } = _ref4;\n          return adapter === this;\n        });\n        if (index === -1) return prevWallets; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const {\n          adapter: adapter\n        } = prevWallets[index];\n        return [...prevWallets.slice(0, index), {\n          adapter: adapter,\n          readyState: readyState\n        }, ...prevWallets.slice(index + 1)].filter(_ref5 => {\n          let {\n            readyState: readyState\n          } = _ref5;\n          return readyState !== WalletReadyState.Unsupported;\n        });\n      });\n    }\n\n    adapters.forEach(adapter => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n    return () => {\n      adapters.forEach(adapter => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n    };\n  }, [adapter, adapters]);\n  const wallet = useMemo(() => {\n    var _wallets$find;\n\n    return (_wallets$find = wallets.find(wallet => wallet.adapter === adapter)) !== null && _wallets$find !== void 0 ? _wallets$find : null;\n  }, [adapter, wallets]); // Setup and teardown event listeners when the adapter changes\n\n  useEffect(() => {\n    if (!adapter) return;\n\n    const handleConnect = publicKey => {\n      setPublicKey(publicKey);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(true);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n\n    const handleDisconnect = () => {\n      if (isUnloadingRef.current) return;\n      setPublicKey(null);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(false);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n\n    const handleError = error => {\n      handleErrorRef.current(error, adapter);\n    };\n\n    adapter.on('connect', handleConnect);\n    adapter.on('disconnect', handleDisconnect);\n    adapter.on('error', handleError);\n    return () => {\n      adapter.off('connect', handleConnect);\n      adapter.off('disconnect', handleDisconnect);\n      adapter.off('error', handleError);\n      handleDisconnect();\n    };\n  }, [adapter, isUnloadingRef]); // When the adapter changes, clear the `autoConnect` tracking flag\n\n  const didAttemptAutoConnectRef = useRef(false);\n  useEffect(() => {\n    return () => {\n      didAttemptAutoConnectRef.current = false;\n    };\n  }, [adapter]); // If auto-connect is enabled, request to connect when the adapter changes and is ready\n\n  useEffect(() => {\n    if (didAttemptAutoConnectRef.current || isConnectingRef.current || connected || !onAutoConnectRequest || !((wallet === null || wallet === void 0 ? void 0 : wallet.readyState) === WalletReadyState.Installed || (wallet === null || wallet === void 0 ? void 0 : wallet.readyState) === WalletReadyState.Loadable)) {\n      return;\n    }\n\n    isConnectingRef.current = true;\n    setConnecting(true);\n    didAttemptAutoConnectRef.current = true;\n\n    (async function () {\n      try {\n        await onAutoConnectRequest();\n      } catch {\n        onConnectError(); // Drop the error. It will be caught by `handleError` anyway.\n      } finally {\n        setConnecting(false);\n        isConnectingRef.current = false;\n      }\n    })();\n  }, [connected, onAutoConnectRequest, onConnectError, wallet]); // Send a transaction using the provided connection\n\n  const sendTransaction = useCallback(async (transaction, connection, options) => {\n    if (!adapter) throw handleErrorRef.current(new WalletNotSelectedError());\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.sendTransaction(transaction, connection, options);\n  }, [adapter, connected]); // Sign a transaction if the wallet supports it\n\n  const signTransaction = useMemo(() => adapter && 'signTransaction' in adapter ? async transaction => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signTransaction(transaction);\n  } : undefined, [adapter, connected]); // Sign multiple transactions if the wallet supports it\n\n  const signAllTransactions = useMemo(() => adapter && 'signAllTransactions' in adapter ? async transactions => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signAllTransactions(transactions);\n  } : undefined, [adapter, connected]); // Sign an arbitrary message if the wallet supports it\n\n  const signMessage = useMemo(() => adapter && 'signMessage' in adapter ? async message => {\n    if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n    return await adapter.signMessage(message);\n  } : undefined, [adapter, connected]);\n  const handleConnect = useCallback(async () => {\n    if (isConnectingRef.current || isDisconnectingRef.current || wallet !== null && wallet !== void 0 && wallet.adapter.connected) return;\n    if (!wallet) throw handleErrorRef.current(new WalletNotSelectedError());\n    const {\n      adapter: adapter,\n      readyState: readyState\n    } = wallet;\n    if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n    isConnectingRef.current = true;\n    setConnecting(true);\n\n    try {\n      await adapter.connect();\n    } catch (e) {\n      onConnectError();\n      throw e;\n    } finally {\n      setConnecting(false);\n      isConnectingRef.current = false;\n    }\n  }, [onConnectError, wallet]);\n  const handleDisconnect = useCallback(async () => {\n    if (isDisconnectingRef.current) return;\n    if (!adapter) return;\n    isDisconnectingRef.current = true;\n    setDisconnecting(true);\n\n    try {\n      await adapter.disconnect();\n    } finally {\n      setDisconnecting(false);\n      isDisconnectingRef.current = false;\n    }\n  }, [adapter]);\n  return React.createElement(WalletContext.Provider, {\n    value: {\n      autoConnect: !!onAutoConnectRequest,\n      wallets: wallets,\n      wallet: wallet,\n      publicKey: publicKey,\n      connected: connected,\n      connecting: connecting,\n      disconnecting: disconnecting,\n      select: onSelectWallet,\n      connect: handleConnect,\n      disconnect: handleDisconnect,\n      sendTransaction: sendTransaction,\n      signTransaction: signTransaction,\n      signAllTransactions: signAllTransactions,\n      signMessage: signMessage\n    }\n  }, children);\n}","map":{"version":3,"sources":["../../src/WalletProviderBase.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { WalletNotConnectedError, WalletNotReadyError, WalletReadyState, } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\nexport function WalletProviderBase({ children, wallets: adapters, adapter, isUnloadingRef, onAutoConnectRequest, onConnectError, onError, onSelectWallet, }) {\n    const isConnectingRef = useRef(false);\n    const [connecting, setConnecting] = useState(false);\n    const isDisconnectingRef = useRef(false);\n    const [disconnecting, setDisconnecting] = useState(false);\n    const [publicKey, setPublicKey] = useState(() => adapter?.publicKey ?? null);\n    const [connected, setConnected] = useState(() => adapter?.connected ?? false);\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */\n    const onErrorRef = useRef(onError);\n    useEffect(() => {\n        onErrorRef.current = onError;\n        return () => {\n            onErrorRef.current = undefined;\n        };\n    }, [onError]);\n    const handleErrorRef = useRef((error, adapter) => {\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            }\n            else {\n                console.error(error, adapter);\n                if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n                    window.open(adapter.url, '_blank');\n                }\n            }\n        }\n        return error;\n    });\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = useState(() => adapters\n        .map((adapter) => ({\n        adapter,\n        readyState: adapter.readyState,\n    }))\n        .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported));\n    // When the adapters change, start to listen for changes to their `readyState`\n    useEffect(() => {\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets) => adapters\n            .map((adapter, index) => {\n            const wallet = wallets[index];\n            // If the wallet hasn't changed, return the same instance\n            return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState\n                ? wallet\n                : {\n                    adapter: adapter,\n                    readyState: adapter.readyState,\n                };\n        })\n            .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported));\n        function handleReadyStateChange(readyState) {\n            setWallets((prevWallets) => {\n                const index = prevWallets.findIndex(({ adapter }) => adapter === this);\n                if (index === -1)\n                    return prevWallets;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index];\n                return [\n                    ...prevWallets.slice(0, index),\n                    { adapter, readyState },\n                    ...prevWallets.slice(index + 1),\n                ].filter(({ readyState }) => readyState !== WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter) => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n        return () => {\n            adapters.forEach((adapter) => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n        };\n    }, [adapter, adapters]);\n    const wallet = useMemo(() => wallets.find((wallet) => wallet.adapter === adapter) ?? null, [adapter, wallets]);\n    // Setup and teardown event listeners when the adapter changes\n    useEffect(() => {\n        if (!adapter)\n            return;\n        const handleConnect = (publicKey) => {\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleDisconnect = () => {\n            if (isUnloadingRef.current)\n                return;\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleError = (error) => {\n            handleErrorRef.current(error, adapter);\n        };\n        adapter.on('connect', handleConnect);\n        adapter.on('disconnect', handleDisconnect);\n        adapter.on('error', handleError);\n        return () => {\n            adapter.off('connect', handleConnect);\n            adapter.off('disconnect', handleDisconnect);\n            adapter.off('error', handleError);\n            handleDisconnect();\n        };\n    }, [adapter, isUnloadingRef]);\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = useRef(false);\n    useEffect(() => {\n        return () => {\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [adapter]);\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    useEffect(() => {\n        if (didAttemptAutoConnectRef.current ||\n            isConnectingRef.current ||\n            connected ||\n            !onAutoConnectRequest ||\n            !(wallet?.readyState === WalletReadyState.Installed || wallet?.readyState === WalletReadyState.Loadable)) {\n            return;\n        }\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function () {\n            try {\n                await onAutoConnectRequest();\n            }\n            catch {\n                onConnectError();\n                // Drop the error. It will be caught by `handleError` anyway.\n            }\n            finally {\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n    // Send a transaction using the provided connection\n    const sendTransaction = useCallback(async (transaction, connection, options) => {\n        if (!adapter)\n            throw handleErrorRef.current(new WalletNotSelectedError());\n        if (!connected)\n            throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n        return await adapter.sendTransaction(transaction, connection, options);\n    }, [adapter, connected]);\n    // Sign a transaction if the wallet supports it\n    const signTransaction = useMemo(() => adapter && 'signTransaction' in adapter\n        ? async (transaction) => {\n            if (!connected)\n                throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.signTransaction(transaction);\n        }\n        : undefined, [adapter, connected]);\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = useMemo(() => adapter && 'signAllTransactions' in adapter\n        ? async (transactions) => {\n            if (!connected)\n                throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.signAllTransactions(transactions);\n        }\n        : undefined, [adapter, connected]);\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage = useMemo(() => adapter && 'signMessage' in adapter\n        ? async (message) => {\n            if (!connected)\n                throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.signMessage(message);\n        }\n        : undefined, [adapter, connected]);\n    const handleConnect = useCallback(async () => {\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected)\n            return;\n        if (!wallet)\n            throw handleErrorRef.current(new WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable))\n            throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        }\n        catch (e) {\n            onConnectError();\n            throw e;\n        }\n        finally {\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [onConnectError, wallet]);\n    const handleDisconnect = useCallback(async () => {\n        if (isDisconnectingRef.current)\n            return;\n        if (!adapter)\n            return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        }\n        finally {\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [adapter]);\n    return (React.createElement(WalletContext.Provider, { value: {\n            autoConnect: !!onAutoConnectRequest,\n            wallets,\n            wallet,\n            publicKey,\n            connected,\n            connecting,\n            disconnecting,\n            select: onSelectWallet,\n            connect: handleConnect,\n            disconnect: handleDisconnect,\n            sendTransaction,\n            signTransaction,\n            signAllTransactions,\n            signMessage,\n        } }, children));\n}\n//# sourceMappingURL=WalletProviderBase.js.map"]},"metadata":{},"sourceType":"module"}