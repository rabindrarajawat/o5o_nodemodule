{"ast":null,"code":"import { createInitializeCandyMachineInstruction, createSetCollectionInstruction } from '@metaplex-foundation/mpl-candy-machine';\nimport { Keypair } from '@solana/web3.js';\nimport { getCandyMachineV2AccountSizeFromData } from '../helpers.mjs';\nimport { findCandyMachineV2CollectionPda } from '../pdas.mjs';\nimport { CandyMachineV2Program } from '../program.mjs';\nimport { toCandyMachineV2InstructionData } from '../models/CandyMachineV2.mjs';\nimport { assertSameCurrencies, SOL } from '../../../types/Amount.mjs';\nimport { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { toBigNumber } from '../../../types/BigNumber.mjs';\nimport { toPublicKey } from '../../../types/PublicKey.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs';\nimport { isSigner } from '../../../types/Signer.mjs';\nimport { ExpectedSignerError } from '../../../errors/SdkError.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateCandyMachineV2Operation';\n/**\n * Creates a brand new Candy Machine.\n *\n * ```ts\n * const { candyMachine } = await metaplex\n *   .candyMachinesV2()\n *   .create({\n *     sellerFeeBasisPoints: 500, // 5% royalties\n *     price: sol(1.3), // 1.3 SOL\n *     itemsAvailable: toBigNumber(1000), // 1000 items available\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst createCandyMachineV2Operation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst createCandyMachineV2OperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const builder = await createCandyMachineV2Builder(metaplex, operation.input, scope);\n    scope.throwIfCanceled();\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n    const candyMachine = await metaplex.candyMachinesV2().findByAddress({\n      address: output.candyMachineSigner.publicKey\n    }, scope);\n    return { ...output,\n      candyMachine\n    };\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Creates a brand new Candy Machine.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .create({\n *     sellerFeeBasisPoints: 500, // 5% royalties\n *     price: sol(1.3), // 1.3 SOL\n *     itemsAvailable: toBigNumber(1000), // 1000 items available\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst createCandyMachineV2Builder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const candyMachine = params.candyMachine ?? Keypair.generate();\n  const authority = params.authority ?? metaplex.identity();\n  const collection = params.collection ?? null;\n  const {\n    data,\n    wallet,\n    tokenMint\n  } = toCandyMachineV2InstructionData(candyMachine.publicKey, { ...params,\n    wallet: params.wallet ?? metaplex.identity().publicKey,\n    tokenMint: params.tokenMint ?? null,\n    symbol: params.symbol ?? '',\n    maxEditionSupply: params.maxEditionSupply ?? toBigNumber(0),\n    isMutable: params.isMutable ?? true,\n    retainAuthority: params.retainAuthority ?? true,\n    goLiveDate: params.goLiveDate ?? null,\n    endSettings: params.endSettings ?? null,\n    creators: params.creators ?? [{\n      address: metaplex.identity().publicKey,\n      share: 100,\n      verified: false\n    }],\n    hiddenSettings: params.hiddenSettings ?? null,\n    whitelistMintSettings: params.whitelistMintSettings ?? null,\n    gatekeeper: params.gatekeeper ?? null\n  });\n  const initializeInstruction = createInitializeCandyMachineInstruction({\n    candyMachine: candyMachine.publicKey,\n    wallet,\n    authority: toPublicKey(authority),\n    payer: payer.publicKey\n  }, {\n    data\n  });\n\n  if (tokenMint) {\n    initializeInstruction.keys.push({\n      pubkey: tokenMint,\n      isWritable: false,\n      isSigner: false\n    });\n  } else {\n    assertSameCurrencies(params.price, SOL);\n  }\n\n  return TransactionBuilder.make().setFeePayer(payer).setContext({\n    candyMachineSigner: candyMachine,\n    wallet,\n    authority: toPublicKey(authority),\n    creators: data.creators\n  }) // Create an empty account for the candy machine.\n  .add(await metaplex.system().builders().createAccount({\n    newAccount: candyMachine,\n    space: getCandyMachineV2AccountSizeFromData(data),\n    program: CandyMachineV2Program.publicKey,\n    instructionKey: params.createAccountInstructionKey ?? 'createAccount'\n  }, {\n    payer,\n    programs\n  })) // Initialize the candy machine account.\n  .add({\n    instruction: initializeInstruction,\n    signers: [candyMachine, payer],\n    key: params.initializeCandyMachineInstructionKey ?? 'initializeCandyMachine'\n  }) // Set the collection.\n  .when(!!collection, builder => {\n    if (!isSigner(authority)) {\n      throw new ExpectedSignerError('authority', 'PublicKey', 'You are trying to create a Candy Machine with a Collection NFT. ' + 'In order for the Collection NFT to be set successfully, you must provide the authority as a Signer. ' + 'Please provide the \"authority\" parameter as a Signer if you want to set the Collection NFT upon creation. ' + 'Alternatively, you may remove the \"collection\" parameter to create a Candy Machine without an associated Collection NFT.');\n    }\n\n    const collectionMint = collection;\n    const metadata = metaplex.nfts().pdas().metadata({\n      mint: collectionMint,\n      programs\n    });\n    const edition = metaplex.nfts().pdas().masterEdition({\n      mint: collectionMint,\n      programs\n    });\n    const collectionPda = findCandyMachineV2CollectionPda(candyMachine.publicKey);\n    const collectionAuthorityRecord = metaplex.nfts().pdas().collectionAuthorityRecord({\n      mint: collectionMint,\n      collectionAuthority: collectionPda,\n      programs\n    });\n    return builder.add({\n      instruction: createSetCollectionInstruction({\n        candyMachine: candyMachine.publicKey,\n        authority: toPublicKey(authority),\n        collectionPda,\n        payer: payer.publicKey,\n        metadata,\n        mint: collectionMint,\n        edition,\n        collectionAuthorityRecord,\n        tokenMetadataProgram: metaplex.programs().getTokenMetadata().address\n      }),\n      signers: [authority],\n      key: params.setCollectionInstructionKey ?? 'setCollection'\n    });\n  });\n};\n\nexport { createCandyMachineV2Builder, createCandyMachineV2Operation, createCandyMachineV2OperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineV2Module/operations/createCandyMachineV2.ts"],"names":["Key","createCandyMachineV2Operation","useOperation","createCandyMachineV2OperationHandler","handle","operation","metaplex","scope","builder","createCandyMachineV2Builder","input","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","candyMachine","candyMachinesV2","findByAddress","address","candyMachineSigner","publicKey","params","options","programs","payer","rpc","getDefaultFeePayer","Keypair","generate","authority","identity","collection","data","wallet","tokenMint","toCandyMachineV2InstructionData","symbol","maxEditionSupply","toBigNumber","isMutable","retainAuthority","goLiveDate","endSettings","creators","share","verified","hiddenSettings","whitelistMintSettings","gatekeeper","initializeInstruction","createInitializeCandyMachineInstruction","toPublicKey","keys","push","pubkey","isWritable","isSigner","assertSameCurrencies","price","SOL","TransactionBuilder","make","setFeePayer","setContext","add","system","builders","createAccount","newAccount","space","getCandyMachineV2AccountSizeFromData","program","CandyMachineV2Program","instructionKey","createAccountInstructionKey","instruction","signers","key","initializeCandyMachineInstructionKey","when","ExpectedSignerError","collectionMint","metadata","nfts","pdas","mint","edition","masterEdition","collectionPda","findCandyMachineV2CollectionPda","collectionAuthorityRecord","collectionAuthority","createSetCollectionInstruction","tokenMetadataProgram","getTokenMetadata","setCollectionInstructionKey"],"mappings":"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","sourcesContent":["import {\n  createInitializeCandyMachineInstruction,\n  createSetCollectionInstruction,\n  Creator,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { getCandyMachineV2AccountSizeFromData } from '../helpers';\nimport {\n  CandyMachineV2,\n  CandyMachineV2Configs,\n  toCandyMachineV2InstructionData,\n} from '../models';\nimport { findCandyMachineV2CollectionPda } from '../pdas';\nimport { CandyMachineV2Program } from '../program';\nimport {\n  Option,\n  RequiredKeys,\n  TransactionBuilder,\n  TransactionBuilderOptions,\n} from '@/utils';\nimport {\n  assertSameCurrencies,\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SOL,\n  toBigNumber,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\nimport { ExpectedSignerError } from '@/errors';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateCandyMachineV2Operation' as const;\n\n/**\n * Creates a brand new Candy Machine.\n *\n * ```ts\n * const { candyMachine } = await metaplex\n *   .candyMachinesV2()\n *   .create({\n *     sellerFeeBasisPoints: 500, // 5% royalties\n *     price: sol(1.3), // 1.3 SOL\n *     itemsAvailable: toBigNumber(1000), // 1000 items available\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createCandyMachineV2Operation =\n  useOperation<CreateCandyMachineV2Operation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateCandyMachineV2Operation = Operation<\n  typeof Key,\n  CreateCandyMachineV2Input,\n  CreateCandyMachineV2Output\n>;\n\nexport type CreateCandyMachineV2InputWithoutConfigs = {\n  /**\n   * The Candy Machine to create as a Signer.\n   * This expects a brand new Keypair with no associated account.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  candyMachine?: Signer;\n\n  /**\n   * The authority that will be allowed to update the Candy Machine.\n   * Upon creation, passing the authority's public key is enough to set it.\n   * However, when also passing a `collection` to this operation,\n   * this authority will need to be passed as a Signer so the relevant\n   * instruction can be signed.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer | PublicKey; // Defaults to mx.identity().\n\n  /**\n   * The mint address of the Collection NFT that all NFTs minted from\n   * this Candy Machine should be part of.\n   * When provided, the `authority` parameter will need to be passed as a `Signer`.\n   * When `null`, minted NFTs won't be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n};\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateCandyMachineV2Input =\n  CreateCandyMachineV2InputWithoutConfigs &\n    RequiredKeys<\n      Partial<CandyMachineV2Configs>,\n      'price' | 'sellerFeeBasisPoints' | 'itemsAvailable'\n    >;\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateCandyMachineV2Output = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The created Candy Machine. */\n  candyMachine: CandyMachineV2;\n\n  /** The create Candy Machine's account as a Signer. */\n  candyMachineSigner: Signer;\n\n  /** The created Candy Machine's wallet. */\n  wallet: PublicKey;\n\n  /** The created Candy Machine's authority. */\n  authority: PublicKey;\n\n  /** The created Candy Machine's creators. */\n  creators: Creator[];\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createCandyMachineV2OperationHandler: OperationHandler<CreateCandyMachineV2Operation> =\n  {\n    async handle(\n      operation: CreateCandyMachineV2Operation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateCandyMachineV2Output> {\n      const builder = await createCandyMachineV2Builder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const candyMachine = await metaplex\n        .candyMachinesV2()\n        .findByAddress({ address: output.candyMachineSigner.publicKey }, scope);\n\n      return { ...output, candyMachine };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateCandyMachineV2BuilderParams = Omit<\n  CreateCandyMachineV2Input,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the account. */\n  createAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the Candy Machine. */\n  initializeCandyMachineInstructionKey?: string;\n\n  /** A key to distinguish the instruction that sets the collection. */\n  setCollectionInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateCandyMachineV2BuilderContext = Omit<\n  CreateCandyMachineV2Output,\n  'response' | 'candyMachine'\n>;\n\n/**\n * Creates a brand new Candy Machine.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .create({\n *     sellerFeeBasisPoints: 500, // 5% royalties\n *     price: sol(1.3), // 1.3 SOL\n *     itemsAvailable: toBigNumber(1000), // 1000 items available\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createCandyMachineV2Builder = async (\n  metaplex: Metaplex,\n  params: CreateCandyMachineV2BuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateCandyMachineV2BuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const candyMachine = params.candyMachine ?? Keypair.generate();\n  const authority = params.authority ?? metaplex.identity();\n  const collection: PublicKey | null = params.collection ?? null;\n\n  const { data, wallet, tokenMint } = toCandyMachineV2InstructionData(\n    candyMachine.publicKey,\n    {\n      ...params,\n      wallet: params.wallet ?? metaplex.identity().publicKey,\n      tokenMint: params.tokenMint ?? null,\n      symbol: params.symbol ?? '',\n      maxEditionSupply: params.maxEditionSupply ?? toBigNumber(0),\n      isMutable: params.isMutable ?? true,\n      retainAuthority: params.retainAuthority ?? true,\n      goLiveDate: params.goLiveDate ?? null,\n      endSettings: params.endSettings ?? null,\n      creators: params.creators ?? [\n        {\n          address: metaplex.identity().publicKey,\n          share: 100,\n          verified: false,\n        },\n      ],\n      hiddenSettings: params.hiddenSettings ?? null,\n      whitelistMintSettings: params.whitelistMintSettings ?? null,\n      gatekeeper: params.gatekeeper ?? null,\n    }\n  );\n\n  const initializeInstruction = createInitializeCandyMachineInstruction(\n    {\n      candyMachine: candyMachine.publicKey,\n      wallet,\n      authority: toPublicKey(authority),\n      payer: payer.publicKey,\n    },\n    { data }\n  );\n\n  if (tokenMint) {\n    initializeInstruction.keys.push({\n      pubkey: tokenMint,\n      isWritable: false,\n      isSigner: false,\n    });\n  } else {\n    assertSameCurrencies(params.price, SOL);\n  }\n\n  return (\n    TransactionBuilder.make<CreateCandyMachineV2BuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        candyMachineSigner: candyMachine,\n        wallet,\n        authority: toPublicKey(authority),\n        creators: data.creators,\n      })\n\n      // Create an empty account for the candy machine.\n      .add(\n        await metaplex\n          .system()\n          .builders()\n          .createAccount(\n            {\n              newAccount: candyMachine,\n              space: getCandyMachineV2AccountSizeFromData(data),\n              program: CandyMachineV2Program.publicKey,\n              instructionKey:\n                params.createAccountInstructionKey ?? 'createAccount',\n            },\n            { payer, programs }\n          )\n      )\n\n      // Initialize the candy machine account.\n      .add({\n        instruction: initializeInstruction,\n        signers: [candyMachine, payer],\n        key:\n          params.initializeCandyMachineInstructionKey ??\n          'initializeCandyMachine',\n      })\n\n      // Set the collection.\n      .when(!!collection, (builder) => {\n        if (!isSigner(authority)) {\n          throw new ExpectedSignerError(\n            'authority',\n            'PublicKey',\n            'You are trying to create a Candy Machine with a Collection NFT. ' +\n              'In order for the Collection NFT to be set successfully, you must provide the authority as a Signer. ' +\n              'Please provide the \"authority\" parameter as a Signer if you want to set the Collection NFT upon creation. ' +\n              'Alternatively, you may remove the \"collection\" parameter to create a Candy Machine without an associated Collection NFT.'\n          );\n        }\n\n        const collectionMint = collection as PublicKey;\n        const metadata = metaplex.nfts().pdas().metadata({\n          mint: collectionMint,\n          programs,\n        });\n        const edition = metaplex.nfts().pdas().masterEdition({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionPda = findCandyMachineV2CollectionPda(\n          candyMachine.publicKey\n        );\n        const collectionAuthorityRecord = metaplex\n          .nfts()\n          .pdas()\n          .collectionAuthorityRecord({\n            mint: collectionMint,\n            collectionAuthority: collectionPda,\n            programs,\n          });\n\n        return builder.add({\n          instruction: createSetCollectionInstruction({\n            candyMachine: candyMachine.publicKey,\n            authority: toPublicKey(authority),\n            collectionPda,\n            payer: payer.publicKey,\n            metadata,\n            mint: collectionMint,\n            edition,\n            collectionAuthorityRecord,\n            tokenMetadataProgram: metaplex.programs().getTokenMetadata()\n              .address,\n          }),\n          signers: [authority],\n          key: params.setCollectionInstructionKey ?? 'setCollection',\n        });\n      })\n  );\n};\n"]},"metadata":{},"sourceType":"module"}