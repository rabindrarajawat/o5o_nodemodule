{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { randomStr, getContentType, getExtension } from '../../utils/common.mjs';\nimport { InvalidJsonVariableError } from '../../errors/SdkError.mjs';\n\nconst toMetaplexFile = function (content, fileName) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return {\n    buffer: parseMetaplexFileContent(content),\n    fileName,\n    displayName: options.displayName ?? fileName,\n    uniqueName: options.uniqueName ?? randomStr(),\n    contentType: options.contentType ?? getContentType(fileName),\n    extension: options.extension ?? getExtension(fileName),\n    tags: options.tags ?? []\n  };\n};\n\nconst toMetaplexFileFromBrowser = async function (file) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const buffer = await file.arrayBuffer();\n  return toMetaplexFile(buffer, file.name, options);\n};\n\nconst toMetaplexFileFromJson = function (json) {\n  let fileName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'inline.json';\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let jsonString;\n\n  try {\n    jsonString = JSON.stringify(json);\n  } catch (error) {\n    throw new InvalidJsonVariableError(error);\n  }\n\n  return toMetaplexFile(jsonString, fileName, options);\n};\n\nconst parseMetaplexFileContent = content => {\n  if (content instanceof ArrayBuffer) {\n    return Buffer.from(new Uint8Array(content));\n  }\n\n  return Buffer.from(content);\n};\n\nconst getBytesFromMetaplexFiles = function () {\n  for (var _len = arguments.length, files = new Array(_len), _key = 0; _key < _len; _key++) {\n    files[_key] = arguments[_key];\n  }\n\n  return files.reduce((acc, file) => acc + file.buffer.byteLength, 0);\n};\n\nconst getBrowserFileFromMetaplexFile = file => new File([file.buffer], file.fileName);\n\nconst isMetaplexFile = metaplexFile => {\n  return metaplexFile != null && typeof metaplexFile === 'object' && 'buffer' in metaplexFile && 'fileName' in metaplexFile && 'displayName' in metaplexFile && 'uniqueName' in metaplexFile && 'contentType' in metaplexFile && 'extension' in metaplexFile && 'tags' in metaplexFile;\n};\n\nexport { getBrowserFileFromMetaplexFile, getBytesFromMetaplexFiles, isMetaplexFile, parseMetaplexFileContent, toMetaplexFile, toMetaplexFileFromBrowser, toMetaplexFileFromJson };","map":{"version":3,"sources":["../../../../src/plugins/storageModule/MetaplexFile.ts"],"names":["toMetaplexFile","content","fileName","options","buffer","parseMetaplexFileContent","displayName","uniqueName","randomStr","contentType","getContentType","extension","getExtension","tags","toMetaplexFileFromBrowser","file","arrayBuffer","name","toMetaplexFileFromJson","json","jsonString","JSON","stringify","error","InvalidJsonVariableError","ArrayBuffer","Buffer","from","Uint8Array","getBytesFromMetaplexFiles","files","reduce","acc","byteLength","getBrowserFileFromMetaplexFile","File","isMetaplexFile","metaplexFile"],"mappings":";;;;AA0BaA,MAAAA,cAAc,GAAG,UAC5BC,OAD4B,EAE5BC,QAF4B;EAAA,IAG5BC,OAH4B,uEAGG,EAHH;EAAA,OAIV;IAClBC,MAAM,EAAEC,wBAAwB,CAACJ,OAAD,CADd;IAElBC,QAFkB;IAGlBI,WAAW,EAAEH,OAAO,CAACG,WAARH,IAAuBD,QAHlB;IAIlBK,UAAU,EAAEJ,OAAO,CAACI,UAARJ,IAAsBK,SAAS,EAJzB;IAKlBC,WAAW,EAAEN,OAAO,CAACM,WAARN,IAAuBO,cAAc,CAACR,QAAD,CALhC;IAMlBS,SAAS,EAAER,OAAO,CAACQ,SAARR,IAAqBS,YAAY,CAACV,QAAD,CAN1B;IAOlBW,IAAI,EAAEV,OAAO,CAACU,IAARV,IAAgB;EAPJ,CAJU;AAAA,CAAjBH;;AAcN,MAAMc,yBAAyB,GAAG,gBACvCC,IADuC,EAGb;EAAA,IAD1BZ,OAC0B,uEADK,EACL;EAC1B,MAAMC,MAAM,GAAG,MAAMW,IAAI,CAACC,WAALD,EAArB;EAEA,OAAOf,cAAc,CAACI,MAAD,EAASW,IAAI,CAACE,IAAd,EAAoBd,OAApB,CAArB;AACF,CAPO;;AASMe,MAAAA,sBAAsB,GAAG,UACpCC,IADoC,EAInB;EAAA,IAFjBjB,QAEiB,uEAFN,aAEM;EAAA,IADjBC,OACiB,uEADc,EACd;EACjB,IAAIiB,UAAJ;;EAEA,IAAI;IACFA,UAAU,GAAGC,IAAI,CAACC,SAALD,CAAeF,IAAfE,CAAbD;EACD,CAFD,CAEE,OAAOG,KAAP,EAAc;IACd,MAAM,IAAIC,wBAAJ,CAA6BD,KAA7B,CAAN;EACF;;EAEA,OAAOvB,cAAc,CAACoB,UAAD,EAAalB,QAAb,EAAuBC,OAAvB,CAArB;AACF,CAdae;;AAgBAb,MAAAA,wBAAwB,GACnCJ,OAA4B,IACjB;EACX,IAAIA,OAAO,YAAYwB,WAAvB,EAAoC;IAClC,OAAOC,MAAM,CAACC,IAAPD,CAAY,IAAIE,UAAJ,CAAe3B,OAAf,CAAZyB,CAAP;EACF;;EAEA,OAAOA,MAAM,CAACC,IAAPD,CAAYzB,OAAZyB,CAAP;AACF,CARarB;;AAUN,MAAMwB,yBAAyB,GAAG;EAAA,kCAAIC,KAAJ;IAAIA,KAAJ;EAAA;;EAAA,OACvCA,KAAK,CAACC,MAAND,CAAa,CAACE,GAAD,EAAMjB,IAAN,KAAeiB,GAAG,GAAGjB,IAAI,CAACX,MAALW,CAAYkB,UAA9CH,EAA0D,CAA1DA,CADuC;AAAA,CAAlC;;MAGMI,8BAA8B,GAAInB,IAAkB,IAC/D,IAAIoB,IAAJ,CAAS,CAACpB,IAAI,CAACX,MAAN,CAAT,EAAoCW,IAAI,CAACb,QAAzC,C;;AAEWkC,MAAAA,cAAc,GACzBC,YAAiB,IACgB;EACjC,OACEA,YAAY,IAAI,IAAhBA,IACA,OAAOA,YAAP,KAAwB,QADxBA,IAEA,YAAYA,YAFZA,IAGA,cAAcA,YAHdA,IAIA,iBAAiBA,YAJjBA,IAKA,gBAAgBA,YALhBA,IAMA,iBAAiBA,YANjBA,IAOA,eAAeA,YAPfA,IAQA,UAAUA,YATZ;AAWF,CAdaD","sourcesContent":["import { Buffer } from 'buffer';\nimport { getContentType, getExtension, randomStr } from '@/utils';\nimport { InvalidJsonVariableError } from '@/errors';\n\nexport type MetaplexFile = {\n  readonly buffer: Buffer;\n  readonly fileName: string;\n  readonly displayName: string;\n  readonly uniqueName: string;\n  readonly contentType: string | null;\n  readonly extension: string | null;\n  readonly tags: MetaplexFileTag[];\n};\n\nexport type MetaplexFileContent = string | Buffer | Uint8Array | ArrayBuffer;\n\nexport type MetaplexFileTag = { name: string; value: string };\n\nexport type MetaplexFileOptions = {\n  displayName?: string;\n  uniqueName?: string;\n  contentType?: string;\n  extension?: string;\n  tags?: { name: string; value: string }[];\n};\n\nexport const toMetaplexFile = (\n  content: MetaplexFileContent,\n  fileName: string,\n  options: MetaplexFileOptions = {}\n): MetaplexFile => ({\n  buffer: parseMetaplexFileContent(content),\n  fileName,\n  displayName: options.displayName ?? fileName,\n  uniqueName: options.uniqueName ?? randomStr(),\n  contentType: options.contentType ?? getContentType(fileName),\n  extension: options.extension ?? getExtension(fileName),\n  tags: options.tags ?? [],\n});\n\nexport const toMetaplexFileFromBrowser = async (\n  file: File,\n  options: MetaplexFileOptions = {}\n): Promise<MetaplexFile> => {\n  const buffer = await file.arrayBuffer();\n\n  return toMetaplexFile(buffer, file.name, options);\n};\n\nexport const toMetaplexFileFromJson = <T extends object = object>(\n  json: T,\n  fileName = 'inline.json',\n  options: MetaplexFileOptions = {}\n): MetaplexFile => {\n  let jsonString;\n\n  try {\n    jsonString = JSON.stringify(json);\n  } catch (error) {\n    throw new InvalidJsonVariableError(error as Error);\n  }\n\n  return toMetaplexFile(jsonString, fileName, options);\n};\n\nexport const parseMetaplexFileContent = (\n  content: MetaplexFileContent\n): Buffer => {\n  if (content instanceof ArrayBuffer) {\n    return Buffer.from(new Uint8Array(content));\n  }\n\n  return Buffer.from(content);\n};\n\nexport const getBytesFromMetaplexFiles = (...files: MetaplexFile[]): number =>\n  files.reduce((acc, file) => acc + file.buffer.byteLength, 0);\n\nexport const getBrowserFileFromMetaplexFile = (file: MetaplexFile): File =>\n  new File([file.buffer as BlobPart], file.fileName);\n\nexport const isMetaplexFile = (\n  metaplexFile: any\n): metaplexFile is MetaplexFile => {\n  return (\n    metaplexFile != null &&\n    typeof metaplexFile === 'object' &&\n    'buffer' in metaplexFile &&\n    'fileName' in metaplexFile &&\n    'displayName' in metaplexFile &&\n    'uniqueName' in metaplexFile &&\n    'contentType' in metaplexFile &&\n    'extension' in metaplexFile &&\n    'tags' in metaplexFile\n  );\n};\n"]},"metadata":{},"sourceType":"module"}