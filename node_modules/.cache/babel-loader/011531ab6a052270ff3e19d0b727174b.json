{"ast":null,"code":"import { toMetadataAccount, parseOriginalOrPrintEditionAccount } from '../accounts.mjs';\nimport { toMint } from '../../tokenModule/models/Mint.mjs';\nimport { toMintAccount, toTokenAccount } from '../../tokenModule/accounts.mjs';\nimport { toMetadata } from '../models/Metadata.mjs';\nimport { toToken } from '../../tokenModule/models/Token.mjs';\nimport { toNftEdition } from '../models/NftEdition.mjs';\nimport { toNftWithToken, toNft } from '../models/Nft.mjs';\nimport { toSftWithToken, toSft } from '../models/Sft.mjs';\nimport { useOperation } from '../../../types/Operation.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftByMintOperation';\n/**\n * Finds an NFT or an SFT by its mint address.\n *\n * ```ts\n * const nft = await metaplex\n *   .nfts()\n *   .findByMint({ mintAddress };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst findNftByMintOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst findNftByMintOperationHandler = {\n  handle: async (operation, metaplex, scope) => {\n    const {\n      programs,\n      commitment\n    } = scope;\n    const {\n      mintAddress,\n      tokenAddress,\n      tokenOwner,\n      loadJsonMetadata = true\n    } = operation.input;\n    const associatedTokenAddress = tokenOwner ? metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: tokenOwner,\n      programs\n    }) : undefined;\n    const nftPdas = metaplex.nfts().pdas();\n    const accountAddresses = [mintAddress, nftPdas.metadata({\n      mint: mintAddress,\n      programs\n    }), nftPdas.masterEdition({\n      mint: mintAddress,\n      programs\n    }), tokenAddress ?? associatedTokenAddress].filter(address => !!address);\n    const accounts = await metaplex.rpc().getMultipleAccounts(accountAddresses, commitment);\n    scope.throwIfCanceled();\n    const mint = toMint(toMintAccount(accounts[0]));\n    let metadata = toMetadata(toMetadataAccount(accounts[1]));\n    const editionAccount = parseOriginalOrPrintEditionAccount(accounts[2]);\n    const token = accounts[3] ? toToken(toTokenAccount(accounts[3])) : null;\n\n    if (loadJsonMetadata) {\n      try {\n        const json = await metaplex.storage().downloadJson(metadata.uri, scope);\n        metadata = { ...metadata,\n          jsonLoaded: true,\n          json\n        };\n      } catch (error) {\n        metadata = { ...metadata,\n          jsonLoaded: true,\n          json: null\n        };\n      }\n    }\n\n    const isNft = editionAccount.exists && mint.mintAuthorityAddress && mint.mintAuthorityAddress.equals(editionAccount.publicKey);\n\n    if (isNft) {\n      const edition = toNftEdition(editionAccount);\n      return token ? toNftWithToken(metadata, mint, edition, token) : toNft(metadata, mint, edition);\n    }\n\n    return token ? toSftWithToken(metadata, mint, token) : toSft(metadata, mint);\n  }\n};\nexport { findNftByMintOperation, findNftByMintOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/nftModule/operations/findNftByMint.ts"],"names":["Key","findNftByMintOperation","useOperation","findNftByMintOperationHandler","handle","operation","metaplex","scope","programs","commitment","mintAddress","tokenAddress","tokenOwner","loadJsonMetadata","input","associatedTokenAddress","tokens","pdas","associatedTokenAccount","mint","owner","undefined","nftPdas","nfts","accountAddresses","metadata","masterEdition","filter","address","accounts","rpc","getMultipleAccounts","throwIfCanceled","toMint","toMintAccount","toMetadata","toMetadataAccount","editionAccount","parseOriginalOrPrintEditionAccount","token","toToken","toTokenAccount","json","storage","downloadJson","uri","jsonLoaded","error","isNft","exists","mintAuthorityAddress","equals","publicKey","edition","toNftEdition","toNftWithToken","toNft","toSftWithToken","toSft"],"mappings":"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","sourcesContent":["import { PublicKey } from '@solana/web3.js';\nimport {\n  toMint,\n  toMintAccount,\n  toToken,\n  toTokenAccount,\n} from '../../tokenModule';\nimport {\n  parseOriginalOrPrintEditionAccount,\n  toMetadataAccount,\n} from '../accounts';\nimport {\n  JsonMetadata,\n  Nft,\n  NftWithToken,\n  Sft,\n  SftWithToken,\n  toMetadata,\n  toNft,\n  toNftEdition,\n  toNftWithToken,\n  toSft,\n  toSftWithToken,\n} from '../models';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftByMintOperation' as const;\n\n/**\n * Finds an NFT or an SFT by its mint address.\n *\n * ```ts\n * const nft = await metaplex\n *   .nfts()\n *   .findByMint({ mintAddress };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findNftByMintOperation = useOperation<FindNftByMintOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindNftByMintOperation = Operation<\n  typeof Key,\n  FindNftByMintInput,\n  FindNftByMintOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindNftByMintInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The explicit token account to fetch with the NFT or SFT.\n   *\n   * If provided, and if that address is valid, the NFT or SFT returned\n   * will be of the type `NftWithToken` or `SftWithToken` respectively.\n   *\n   * Alternatively, you may use the `tokenOwner` parameter to fetch the\n   * associated token account.\n   *\n   * @defaultValue Defaults to not fetching the token account.\n   */\n  tokenAddress?: PublicKey;\n\n  /**\n   * The associated token account to fetch with the NFT or SFT.\n   *\n   * If provided, and if that account exists, the NFT or SFT returned\n   * will be of the type `NftWithToken` or `SftWithToken` respectively.\n   *\n   * Alternatively, you may use the `tokenAddress` parameter to fetch the\n   * token account at an explicit address.\n   *\n   * @defaultValue Defaults to not fetching the associated token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * Whether or not we should fetch the JSON Metadata for the NFT or SFT.\n   *\n   * @defaultValue `true`\n   */\n  loadJsonMetadata?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindNftByMintOutput = Nft | Sft | NftWithToken | SftWithToken;\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findNftByMintOperationHandler: OperationHandler<FindNftByMintOperation> =\n  {\n    handle: async (\n      operation: FindNftByMintOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FindNftByMintOutput> => {\n      const { programs, commitment } = scope;\n      const {\n        mintAddress,\n        tokenAddress,\n        tokenOwner,\n        loadJsonMetadata = true,\n      } = operation.input;\n\n      const associatedTokenAddress = tokenOwner\n        ? metaplex.tokens().pdas().associatedTokenAccount({\n            mint: mintAddress,\n            owner: tokenOwner,\n            programs,\n          })\n        : undefined;\n      const nftPdas = metaplex.nfts().pdas();\n      const accountAddresses = [\n        mintAddress,\n        nftPdas.metadata({ mint: mintAddress, programs }),\n        nftPdas.masterEdition({ mint: mintAddress, programs }),\n        tokenAddress ?? associatedTokenAddress,\n      ].filter((address): address is PublicKey => !!address);\n\n      const accounts = await metaplex\n        .rpc()\n        .getMultipleAccounts(accountAddresses, commitment);\n      scope.throwIfCanceled();\n\n      const mint = toMint(toMintAccount(accounts[0]));\n      let metadata = toMetadata(toMetadataAccount(accounts[1]));\n      const editionAccount = parseOriginalOrPrintEditionAccount(accounts[2]);\n      const token = accounts[3] ? toToken(toTokenAccount(accounts[3])) : null;\n\n      if (loadJsonMetadata) {\n        try {\n          const json = await metaplex\n            .storage()\n            .downloadJson<JsonMetadata>(metadata.uri, scope);\n          metadata = { ...metadata, jsonLoaded: true, json };\n        } catch (error) {\n          metadata = { ...metadata, jsonLoaded: true, json: null };\n        }\n      }\n\n      const isNft =\n        editionAccount.exists &&\n        mint.mintAuthorityAddress &&\n        mint.mintAuthorityAddress.equals(editionAccount.publicKey);\n\n      if (isNft) {\n        const edition = toNftEdition(editionAccount);\n        return token\n          ? toNftWithToken(metadata, mint, edition, token)\n          : toNft(metadata, mint, edition);\n      }\n\n      return token\n        ? toSftWithToken(metadata, mint, token)\n        : toSft(metadata, mint);\n    },\n  };\n"]},"metadata":{},"sourceType":"module"}