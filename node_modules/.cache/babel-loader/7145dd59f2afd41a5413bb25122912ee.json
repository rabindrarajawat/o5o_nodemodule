{"ast":null,"code":"import { defineProperty as _defineProperty } from '../_virtual/_rollupPluginBabelHelpers.mjs';\nimport { Transaction } from '@solana/web3.js';\n\nclass TransactionBuilder {\n  /** The list of all instructions and their respective signers. */\n\n  /** The signer to use to pay for transaction fees. */\n\n  /** Any additional context gathered when creating the transaction builder. */\n  constructor() {\n    let transactionOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _defineProperty(this, \"records\", []);\n\n    _defineProperty(this, \"feePayer\", undefined);\n\n    _defineProperty(this, \"context\", {});\n\n    this.transactionOptions = transactionOptions;\n  }\n\n  static make(transactionOptions) {\n    return new TransactionBuilder(transactionOptions);\n  }\n\n  prepend() {\n    for (var _len = arguments.length, txs = new Array(_len), _key = 0; _key < _len; _key++) {\n      txs[_key] = arguments[_key];\n    }\n\n    const newRecords = txs.flatMap(tx => tx instanceof TransactionBuilder ? tx.getInstructionsWithSigners() : [tx]);\n    this.records = [...newRecords, ...this.records];\n    return this;\n  }\n\n  append() {\n    for (var _len2 = arguments.length, txs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      txs[_key2] = arguments[_key2];\n    }\n\n    const newRecords = txs.flatMap(tx => tx instanceof TransactionBuilder ? tx.getInstructionsWithSigners() : [tx]);\n    this.records = [...this.records, ...newRecords];\n    return this;\n  }\n\n  add() {\n    return this.append(...arguments);\n  }\n\n  splitUsingKey(key) {\n    let include = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const firstBuilder = new TransactionBuilder(this.transactionOptions);\n    const secondBuilder = new TransactionBuilder(this.transactionOptions);\n    let keyPosition = this.records.findIndex(record => record.key === key);\n\n    if (keyPosition > -1) {\n      keyPosition += include ? 1 : 0;\n      firstBuilder.add(...this.records.slice(0, keyPosition));\n      firstBuilder.add(...this.records.slice(keyPosition));\n    } else {\n      firstBuilder.add(this);\n    }\n\n    return [firstBuilder, secondBuilder];\n  }\n\n  splitBeforeKey(key) {\n    return this.splitUsingKey(key, false);\n  }\n\n  splitAfterKey(key) {\n    return this.splitUsingKey(key, true);\n  }\n\n  getInstructionsWithSigners() {\n    return this.records;\n  }\n\n  getInstructions() {\n    return this.records.map(record => record.instruction);\n  }\n\n  getInstructionCount() {\n    return this.records.length;\n  }\n\n  isEmpty() {\n    return this.getInstructionCount() === 0;\n  }\n\n  getSigners() {\n    const feePayer = this.feePayer == null ? [] : [this.feePayer];\n    const signers = this.records.flatMap(record => record.signers);\n    return [...feePayer, ...signers];\n  }\n\n  setTransactionOptions(transactionOptions) {\n    this.transactionOptions = transactionOptions;\n    return this;\n  }\n\n  getTransactionOptions() {\n    return this.transactionOptions;\n  }\n\n  setFeePayer(feePayer) {\n    this.feePayer = feePayer;\n    return this;\n  }\n\n  getFeePayer() {\n    return this.feePayer;\n  }\n\n  setContext(context) {\n    this.context = context;\n    return this;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  when(condition, callback) {\n    return condition ? callback(this) : this;\n  }\n\n  unless(condition, callback) {\n    return this.when(!condition, callback);\n  }\n\n  toTransaction(blockhashWithExpiryBlockHeight) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = { ...this.getTransactionOptions(),\n      ...options\n    };\n    const transaction = new Transaction({\n      feePayer: this.getFeePayer()?.publicKey,\n      signatures: options.signatures,\n      blockhash: blockhashWithExpiryBlockHeight.blockhash,\n      lastValidBlockHeight: blockhashWithExpiryBlockHeight.lastValidBlockHeight\n    });\n    transaction.add(...this.getInstructions());\n    return transaction;\n  }\n\n  async sendAndConfirm(metaplex, confirmOptions) {\n    const response = await metaplex.rpc().sendAndConfirmTransaction(this, confirmOptions);\n    return {\n      response,\n      ...this.getContext()\n    };\n  }\n\n}\n\nexport { TransactionBuilder };","map":{"version":3,"sources":["../../../src/utils/TransactionBuilder.ts"],"names":["TransactionBuilder","undefined","constructor","transactionOptions","make","prepend","txs","newRecords","flatMap","tx","getInstructionsWithSigners","records","append","add","splitUsingKey","key","include","firstBuilder","secondBuilder","keyPosition","findIndex","record","slice","splitBeforeKey","splitAfterKey","getInstructions","map","instruction","getInstructionCount","length","isEmpty","getSigners","feePayer","signers","setTransactionOptions","getTransactionOptions","setFeePayer","getFeePayer","setContext","context","getContext","when","condition","callback","unless","toTransaction","blockhashWithExpiryBlockHeight","options","transaction","Transaction","publicKey","signatures","blockhash","lastValidBlockHeight","sendAndConfirm","metaplex","confirmOptions","response","rpc","sendAndConfirmTransaction"],"mappings":"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","sourcesContent":["import {\n  BlockhashWithExpiryBlockHeight,\n  ConfirmOptions,\n  SignaturePubkeyPair,\n  Transaction,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../plugins/rpcModule';\nimport type { Metaplex } from '@/Metaplex';\nimport type { OperationOptions, Signer } from '@/types';\n\nexport type InstructionWithSigners = {\n  instruction: TransactionInstruction;\n  signers: Signer[];\n  key?: string;\n};\n\ntype TransactionOptions = {\n  /** Additional signatures. */\n  signatures?: Array<SignaturePubkeyPair>;\n};\n\nexport type TransactionBuilderOptions = Pick<\n  OperationOptions,\n  'programs' | 'payer'\n>;\n\nexport class TransactionBuilder<C extends object = object> {\n  /** The list of all instructions and their respective signers. */\n  protected records: InstructionWithSigners[] = [];\n\n  /** Options used when building the transaction. */\n  protected transactionOptions: TransactionOptions;\n\n  /** The signer to use to pay for transaction fees. */\n  protected feePayer: Signer | undefined = undefined;\n\n  /** Any additional context gathered when creating the transaction builder. */\n  protected context: C = {} as C;\n\n  constructor(transactionOptions: TransactionOptions = {}) {\n    this.transactionOptions = transactionOptions;\n  }\n\n  static make<C extends object = object>(\n    transactionOptions?: TransactionOptions\n  ): TransactionBuilder<C> {\n    return new TransactionBuilder<C>(transactionOptions);\n  }\n\n  prepend(\n    ...txs: (InstructionWithSigners | TransactionBuilder)[]\n  ): TransactionBuilder<C> {\n    const newRecords = txs.flatMap((tx) =>\n      tx instanceof TransactionBuilder ? tx.getInstructionsWithSigners() : [tx]\n    );\n    this.records = [...newRecords, ...this.records];\n\n    return this;\n  }\n\n  append(\n    ...txs: (InstructionWithSigners | TransactionBuilder)[]\n  ): TransactionBuilder<C> {\n    const newRecords = txs.flatMap((tx) =>\n      tx instanceof TransactionBuilder ? tx.getInstructionsWithSigners() : [tx]\n    );\n    this.records = [...this.records, ...newRecords];\n\n    return this;\n  }\n\n  add(\n    ...txs: (InstructionWithSigners | TransactionBuilder)[]\n  ): TransactionBuilder<C> {\n    return this.append(...txs);\n  }\n\n  splitUsingKey(\n    key: string,\n    include = true\n  ): [TransactionBuilder, TransactionBuilder] {\n    const firstBuilder = new TransactionBuilder(this.transactionOptions);\n    const secondBuilder = new TransactionBuilder(this.transactionOptions);\n    let keyPosition = this.records.findIndex((record) => record.key === key);\n\n    if (keyPosition > -1) {\n      keyPosition += include ? 1 : 0;\n      firstBuilder.add(...this.records.slice(0, keyPosition));\n      firstBuilder.add(...this.records.slice(keyPosition));\n    } else {\n      firstBuilder.add(this);\n    }\n\n    return [firstBuilder, secondBuilder];\n  }\n\n  splitBeforeKey(key: string): [TransactionBuilder, TransactionBuilder] {\n    return this.splitUsingKey(key, false);\n  }\n\n  splitAfterKey(key: string): [TransactionBuilder, TransactionBuilder] {\n    return this.splitUsingKey(key, true);\n  }\n\n  getInstructionsWithSigners(): InstructionWithSigners[] {\n    return this.records;\n  }\n\n  getInstructions(): TransactionInstruction[] {\n    return this.records.map((record) => record.instruction);\n  }\n\n  getInstructionCount(): number {\n    return this.records.length;\n  }\n\n  isEmpty(): boolean {\n    return this.getInstructionCount() === 0;\n  }\n\n  getSigners(): Signer[] {\n    const feePayer = this.feePayer == null ? [] : [this.feePayer];\n    const signers = this.records.flatMap((record) => record.signers);\n\n    return [...feePayer, ...signers];\n  }\n\n  setTransactionOptions(\n    transactionOptions: TransactionOptions\n  ): TransactionBuilder<C> {\n    this.transactionOptions = transactionOptions;\n\n    return this;\n  }\n\n  getTransactionOptions(): TransactionOptions | undefined {\n    return this.transactionOptions;\n  }\n\n  setFeePayer(feePayer: Signer): TransactionBuilder<C> {\n    this.feePayer = feePayer;\n\n    return this;\n  }\n\n  getFeePayer(): Signer | undefined {\n    return this.feePayer;\n  }\n\n  setContext(context: C): TransactionBuilder<C> {\n    this.context = context;\n\n    return this;\n  }\n\n  getContext(): C {\n    return this.context;\n  }\n\n  when(\n    condition: boolean,\n    callback: (tx: TransactionBuilder<C>) => TransactionBuilder<C>\n  ) {\n    return condition ? callback(this) : this;\n  }\n\n  unless(\n    condition: boolean,\n    callback: (tx: TransactionBuilder<C>) => TransactionBuilder<C>\n  ) {\n    return this.when(!condition, callback);\n  }\n\n  toTransaction(\n    blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight,\n    options: TransactionOptions = {}\n  ): Transaction {\n    options = { ...this.getTransactionOptions(), ...options };\n\n    const transaction = new Transaction({\n      feePayer: this.getFeePayer()?.publicKey,\n      signatures: options.signatures,\n      blockhash: blockhashWithExpiryBlockHeight.blockhash,\n      lastValidBlockHeight: blockhashWithExpiryBlockHeight.lastValidBlockHeight,\n    });\n\n    transaction.add(...this.getInstructions());\n\n    return transaction;\n  }\n\n  async sendAndConfirm(\n    metaplex: Metaplex,\n    confirmOptions?: ConfirmOptions\n  ): Promise<{ response: SendAndConfirmTransactionResponse } & C> {\n    const response = await metaplex\n      .rpc()\n      .sendAndConfirmTransaction(this, confirmOptions);\n\n    return {\n      response,\n      ...this.getContext(),\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}