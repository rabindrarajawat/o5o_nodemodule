{"ast":null,"code":"import { defineProperty as _defineProperty } from '../../_virtual/_rollupPluginBabelHelpers.mjs';\nimport { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport { CANDY_GUARD_LABEL_SIZE } from './constants.mjs';\nimport { UnregisteredCandyGuardError, GuardGroupLabelTooLongError, SelectedGuardGroupDoesNotExistError, GuardGroupRequiredError, GuardRouteNotSupportedError, GuardNotEnabledError } from './errors.mjs';\nimport { serialize, deserialize } from '../../types/Serializer.mjs';\nimport { serializeFeatureFlags, deserializeFeatureFlags } from '../../types/FeatureFlags.mjs';\nimport { padEmptyChars, removeEmptyChars } from '../../utils/common.mjs';\n/**\n * This client enables us to register custom guards from\n * custom Candy Guard programs and interact with them.\n *\n * @see {@link CandyGuardClient}\n * @group Module\n */\n\nclass CandyMachineGuardsClient {\n  constructor(metaplex) {\n    _defineProperty(this, \"guards\", []);\n\n    this.metaplex = metaplex;\n  }\n  /** Registers one or many guards by providing their manifest. */\n\n\n  register() {\n    this.guards.push(...arguments);\n  }\n  /** Gets the manifest of a guard using its name. */\n\n\n  get(name) {\n    const guard = this.guards.find(guard => guard.name === name);\n\n    if (!guard) {\n      throw new UnregisteredCandyGuardError(name);\n    }\n\n    return guard;\n  }\n  /** Gets all registered guard manifests. */\n\n\n  all() {\n    return this.guards;\n  }\n  /**\n   * Gets all guard manifests for a registered Candy Guard program.\n   *\n   * It fails if the manifest of any guard expected by the program\n   * is not registered. Manifests are returned in the order in which\n   * they are defined on the `availableGuards` property of the program.\n   */\n\n\n  forProgram() {\n    let program = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'CandyGuardProgram';\n    const candyGuardProgram = typeof program === 'object' && 'availableGuards' in program ? program : this.metaplex.programs().get(program);\n    return candyGuardProgram.availableGuards.map(name => this.get(name));\n  }\n  /**\n   * Gets all guard manifests for the registered Candy Guard program.\n   *\n   * @see {@link CandyMachineGuardsClient.forProgram}\n   */\n\n\n  forCandyGuardProgram() {\n    let programs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const candyGuardProgram = this.metaplex.programs().getCandyGuard(programs);\n    return this.forProgram(candyGuardProgram);\n  }\n  /** Serializes the settings of all guards and groups. */\n\n\n  serializeSettings(guards) {\n    let groups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let programs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    const availableGuards = this.forCandyGuardProgram(programs);\n    this.assertGuardsAreRegistered(guards, groups, availableGuards.map(_ref => {\n      let {\n        name\n      } = _ref;\n      return name;\n    }));\n\n    const serializeSet = set => {\n      const {\n        features,\n        buffer\n      } = availableGuards.reduce((acc, guard, index) => {\n        const value = set[guard.name] ?? null;\n        acc.features[index] = Boolean(value);\n\n        if (value) {\n          acc.buffer = Buffer.concat([acc.buffer, serialize(value, guard.settingsSerializer)]);\n        }\n\n        return acc;\n      }, {\n        features: [],\n        buffer: Buffer.from([])\n      });\n      const serializedfeatures = serializeFeatureFlags(features, 8, true);\n      serializedfeatures.reverse();\n      return Buffer.concat([serializedfeatures, buffer]);\n    };\n\n    let buffer = serializeSet(guards);\n    const groupCountBuffer = Buffer.alloc(4);\n    beet.u32.write(groupCountBuffer, 0, groups.length);\n    buffer = Buffer.concat([buffer, groupCountBuffer]);\n    groups.forEach(group => {\n      if (group.label.length > CANDY_GUARD_LABEL_SIZE) {\n        throw new GuardGroupLabelTooLongError(group.label, CANDY_GUARD_LABEL_SIZE);\n      }\n\n      const labelBuffer = Buffer.alloc(CANDY_GUARD_LABEL_SIZE);\n      labelBuffer.write(padEmptyChars(group.label, CANDY_GUARD_LABEL_SIZE), 0, CANDY_GUARD_LABEL_SIZE, 'utf8');\n      buffer = Buffer.concat([buffer, labelBuffer, serializeSet(group.guards)]);\n    });\n    return buffer;\n  }\n  /** Deserializes the settings of all guards and groups. */\n\n\n  deserializeSettings(buffer) {\n    let program = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'CandyGuardProgram';\n    const availableGuards = this.forProgram(program);\n\n    const deserializeSet = () => {\n      const serializedFeatures = buffer.slice(0, 8);\n      serializedFeatures.reverse();\n      const features = deserializeFeatureFlags(serializedFeatures, 64, true);\n      buffer = buffer.slice(8);\n      return availableGuards.reduce((acc, guard, index) => {\n        const isEnabled = features[index] ?? false;\n        acc[guard.name] = null;\n        if (!isEnabled) return acc;\n        const [settings] = deserialize(buffer, guard.settingsSerializer);\n        buffer = buffer.slice(guard.settingsBytes);\n        acc[guard.name] = settings;\n        return acc;\n      }, {});\n    };\n\n    const guards = deserializeSet();\n    const groups = [];\n    const groupsCount = beet.u32.read(buffer, 0);\n    buffer = buffer.slice(4);\n\n    for (let i = 0; i < groupsCount; i++) {\n      const label = removeEmptyChars(buffer.slice(0, CANDY_GUARD_LABEL_SIZE).toString('utf8'));\n      buffer = buffer.slice(CANDY_GUARD_LABEL_SIZE);\n      groups.push({\n        label,\n        guards: deserializeSet()\n      });\n    }\n\n    return {\n      guards,\n      groups\n    };\n  }\n  /**\n   * Resolves the set of settings that should be used when minting.\n   *\n   * If no group exists, the `guards` settings will be used.\n   * Otherwise, the `guards` settings will act as default settings and\n   * the settings of the selected group will override them.\n   */\n\n\n  resolveGroupSettings(guards) {\n    let groups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let groupLabel = arguments.length > 2 ? arguments[2] : undefined;\n    const availableGroups = groups.map(group => group.label);\n    const activeGroup = groups.find(group => group.label === groupLabel);\n\n    if (groupLabel && !activeGroup) {\n      throw new SelectedGuardGroupDoesNotExistError(groupLabel, availableGroups);\n    }\n\n    if (groups.length === 0) {\n      return guards;\n    }\n\n    if (!activeGroup) {\n      throw new GuardGroupRequiredError(availableGroups);\n    }\n\n    const activeGroupGuardsWithoutNullGuards = Object.fromEntries(Object.entries(activeGroup.guards).filter(_ref2 => {\n      let [, v] = _ref2;\n      return v != null;\n    }));\n    return { ...guards,\n      ...activeGroupGuardsWithoutNullGuards\n    };\n  }\n  /**\n   * Parses the arguments and remaining accounts of\n   * all relevant guards for the mint instruction.\n   */\n\n\n  parseMintSettings(candyMachine, candyGuard, owner, payer, mint, guardMintSettings, groupLabel) {\n    let programs = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];\n    const availableGuards = this.forCandyGuardProgram(programs);\n    const guardSettings = this.resolveGroupSettings(candyGuard.guards, candyGuard.groups, groupLabel);\n    const initialAccumulator = {\n      arguments: Buffer.from([]),\n      accountMetas: [],\n      signers: []\n    };\n    return availableGuards.reduce((acc, guard) => {\n      const settings = guardSettings[guard.name] ?? null;\n      const mintSettings = guardMintSettings[guard.name] ?? null;\n      if (!guard.mintSettingsParser || !settings) return acc;\n      const parsedSettings = guard.mintSettingsParser({\n        metaplex: this.metaplex,\n        settings,\n        mintSettings,\n        owner,\n        payer,\n        mint,\n        candyMachine,\n        candyGuard: candyGuard.address,\n        candyGuardAuthority: candyGuard.authorityAddress,\n        programs\n      });\n      const accounts = this.getAccountMetas(parsedSettings.remainingAccounts);\n      const signers = this.getSigners(parsedSettings.remainingAccounts);\n      acc.arguments = Buffer.concat([acc.arguments, parsedSettings.arguments]);\n      acc.accountMetas.push(...accounts);\n      acc.signers.push(...signers);\n      return acc;\n    }, initialAccumulator);\n  }\n  /**\n   * Parses the arguments and remaining accounts of\n   * the requested guard for the route instruction.\n   */\n\n\n  parseRouteSettings(candyMachine, candyGuard, payer, guard, routeSettings, groupLabel) {\n    let programs = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    const guardManifest = this.get(guard);\n\n    if (!guardManifest.routeSettingsParser) {\n      throw new GuardRouteNotSupportedError(guard);\n    }\n\n    const guardSettings = this.resolveGroupSettings(candyGuard.guards, candyGuard.groups, groupLabel);\n    const settings = guardSettings[guard] ?? null;\n\n    if (!settings) {\n      throw new GuardNotEnabledError(guard, groupLabel);\n    }\n\n    const parsedSettings = guardManifest.routeSettingsParser({\n      metaplex: this.metaplex,\n      settings,\n      routeSettings,\n      payer,\n      candyMachine,\n      candyGuard: candyGuard.address,\n      candyGuardAuthority: candyGuard.authorityAddress,\n      programs\n    });\n    return {\n      arguments: parsedSettings.arguments,\n      accountMetas: this.getAccountMetas(parsedSettings.remainingAccounts),\n      signers: this.getSigners(parsedSettings.remainingAccounts)\n    };\n  }\n  /** @internal */\n\n\n  getAccountMetas(remainingAccounts) {\n    return remainingAccounts.map(account => ({\n      pubkey: account.isSigner ? account.address.publicKey : account.address,\n      isSigner: account.isSigner,\n      isWritable: account.isWritable\n    }));\n  }\n  /** @internal */\n\n\n  getSigners(remainingAccounts) {\n    return remainingAccounts.filter(account => account.isSigner).map(account => account.address);\n  }\n  /** @internal */\n\n\n  assertGuardsAreRegistered(guards, groups, availableGuardNames) {\n    const guardNames = new Set();\n\n    const addGuardSet = guardSet => {\n      Object.keys(guardSet).forEach(name => {\n        if (!!guardSet[name]) {\n          guardNames.add(name);\n        }\n      });\n    };\n\n    addGuardSet(guards);\n    groups.forEach(group => addGuardSet(group.guards));\n    guardNames.forEach(name => {\n      if (!availableGuardNames.includes(name)) {\n        throw new UnregisteredCandyGuardError(name);\n      }\n    });\n  }\n\n}\n\nexport { CandyMachineGuardsClient };","map":{"version":3,"sources":["../../../../src/plugins/candyMachineModule/CandyMachineGuardsClient.ts"],"names":["CandyMachineGuardsClient","constructor","metaplex","register","guards","push","get","name","guard","find","UnregisteredCandyGuardError","all","forProgram","program","candyGuardProgram","programs","availableGuards","map","forCandyGuardProgram","getCandyGuard","serializeSettings","groups","assertGuardsAreRegistered","serializeSet","set","features","buffer","reduce","acc","index","value","Boolean","Buffer","concat","serialize","settingsSerializer","from","serializedfeatures","serializeFeatureFlags","reverse","groupCountBuffer","alloc","beet","u32","write","length","forEach","group","label","CANDY_GUARD_LABEL_SIZE","GuardGroupLabelTooLongError","labelBuffer","padEmptyChars","deserializeSettings","deserializeSet","serializedFeatures","slice","deserializeFeatureFlags","isEnabled","settings","deserialize","settingsBytes","groupsCount","read","i","removeEmptyChars","toString","resolveGroupSettings","groupLabel","availableGroups","activeGroup","SelectedGuardGroupDoesNotExistError","GuardGroupRequiredError","activeGroupGuardsWithoutNullGuards","Object","fromEntries","entries","filter","v","parseMintSettings","candyMachine","candyGuard","owner","payer","mint","guardMintSettings","guardSettings","initialAccumulator","arguments","accountMetas","signers","mintSettings","mintSettingsParser","parsedSettings","address","candyGuardAuthority","authorityAddress","accounts","getAccountMetas","remainingAccounts","getSigners","parseRouteSettings","routeSettings","guardManifest","routeSettingsParser","GuardRouteNotSupportedError","GuardNotEnabledError","account","pubkey","isSigner","publicKey","isWritable","availableGuardNames","guardNames","Set","addGuardSet","guardSet","keys","add","includes"],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport { AccountMeta } from '@solana/web3.js';\nimport { CANDY_GUARD_LABEL_SIZE } from './constants';\nimport {\n  GuardGroupLabelTooLongError,\n  GuardGroupRequiredError,\n  GuardNotEnabledError,\n  GuardRouteNotSupportedError,\n  SelectedGuardGroupDoesNotExistError,\n  UnregisteredCandyGuardError,\n} from './errors';\nimport {\n  CandyGuardManifest,\n  CandyGuardsMintSettings,\n  CandyGuardsRemainingAccount,\n  CandyGuardsRouteSettings,\n  CandyGuardsSettings,\n  DefaultCandyGuardRouteSettings,\n  DefaultCandyGuardSettings,\n} from './guards';\nimport { CandyGuard } from './models';\nimport { CandyGuardProgram } from './programs';\nimport { Option, padEmptyChars, removeEmptyChars } from '@/utils';\nimport {\n  deserialize,\n  deserializeFeatureFlags,\n  Program,\n  PublicKey,\n  serialize,\n  serializeFeatureFlags,\n  Signer,\n} from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n/**\n * This client enables us to register custom guards from\n * custom Candy Guard programs and interact with them.\n *\n * @see {@link CandyGuardClient}\n * @group Module\n */\nexport class CandyMachineGuardsClient {\n  readonly guards: CandyGuardManifest<any, any, any>[] = [];\n\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /** Registers one or many guards by providing their manifest. */\n  register(...guard: CandyGuardManifest<any, any, any>[]) {\n    this.guards.push(...guard);\n  }\n\n  /** Gets the manifest of a guard using its name. */\n  get(name: string): CandyGuardManifest<any, any, any> {\n    const guard = this.guards.find((guard) => guard.name === name);\n\n    if (!guard) {\n      throw new UnregisteredCandyGuardError(name);\n    }\n\n    return guard;\n  }\n\n  /** Gets all registered guard manifests. */\n  all(): CandyGuardManifest<any, any, any>[] {\n    return this.guards;\n  }\n\n  /**\n   * Gets all guard manifests for a registered Candy Guard program.\n   *\n   * It fails if the manifest of any guard expected by the program\n   * is not registered. Manifests are returned in the order in which\n   * they are defined on the `availableGuards` property of the program.\n   */\n  forProgram(\n    program: string | PublicKey | CandyGuardProgram = 'CandyGuardProgram'\n  ): CandyGuardManifest<any, any, any>[] {\n    const candyGuardProgram =\n      typeof program === 'object' && 'availableGuards' in program\n        ? program\n        : this.metaplex.programs().get<CandyGuardProgram>(program);\n\n    return candyGuardProgram.availableGuards.map((name) => this.get(name));\n  }\n\n  /**\n   * Gets all guard manifests for the registered Candy Guard program.\n   *\n   * @see {@link CandyMachineGuardsClient.forProgram}\n   */\n  forCandyGuardProgram(\n    programs: Program[] = []\n  ): CandyGuardManifest<any, any, any>[] {\n    const candyGuardProgram = this.metaplex.programs().getCandyGuard(programs);\n\n    return this.forProgram(candyGuardProgram);\n  }\n\n  /** Serializes the settings of all guards and groups. */\n  serializeSettings<T extends CandyGuardsSettings = DefaultCandyGuardSettings>(\n    guards: Partial<T>,\n    groups: { label: string; guards: Partial<T> }[] = [],\n    programs: Program[] = []\n  ): Buffer {\n    const availableGuards = this.forCandyGuardProgram(programs);\n    this.assertGuardsAreRegistered<T>(\n      guards,\n      groups,\n      availableGuards.map(({ name }) => name)\n    );\n\n    const serializeSet = (set: Partial<T>): Buffer => {\n      const { features, buffer } = availableGuards.reduce(\n        (acc, guard, index) => {\n          const value = set[guard.name] ?? null;\n          acc.features[index] = Boolean(value);\n          if (value) {\n            acc.buffer = Buffer.concat([\n              acc.buffer,\n              serialize(value, guard.settingsSerializer),\n            ]);\n          }\n          return acc;\n        },\n        {\n          features: [] as boolean[],\n          buffer: Buffer.from([]),\n        }\n      );\n\n      const serializedfeatures = serializeFeatureFlags(features, 8, true);\n      serializedfeatures.reverse();\n\n      return Buffer.concat([serializedfeatures, buffer]);\n    };\n\n    let buffer = serializeSet(guards);\n\n    const groupCountBuffer = Buffer.alloc(4);\n    beet.u32.write(groupCountBuffer, 0, groups.length);\n    buffer = Buffer.concat([buffer, groupCountBuffer]);\n\n    groups.forEach((group) => {\n      if (group.label.length > CANDY_GUARD_LABEL_SIZE) {\n        throw new GuardGroupLabelTooLongError(\n          group.label,\n          CANDY_GUARD_LABEL_SIZE\n        );\n      }\n      const labelBuffer = Buffer.alloc(CANDY_GUARD_LABEL_SIZE);\n      labelBuffer.write(\n        padEmptyChars(group.label, CANDY_GUARD_LABEL_SIZE),\n        0,\n        CANDY_GUARD_LABEL_SIZE,\n        'utf8'\n      );\n      buffer = Buffer.concat([buffer, labelBuffer, serializeSet(group.guards)]);\n    });\n\n    return buffer;\n  }\n\n  /** Deserializes the settings of all guards and groups. */\n  deserializeSettings<\n    T extends CandyGuardsSettings = DefaultCandyGuardSettings\n  >(\n    buffer: Buffer,\n    program: string | PublicKey | CandyGuardProgram = 'CandyGuardProgram'\n  ): { guards: T; groups: { label: string; guards: T }[] } {\n    const availableGuards = this.forProgram(program);\n    const deserializeSet = () => {\n      const serializedFeatures = buffer.slice(0, 8);\n      serializedFeatures.reverse();\n      const features = deserializeFeatureFlags(serializedFeatures, 64, true);\n      buffer = buffer.slice(8);\n\n      return availableGuards.reduce((acc, guard, index) => {\n        const isEnabled = features[index] ?? false;\n        acc[guard.name] = null;\n        if (!isEnabled) return acc;\n\n        const [settings] = deserialize(buffer, guard.settingsSerializer);\n        buffer = buffer.slice(guard.settingsBytes);\n        acc[guard.name] = settings;\n        return acc;\n      }, {} as CandyGuardsSettings) as T;\n    };\n\n    const guards: T = deserializeSet();\n    const groups: { label: string; guards: T }[] = [];\n    const groupsCount = beet.u32.read(buffer, 0);\n    buffer = buffer.slice(4);\n\n    for (let i = 0; i < groupsCount; i++) {\n      const label = removeEmptyChars(\n        buffer.slice(0, CANDY_GUARD_LABEL_SIZE).toString('utf8')\n      );\n      buffer = buffer.slice(CANDY_GUARD_LABEL_SIZE);\n      groups.push({ label, guards: deserializeSet() });\n    }\n\n    return { guards, groups };\n  }\n\n  /**\n   * Resolves the set of settings that should be used when minting.\n   *\n   * If no group exists, the `guards` settings will be used.\n   * Otherwise, the `guards` settings will act as default settings and\n   * the settings of the selected group will override them.\n   */\n  resolveGroupSettings<\n    T extends CandyGuardsSettings = DefaultCandyGuardSettings\n  >(\n    guards: T,\n    groups: { label: string; guards: T }[] = [],\n    groupLabel: Option<string>\n  ): T {\n    const availableGroups = groups.map((group) => group.label);\n    const activeGroup = groups.find((group) => group.label === groupLabel);\n    if (groupLabel && !activeGroup) {\n      throw new SelectedGuardGroupDoesNotExistError(\n        groupLabel,\n        availableGroups\n      );\n    }\n\n    if (groups.length === 0) {\n      return guards;\n    }\n\n    if (!activeGroup) {\n      throw new GuardGroupRequiredError(availableGroups);\n    }\n\n    const activeGroupGuardsWithoutNullGuards = Object.fromEntries(\n      Object.entries(activeGroup.guards).filter(([, v]) => v != null)\n    ) as Partial<T>;\n\n    return {\n      ...guards,\n      ...activeGroupGuardsWithoutNullGuards,\n    };\n  }\n\n  /**\n   * Parses the arguments and remaining accounts of\n   * all relevant guards for the mint instruction.\n   */\n  parseMintSettings<\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    MintSettings extends CandyGuardsMintSettings = {}\n  >(\n    candyMachine: PublicKey,\n    candyGuard: CandyGuard<Settings>,\n    owner: PublicKey,\n    payer: Signer,\n    mint: Signer,\n    guardMintSettings: Partial<MintSettings>,\n    groupLabel: Option<string>,\n    programs: Program[] = []\n  ): {\n    arguments: Buffer;\n    accountMetas: AccountMeta[];\n    signers: Signer[];\n  } {\n    const availableGuards = this.forCandyGuardProgram(programs);\n    const guardSettings = this.resolveGroupSettings(\n      candyGuard.guards,\n      candyGuard.groups,\n      groupLabel\n    );\n    const initialAccumulator = {\n      arguments: Buffer.from([]),\n      accountMetas: [] as AccountMeta[],\n      signers: [] as Signer[],\n    };\n\n    return availableGuards.reduce((acc, guard) => {\n      const settings = guardSettings[guard.name] ?? null;\n      const mintSettings = guardMintSettings[guard.name] ?? null;\n      if (!guard.mintSettingsParser || !settings) return acc;\n\n      const parsedSettings = guard.mintSettingsParser({\n        metaplex: this.metaplex,\n        settings,\n        mintSettings,\n        owner,\n        payer,\n        mint,\n        candyMachine,\n        candyGuard: candyGuard.address,\n        candyGuardAuthority: candyGuard.authorityAddress,\n        programs,\n      });\n\n      const accounts = this.getAccountMetas(parsedSettings.remainingAccounts);\n      const signers = this.getSigners(parsedSettings.remainingAccounts);\n      acc.arguments = Buffer.concat([acc.arguments, parsedSettings.arguments]);\n      acc.accountMetas.push(...accounts);\n      acc.signers.push(...signers);\n      return acc;\n    }, initialAccumulator);\n  }\n\n  /**\n   * Parses the arguments and remaining accounts of\n   * the requested guard for the route instruction.\n   */\n  parseRouteSettings<\n    Guard extends keyof RouteSettings & string,\n    Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n    RouteSettings extends CandyGuardsRouteSettings = DefaultCandyGuardRouteSettings\n  >(\n    candyMachine: PublicKey,\n    candyGuard: CandyGuard<Settings>,\n    payer: Signer,\n    guard: Guard,\n    routeSettings: RouteSettings[Guard],\n    groupLabel: Option<string>,\n    programs: Program[] = []\n  ): {\n    arguments: Buffer;\n    accountMetas: AccountMeta[];\n    signers: Signer[];\n  } {\n    const guardManifest = this.get(guard);\n    if (!guardManifest.routeSettingsParser) {\n      throw new GuardRouteNotSupportedError(guard);\n    }\n\n    const guardSettings = this.resolveGroupSettings(\n      candyGuard.guards,\n      candyGuard.groups,\n      groupLabel\n    );\n    const settings = guardSettings[guard] ?? null;\n    if (!settings) {\n      throw new GuardNotEnabledError(guard, groupLabel);\n    }\n\n    const parsedSettings = guardManifest.routeSettingsParser({\n      metaplex: this.metaplex,\n      settings,\n      routeSettings,\n      payer,\n      candyMachine,\n      candyGuard: candyGuard.address,\n      candyGuardAuthority: candyGuard.authorityAddress,\n      programs,\n    });\n\n    return {\n      arguments: parsedSettings.arguments,\n      accountMetas: this.getAccountMetas(parsedSettings.remainingAccounts),\n      signers: this.getSigners(parsedSettings.remainingAccounts),\n    };\n  }\n\n  /** @internal */\n  protected getAccountMetas(\n    remainingAccounts: CandyGuardsRemainingAccount[]\n  ): AccountMeta[] {\n    return remainingAccounts.map((account) => ({\n      pubkey: account.isSigner ? account.address.publicKey : account.address,\n      isSigner: account.isSigner,\n      isWritable: account.isWritable,\n    }));\n  }\n\n  /** @internal */\n  protected getSigners(\n    remainingAccounts: CandyGuardsRemainingAccount[]\n  ): Signer[] {\n    return remainingAccounts\n      .filter((account) => account.isSigner)\n      .map((account) => account.address as Signer);\n  }\n\n  /** @internal */\n  protected assertGuardsAreRegistered<\n    T extends CandyGuardsSettings = DefaultCandyGuardSettings\n  >(\n    guards: Partial<T>,\n    groups: { label: string; guards: Partial<T> }[],\n    availableGuardNames: string[]\n  ): void {\n    const guardNames = new Set<string>();\n    const addGuardSet = (guardSet: Partial<T>) => {\n      Object.keys(guardSet).forEach((name) => {\n        if (!!guardSet[name]) {\n          guardNames.add(name);\n        }\n      });\n    };\n\n    addGuardSet(guards);\n    groups.forEach((group) => addGuardSet(group.guards));\n\n    guardNames.forEach((name) => {\n      if (!availableGuardNames.includes(name)) {\n        throw new UnregisteredCandyGuardError(name);\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}