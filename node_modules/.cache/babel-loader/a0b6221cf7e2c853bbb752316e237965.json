{"ast":null,"code":"// /* eslint-disable react-hooks/exhaustive-deps */\n// /* eslint-disable eqeqeq */\n// /* eslint-disable @typescript-eslint/no-unused-vars */\n// import { AnchorWallet, useAnchorWallet } from \"@solana/wallet-adapter-react\";\n// import { useEffect, useState } from \"react\";\n// import * as anchor from \"@project-serum/anchor\";\n// import useWalletBalance from \"./use-wallet-balance\";\n// import {\n//   TOKEN_PROGRAM_ID,\n//   ASSOCIATED_TOKEN_PROGRAM_ID,\n//   Token,\n// } from \"@solana/spl-token\";\n// import { programs } from \"@metaplex/js\";\n// import toast from \"react-hot-toast\";\n// import {\n//   Keypair,\n//   PublicKey,\n//   Transaction,\n//   ConfirmOptions,\n//   LAMPORTS_PER_SOL,\n//   Connection,\n// } from \"@solana/web3.js\";\n// import * as splToken from \"@solana/spl-token\";\n// import axios from \"axios\";\n// import {\n//   STAKE_DATA_SIZE,\n//   STAKE_CONTRACT_IDL,\n//   COLLECTION_NAME,\n// } from \"../constant/contract\";\n// import {\n//   GLOBAL_AUTHORITY_SEED,\n//   NEXT_PUBLIC_SOLANA_NETWORK,\n//   NEXT_PUBLIC_STAKE_CONTRACT_ID,\n//   REWARD_TOKEN,\n//   REWARD_TOKEN_DECIMALS,\n//   USER_POOL_DATA_SEED,\n//   USER_POOL_SEED,\n// } from \"../constant/env\";\n// import { printLog } from \"../utils/utility\";\n// import { sendTransactions } from \"../helpers/sol/connection\";\n// const {\n//   metadata: { Metadata },\n// } = programs;\n// const TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n//   \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n// );\n// // const connection = new anchor.web3.Connection(\n// //   NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\"\n// //     ? \"https://metaplex.devnet.rpcpool.com\"\n// //     : \"https://metaplex.mainnet.rpcpool.com\"\n// // );\n// const connection = new anchor.web3.Connection(\n//   NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\"\n//     ? \"https://api.devnet.solana.com\"\n//     : \"https://metaplex.mainnet.rpcpool.com\"\n// );\n// const programId = new PublicKey(NEXT_PUBLIC_STAKE_CONTRACT_ID!);\n// const idl = STAKE_CONTRACT_IDL as anchor.Idl;\n// const confirmOption: ConfirmOptions = {\n//   commitment: \"finalized\",\n//   preflightCommitment: \"finalized\",\n//   skipPreflight: false,\n// };\n// const rewardMint = new PublicKey(REWARD_TOKEN);\n// const createAssociatedTokenAccountInstruction = (\n//   associatedTokenAddress: anchor.web3.PublicKey,\n//   payer: anchor.web3.PublicKey,\n//   walletAddress: anchor.web3.PublicKey,\n//   splTokenMintAddress: anchor.web3.PublicKey\n// ) => {\n//   const keys = [\n//     { pubkey: payer, isSigner: true, isWritable: true },\n//     { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n//     { pubkey: walletAddress, isSigner: false, isWritable: false },\n//     { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n//     {\n//       pubkey: anchor.web3.SystemProgram.programId,\n//       isSigner: false,\n//       isWritable: false,\n//     },\n//     { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n//     {\n//       pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n//       isSigner: false,\n//       isWritable: false,\n//     },\n//   ];\n//   return new anchor.web3.TransactionInstruction({\n//     keys,\n//     programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n//     data: Buffer.from([]),\n//   });\n// };\n// const sendTransaction = async (\n//   transaction: Transaction,\n//   signers: Keypair[],\n//   wallet: AnchorWallet\n// ) => {\n//   try {\n//     transaction.feePayer = wallet.publicKey;\n//     transaction.recentBlockhash = (\n//       await connection.getRecentBlockhash(\"max\")\n//     ).blockhash;\n//     await transaction.setSigners(\n//       wallet.publicKey,\n//       ...signers.map((s) => s.publicKey)\n//     );\n//     if (signers.length != 0) await transaction.partialSign(...signers);\n//     const signedTransaction = await wallet.signTransaction(transaction);\n//     let hash = await connection.sendRawTransaction(\n//       await signedTransaction.serialize()\n//     );\n//     await connection.confirmTransaction(hash);\n//     toast.success(\"Transaction succeed.\");\n//   } catch (err) {\n//     toast.error(\"Transaction failed. Please try again.\");\n//   }\n// };\n// const getTokenWallet = async (\n//   wallet: anchor.web3.PublicKey,\n//   mint: anchor.web3.PublicKey\n// ) => {\n//   return (\n//     await anchor.web3.PublicKey.findProgramAddress(\n//       [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n//       ASSOCIATED_TOKEN_PROGRAM_ID\n//     )\n//   )[0];\n// };\n// const getMetadata = async (\n//   mint: anchor.web3.PublicKey\n// ): Promise<anchor.web3.PublicKey> => {\n//   return (\n//     await anchor.web3.PublicKey.findProgramAddress(\n//       [\n//         Buffer.from(\"metadata\"),\n//         TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n//         mint.toBuffer(),\n//       ],\n//       TOKEN_METADATA_PROGRAM_ID\n//     )\n//   )[0];\n// };\n// const getStakedNftsForOwner = async (wallet: AnchorWallet) => {\n//   const provider = new anchor.Provider(\n//     connection,\n//     wallet,\n//     anchor.Provider.defaultOptions()\n//   );\n//   const program = new anchor.Program(idl, programId, provider);\n//   const allTokens: any = [];\n//   // let [globalAuthority] = await PublicKey.findProgramAddress(\n//   //     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\n//   //     program.programId\n//   // );\n//   let stakedNftList = await connection.getParsedProgramAccounts(programId);\n//   for (let nftAccount of stakedNftList) {\n//     try {\n//       let stakedNft = await program.account.userPoolData.fetch(\n//         nftAccount.pubkey\n//       );\n//       console.log(nftAccount);\n//       if (stakedNft.owner.toString() !== wallet.publicKey.toString()) {\n//         continue;\n//       }\n//       let mint = stakedNft.nftMint;\n//       let pda = await getMetadata(mint);\n//       let account = await getTokenWallet(wallet.publicKey, mint);\n//       const accountInfo: any = await connection.getParsedAccountInfo(pda);\n//       let metadata: any = new Metadata(\n//         wallet.publicKey.toString(),\n//         accountInfo.value\n//       );\n//       // if (metadata.data.data.symbol == COLLECTION_NAME) {\n//         const { data }: any = await axios.get(metadata.data.data.uri);\n//         const entireData = {\n//           ...data,\n//           id: Number(data.name.replace(/^\\D+/g, \"\").split(\" - \")[0]),\n//         };\n//         allTokens.push({\n//           account: account,\n//           poolKey: nftAccount.pubkey,\n//           address: mint,\n//           ...entireData,\n//         });\n//       // }\n//     } catch (err) {\n//       console.log(err);\n//     }\n//   }\n//   return allTokens;\n// };\n// const getStakedNftsForOwner1 = async (wallet: AnchorWallet) => {\n//   const provider = new anchor.Provider(\n//     connection,\n//     wallet,\n//     anchor.Provider.defaultOptions()\n//   );\n//   const program = new anchor.Program(idl, programId, provider);\n//   const allTokens: any = [];\n//   try {\n//     let resp = await connection.getProgramAccounts(programId, {\n//       dataSlice: {\n//         length: 0,\n//         offset: 0,\n//       },\n//       filters: [\n//         {\n//           dataSize: STAKE_DATA_SIZE,\n//         },\n//         {\n//           memcmp: {\n//             offset: 8,\n//             bytes: wallet.publicKey.toBase58(),\n//           },\n//         },\n//       ],\n//     });\n//     for (let nftAccount of resp) {\n//       let stakedNft = await program.account.userPool.fetch(nftAccount.pubkey);\n//       if (stakedNft.itemCount == 0) {\n//         continue;\n//       }\n//       for (let i = 0; i < stakedNft.itemCount; i++) {\n//         let mint = stakedNft.nftMintList[i];\n//         let pda = await getMetadata(mint);\n//         const accountInfo: any = await connection.getParsedAccountInfo(pda);\n//         let metadata: any = new Metadata(\n//           wallet.publicKey.toString(),\n//           accountInfo.value\n//         );\n//         const { data }: any = await axios.get(metadata.data.data.uri);\n//         const entireData = {\n//           ...data,\n//           id: Number(data.name.replace(/^\\D+/g, \"\").split(\" - \")[0]),\n//         };\n//         allTokens.push({\n//           poolKey: nftAccount.pubkey,\n//           address: mint,\n//           ...entireData,\n//         });\n//       }\n//     }\n//   } catch (e) {\n//     console.log(e);\n//   }\n//   return allTokens;\n// };\n// const getPoolInfo = async (wallet: AnchorWallet) => {\n//   const provider = new anchor.Provider(\n//     connection,\n//     wallet,\n//     anchor.Provider.defaultOptions()\n//   );\n//   const program = new anchor.Program(idl, programId, provider);\n//   let userPoolInfo = null;\n//   // for (let stakeAccount of resp) {\n//   let [userPool] = await PublicKey.findProgramAddress(\n//     [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\n//     program.programId\n//   );\n//   try {\n//     userPoolInfo = await program.account.userPool.fetch(userPool);\n//   } catch { }\n//   return userPoolInfo;\n// };\n// const getGlobalInfo = async (wallet: AnchorWallet) => {\n//   const provider = new anchor.Provider(\n//     connection,\n//     wallet,\n//     anchor.Provider.defaultOptions()\n//   );\n//   const program = new anchor.Program(idl, programId, provider);\n//   let globalInfo = null;\n//   // for (let stakeAccount of resp) {\n//   let [globalAuthority] = await PublicKey.findProgramAddress(\n//     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\n//     program.programId\n//   );\n//   try {\n//     globalInfo = await program.account.globalPool.fetch(globalAuthority); //\n//   } catch (err) {\n//     console.log(err);\n//   }\n//   return globalInfo;\n// };\n// const _stakeNftList = async (\n//   wallet: AnchorWallet,\n//   stakeMode: any,\n//   nftMintList: any\n// ) => {\n//   let provider = new anchor.Provider(\n//     connection,\n//     wallet,\n//     anchor.Provider.defaultOptions()\n//   );\n//   let program = new anchor.Program(idl, programId, provider);\n//   let [userPool] = await PublicKey.findProgramAddress(\n//     [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\n//     program.programId\n//   );\n//   // let transaction = new Transaction();\n//   // let signers: Keypair[] = [];\n//   try {\n//     const signersMatrix = [];\n//     const instructionsMatrix = [];\n//     let userPoolInfo = await getPoolInfo(wallet);\n//     let instructions: any[] = [];\n//     if (userPoolInfo == null) {\n//       instructions.push(\n//         await program.instruction.initUserPool({\n//           accounts: {\n//             owner: wallet.publicKey,\n//             userPool: userPool,\n//             systemProgram: anchor.web3.SystemProgram.programId,\n//           },\n//         })\n//       );\n//       let keypair = anchor.web3.Keypair.generate();\n//       let signers = [keypair];\n//       signersMatrix.push(signers);\n//       instructionsMatrix.push(instructions);\n//     }\n//     const [globalAuthority] = await PublicKey.findProgramAddress(\n//       [Buffer.from(GLOBAL_AUTHORITY_SEED)],\n//       program.programId\n//     );\n//     for (let i = 0; i < nftMintList.length; i++) {\n//       let instructions: any[] = [];\n//       let nftMint = nftMintList[i];\n//       const sourceNftAccount = nftMint.account;\n//       const destNftAccount = await getTokenWallet(\n//         globalAuthority,\n//         nftMint.address\n//       );\n//       console.log(\n//         \"mint-2\",\n//         nftMint.address.toString(),\n//         \"sourceNftAccount\",\n//         sourceNftAccount.toString(),\n//         \"destNftAccount\",\n//         destNftAccount.toString()\n//       );\n//       if ((await connection.getAccountInfo(destNftAccount)) == null) {\n//         // transaction.add(createAssociatedTokenAccountInstruction(destNftAccount, wallet.publicKey, globalAuthority, nftMint.address))\n//         instructions.push(\n//           createAssociatedTokenAccountInstruction(\n//             destNftAccount,\n//             wallet.publicKey,\n//             globalAuthority,\n//             nftMint.address\n//           )\n//         );\n//       }\n//       let [userPoolData] = await PublicKey.findProgramAddress(\n//         [\n//           Buffer.from(USER_POOL_DATA_SEED),\n//           wallet.publicKey.toBuffer(),\n//           nftMint.address.toBuffer(),\n//         ],\n//         program.programId\n//       );\n//       instructions.push(\n//         await program.instruction.stakeNft(1,{\n//           accounts: {\n//             owner: wallet.publicKey,\n//             userPool: userPool,\n//             userPoolData: userPoolData,\n//             globalAuthority: globalAuthority,\n//             nftMint: nftMint.address,\n//             sourceNftAccount: sourceNftAccount,\n//             destNftAccount: destNftAccount,\n//             tokenProgram: TOKEN_PROGRAM_ID,\n//             systemProgram: anchor.web3.SystemProgram.programId,\n//           },\n//         })\n//       );\n//       // transaction.add(\n//       //     await program.instruction.stakeNft({\n//       //         accounts: {\n//       //             owner: wallet.publicKey,\n//       //             userPool: userPool,\n//       //             userPoolData: userPoolData,\n//       //             globalAuthority: globalAuthority,\n//       //             nftMint: nftMint.address,\n//       //             sourceNftAccount: sourceNftAccount,\n//       //             destNftAccount: destNftAccount,\n//       //             tokenProgram: TOKEN_PROGRAM_ID,\n//       //             systemProgram: anchor.web3.SystemProgram.programId,\n//       //         }\n//       //     })\n//       // );\n//       let keypair = anchor.web3.Keypair.generate();\n//       let signers = [keypair];\n//       signersMatrix.push(signers);\n//       instructionsMatrix.push(instructions);\n//     }\n//     await sendTransactions(\n//       connection,\n//       wallet,\n//       instructionsMatrix,\n//       signersMatrix\n//     );\n//     // await delay(20000);\n//     toast.success(\"Transaction succeed.\");\n//     return 1;\n//   } catch (err) {\n//     toast.error(\"Transaction failed.\");\n//     console.log(err);\n//     return 0;\n//   }\n//   // await sendTransaction(transaction, signers, wallet);\n// };\n// function delay(ms: any) {\n//   return new Promise((resolve) => {\n//     setTimeout(resolve, ms);\n//   });\n// }\n// const stake = async (\n//   PoolKey: PublicKey,\n//   nftMint: PublicKey,\n//   wallet: AnchorWallet\n// ) => {\n//   let provider = new anchor.Provider(connection, wallet, confirmOption);\n//   let program = new anchor.Program(idl, programId, provider);\n//   const [globalAuthority, globalBump] = await PublicKey.findProgramAddress(\n//     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\n//     program.programId\n//   );\n//   const sourceNftAccount = await getTokenWallet(wallet.publicKey, nftMint);\n//   const destNftAccount = await getTokenWallet(globalAuthority, nftMint);\n//   let transaction = new Transaction();\n//   let signers: Keypair[] = [];\n//   let [userPoolData] = await PublicKey.findProgramAddress(\n//     [\n//       Buffer.from(USER_POOL_DATA_SEED),\n//       wallet.publicKey.toBuffer(),\n//       nftMint.toBuffer(),\n//     ],\n//     program.programId\n//   );\n//   if ((await connection.getAccountInfo(destNftAccount)) == null)\n//     transaction.add(\n//       createAssociatedTokenAccountInstruction(\n//         destNftAccount,\n//         wallet.publicKey,\n//         globalAuthority,\n//         nftMint\n//       )\n//     );\n//   transaction.add(\n//     await program.instruction.stakeNft(1,{\n//       accounts: {\n//         owner: wallet.publicKey,\n//         userPool: PoolKey,\n//         userPoolData: userPoolData,\n//         globalAuthority: globalAuthority,\n//         nftMint: nftMint,\n//         sourceNftAccount: sourceNftAccount,\n//         destNftAccount: destNftAccount,\n//         tokenProgram: TOKEN_PROGRAM_ID,\n//         systemProgram: anchor.web3.SystemProgram.programId,\n//       },\n//     })\n//   );\n//   await sendTransaction(transaction, signers, wallet);\n// };\n// const unStake = async (nfts: any[], wallet: AnchorWallet) => {\n//   let provider = new anchor.Provider(\n//     connection,\n//     wallet,\n//     anchor.Provider.defaultOptions()\n//   );\n//   let program = new anchor.Program(idl, programId, provider);\n//   const [globalAuthority, globalBump] = await PublicKey.findProgramAddress(\n//     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\n//     program.programId\n//   );\n//   let [userPool] = await PublicKey.findProgramAddress(\n//     [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\n//     program.programId\n//   );\n//   const signersMatrix = [];\n//   const instructionsMatrix = [];\n//   // let transaction = new Transaction();\n//   for (let i = 0; i < nfts.length; i++) {\n//     let instructions: any[] = [];\n//     let destAccount = await getTokenWallet(wallet.publicKey, nfts[i].address);\n//     let sourceAccount = await getTokenWallet(globalAuthority, nfts[i].address);\n//     console.log(\n//       \"mint-1\",\n//       nfts[i].address.toString(),\n//       \"sourceNftAccount\",\n//       sourceAccount.toString(),\n//       \"destNftAccount\",\n//       destAccount.toString()\n//     );\n//     if ((await connection.getAccountInfo(destAccount)) == null) {\n//       // transaction.add(createAssociatedTokenAccountInstruction(destAccount, wallet.publicKey, wallet.publicKey, nfts[i].address))\n//       instructions.push(\n//         createAssociatedTokenAccountInstruction(\n//           destAccount,\n//           wallet.publicKey,\n//           wallet.publicKey,\n//           nfts[i].address\n//         )\n//       );\n//     }\n//     let [userPoolData] = await PublicKey.findProgramAddress(\n//       [\n//         Buffer.from(USER_POOL_DATA_SEED),\n//         wallet.publicKey.toBuffer(),\n//         nfts[i].address.toBuffer(),\n//       ],\n//       program.programId\n//     );\n//     // transaction.add(\n//     //     await program.instruction.unstakeNft(globalBump, {\n//     //         accounts: {\n//     //             owner: wallet.publicKey,\n//     //             userPool: userPool,\n//     //             userPoolData: userPoolData,\n//     //             globalAuthority: globalAuthority,\n//     //             nftMint: nfts[i].address,\n//     //             sourceNftAccount: sourceAccount,\n//     //             destNftAccount: destAccount,\n//     //             tokenProgram: TOKEN_PROGRAM_ID,\n//     //         }\n//     //     })\n//     // );\n//     instructions.push(\n//       await program.instruction.unstakeNft(globalBump,1, {\n//         accounts: {\n//           owner: wallet.publicKey,\n//           userPool: userPool,\n//           userPoolData: userPoolData,\n//           globalAuthority: globalAuthority,\n//           nftMint: nfts[i].address,\n//           sourceNftAccount: sourceAccount,\n//           destNftAccount: destAccount,\n//           tokenProgram: TOKEN_PROGRAM_ID,\n//         },\n//       })\n//     );\n//     let keypair = anchor.web3.Keypair.generate();\n//     let signers = [keypair];\n//     signersMatrix.push(signers);\n//     instructionsMatrix.push(instructions);\n//   }\n//   // await sendTransaction(transaction, [], wallet);\n//   try {\n//     await sendTransactions(\n//       connection,\n//       wallet,\n//       instructionsMatrix,\n//       signersMatrix\n//     );\n//     // await delay(20000);\n//     toast.success(\"Transaction succeed.\");\n//     return 1;\n//   } catch (err) {\n//     toast.error(\"Transaction failed.\");\n//     console.log(err);\n//     return 0;\n//   }\n// };\n// async function claim(wallet: AnchorWallet) {\n//   let provider = new anchor.Provider(connection, wallet, confirmOption);\n//   let program = new anchor.Program(idl, programId, provider)\n//   const [globalAuthority, globalBump] = await PublicKey.findProgramAddress(\n//       [Buffer.from(GLOBAL_AUTHORITY_SEED)],\n//       program.programId\n//   );\n//   var myToken = new Token(\n//       connection,\n//       rewardMint,\n//       TOKEN_PROGRAM_ID,\n//       wallet as any\n//   );\n//   let sourceRewardAccount = await getTokenWallet(globalAuthority, rewardMint);\n//   let srcAccInfo = await myToken.getAccountInfo(sourceRewardAccount);\n//   if (!srcAccInfo) {\n//       return;\n//   }\n//   let transaction = new Transaction();\n//   let destRewardAccount = await withFindOrInitAssociatedTokenAccount(\n//       transaction,\n//       provider.connection,\n//       rewardMint,\n//       wallet.publicKey,\n//       wallet.publicKey,\n//       true\n//   );\n//   let [userPool, userBump] = await PublicKey.findProgramAddress(\n//       [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\n//       program.programId\n//   );\n//   transaction.add(\n//       await program.instruction.claimReward({\n//           accounts: {\n//               owner: wallet.publicKey,\n//               userPool: userPool,\n//               globalAuthority: globalAuthority,\n//               sourceAccount: sourceRewardAccount,\n//               destAccount: destRewardAccount,\n//               tokenProgram: TOKEN_PROGRAM_ID,\n//           }\n//       })\n//   )\n//   try {\n//       await sendTransaction(transaction, [], wallet);\n//   } catch (err: any) {\n//       printLog(err.reason || err.error?.message || err.message)\n//   }\n// }\n// const useNftStake = () => {\n//   const [balance, setBalance] = useWalletBalance();\n//   const anchorWallet = useAnchorWallet();\n//   const [isLoading, setIsLoading] = useState(false);\n//   const [stakedNfts, setStakedNfts] = useState<Array<any>>([]);\n//   // const [claimedAmount, setClaimedAmount] = useState(0);\n//   // const [dailyReward, setDailyReward] = useState(0);\n//   const [claimAmount, setClaimAmount] = useState(0);\n//   const [stakedCount, setStakedCount] = useState(0);\n//   const [totalStakedNFT, setTotalStakedNFT] = useState(0);\n//   const [rewardedTime, setRewardedTime] = useState(0);\n//   useEffect(() => {\n//     getStakedNfts();\n//   }, [anchorWallet, balance]);\n//   useEffect(() => {\n//     // const interval = setInterval(async () => {\n//     //   try {\n//     //     if (\n//     //       !anchorWallet ||\n//     //       !anchorWallet.publicKey ||\n//     //       !anchorWallet.signAllTransactions ||\n//     //       !anchorWallet.signTransaction\n//     //     ) {\n//     //       return;\n//     //     }\n//     //     let poolInfo = await getPoolInfo(anchorWallet);\n//     //     if (poolInfo != null) {\n//     //       // let days = 0;\n//     //       // if (Math.floor(Date.now() / 1000) > poolInfo.rewardTime.toNumber()) {\n//     //       //   days =\n//     //       //     (Math.floor(Date.now() / 1000) - poolInfo.rewardTime.toNumber()) /\n//     //       //     DAY_TIME;\n//     //       // }\n//     //       // let reward = poolInfo.claimable.toNumber() / LAMPORTS_PER_SOL + poolInfo.stakedCount * days;\n//     //       // setClaimAmount(Math.floor(reward * 100) / 100);\n//     //       setStakedCount(poolInfo.stakedCount);\n//     //     }\n//     //   } catch (err) {\n//     //     console.log(err);\n//     //   }\n//     // }, 10000);\n//     // return () => clearInterval(interval);\n//   }, [anchorWallet]);\n//   const getStakedNfts = async () => {\n//     try {\n//       if (\n//         !anchorWallet ||\n//         !anchorWallet.publicKey ||\n//         !anchorWallet.signAllTransactions ||\n//         !anchorWallet.signTransaction\n//       ) {\n//         return;\n//       }\n//       setIsLoading(true);\n//       const stakedNftsForOwner = await getStakedNftsForOwner(anchorWallet);\n//       console.log(\"loaded staked nfts\", stakedNftsForOwner);\n//       setStakedNfts(stakedNftsForOwner);\n//       let globalInfo = await getGlobalInfo(anchorWallet);\n//       console.log(\"globalInfo\", globalInfo);\n//       setTotalStakedNFT(globalInfo?.stakedCount);\n//       const poolInfo = await getPoolInfo(anchorWallet);\n//       console.log(\"poolInfo\", poolInfo);\n//       if (poolInfo != null) {\n//         // setClaimAmount(poolInfo.claimableReward.toNumber() / LAMPORTS_PER_SOL);\n//         // setDailyReward(get_daily_reward(poolInfo.stakedCount));\n//         console.log(\"claimableReward\", poolInfo.claimableReward.toNumber() / REWARD_TOKEN_DECIMALS);\n//         console.log(\"durationPoint\", poolInfo.durationPoint.toNumber());\n//         console.log(\"dailyReward\", poolInfo.dailyReward.toNumber());     \n//         console.log(\"stakedCount\", poolInfo.stakedCount);     \n//         console.log(\"gangCreatedTime\", poolInfo.gangCreatedTime.toNumber(), new Date(poolInfo.gangCreatedTime.toNumber()).toUTCString());     \n//         setClaimAmount(Math.floor(poolInfo.claimableReward.toNumber() / REWARD_TOKEN_DECIMALS * 100) / 100);\n//         setStakedCount(poolInfo.stakedCount);\n//         // console.log(\"poolinfo->totalrewards\", poolInfo?.totalReward.toNumber() / LAMPORTS_PER_SOL)\n//         setRewardedTime(poolInfo.rewardTime.toNumber());\n//       }\n//       setIsLoading(false);\n//     } catch (e){\n//       console.error(e)\n//       setIsLoading(false);\n//     }\n//   };\n//   const get_daily_reward_multiplier = (cnt: number) => {\n//     let res = 0.0;\n//     if (cnt == 1) {\n//       res = 1;\n//     } else if (cnt == 2) {\n//       res = 1.25;\n//     } else if (cnt == 4) {\n//       res = 1.5;\n//     } else if (cnt == 6) {\n//       res = 1.75;\n//     } else if (cnt == 8) {\n//       res = 2;\n//     }\n//     return res;\n//   };\n//   const get_daily_reward = (staked_count: number) => {\n//     let rest = staked_count % 8;\n//     let daily_reward = 0;\n//     if (rest % 2 == 0) {\n//       daily_reward =\n//         8.0 * 2.0 * 2.0 * Math.floor(staked_count / 8) +\n//         rest * 2.0 * get_daily_reward_multiplier(rest);\n//     } else {\n//       daily_reward =\n//         8.0 * 2.0 * 2.0 * Math.floor(staked_count / 8) +\n//         (rest - 1) * 2.0 * get_daily_reward_multiplier(rest - 1) +\n//         1.0 * 2.0 * 1.0;\n//     }\n//     // let days = (now - self.reward_time) / DAY_TIME;\n//     // self.total_reward = self.total_reward + daily_reward as u64 * days as u64 * DECIMAL;\n//     // self.reward_time = now;\n//     // Ok(self.total_reward)\n//     return daily_reward;\n//   };\n//   const updateBalance = async (wallet: AnchorWallet) => {\n//     const balance = await connection.getBalance(wallet.publicKey);\n//     setBalance(balance / LAMPORTS_PER_SOL);\n//   };\n//   const stakeNftList = async (stakeMode: any, nftMintList: any) => {\n//     if (!anchorWallet) {\n//       toast.error(\"Connect wallet first, please.\");\n//       return 0;\n//     }\n//     setIsLoading(true);\n//     try {\n//       const res = await _stakeNftList(anchorWallet, stakeMode, nftMintList);\n//       // await updateBalance(anchorWallet);\n//       // if (res == 1) {\n//       //   const poolInfo = await getPoolInfo(anchorWallet);\n//       //   console.log(\"poolInfo\", poolInfo);\n//       //   if (poolInfo != null) {\n//       //     // setClaimAmount(poolInfo.stakedCount);\n//       //     console.log(\n//       //       \"poolInfo->totalReward\",\n//       //       poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL\n//       //     );\n//       //     console.log(\"setClaimAmt3\", poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL)  \n//       //     setClaimAmount(Math.floor(poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL * 100) / 100);\n//       //     setRewardedTime(poolInfo.rewardTime.toNumber());\n//       //   }\n//       // }\n//       setIsLoading(false);\n//       return res;\n//     } catch (err) {\n//       setIsLoading(false);\n//       console.log(err);\n//       return 0;\n//     }\n//   };\n//   const stakeNft = async (PoolKey: PublicKey, nftMint: PublicKey) => {\n//     if (!anchorWallet) {\n//       toast.error(\"Connect wallet first, please.\");\n//       return;\n//     }\n//     setIsLoading(true);\n//     await stake(PoolKey, nftMint, anchorWallet);\n//     // await updateBalance(anchorWallet);\n//     setIsLoading(false);\n//   };\n//   const unStakeNft = async (nfts: any[]) => {\n//     if (!anchorWallet) {\n//       toast.error(\"Connect wallet first, please.\");\n//       return;\n//     }\n//     setIsLoading(true);\n//     const res = await unStake(nfts, anchorWallet);\n//     // if (res == 1) {\n//     //   const poolInfo = await getPoolInfo(anchorWallet);\n//     //   console.log(\"poolInfo\", poolInfo);\n//     //   if (poolInfo != null) {\n//     //     console.log(\n//     //       \"poolInfo->totalReward\",\n//     //       poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL\n//     //     );\n//     //     console.log(\"setClaimAmt4\", poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL)  \n//     //     setClaimAmount(Math.floor(poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL * 100) / 100);\n//     //     setRewardedTime(poolInfo.rewardTime.toNumber());\n//     //   }\n//     // }\n//     setIsLoading(false);\n//     return res;\n//   };\n//   const claimRewards = async () => {\n//     if (!anchorWallet) {\n//       toast.error(\"Connect wallet first, please.\");\n//       return;\n//     }\n//     setIsLoading(true);\n//     await claim(anchorWallet);\n//     setIsLoading(false);\n//   };\n//   return {\n//     isLoading,\n//     stakedNfts,\n//     stakedCount,\n//     claimAmount,\n//     totalStakedNFT,\n//     stakeNftList,\n//     stakeNft,\n//     unStakeNft,\n//     claimRewards,\n//     getStakedNfts,\n//     setStakedNfts,\n//   };\n// };\n// async function withFindOrInitAssociatedTokenAccount(\n//   transaction: Transaction,\n//   connection: Connection,\n//   mint: PublicKey,\n//   owner: PublicKey,\n//   payer: PublicKey,\n//   allowOwnerOffCurve: boolean\n// ) {\n//   const associatedAddress = await splToken.Token.getAssociatedTokenAddress(\n//     splToken.ASSOCIATED_TOKEN_PROGRAM_ID,\n//     splToken.TOKEN_PROGRAM_ID,\n//     mint,\n//     owner,\n//     allowOwnerOffCurve\n//   );\n//   const account = await connection.getAccountInfo(associatedAddress);\n//   if (!account) {\n//     transaction.add(\n//       splToken.Token.createAssociatedTokenAccountInstruction(\n//         splToken.ASSOCIATED_TOKEN_PROGRAM_ID,\n//         splToken.TOKEN_PROGRAM_ID,\n//         mint,\n//         associatedAddress,\n//         owner,\n//         payer\n//       )\n//     );\n//   }\n//   return associatedAddress;\n// }\n// export default useNftStake;","map":{"version":3,"names":[],"sources":["D:/software/o5o BNB/o5o-staking-frontend/src/hooks/use-nft-stake.ts"],"sourcesContent":["// /* eslint-disable react-hooks/exhaustive-deps */\r\n// /* eslint-disable eqeqeq */\r\n// /* eslint-disable @typescript-eslint/no-unused-vars */\r\n// import { AnchorWallet, useAnchorWallet } from \"@solana/wallet-adapter-react\";\r\n// import { useEffect, useState } from \"react\";\r\n// import * as anchor from \"@project-serum/anchor\";\r\n// import useWalletBalance from \"./use-wallet-balance\";\r\n// import {\r\n//   TOKEN_PROGRAM_ID,\r\n//   ASSOCIATED_TOKEN_PROGRAM_ID,\r\n//   Token,\r\n// } from \"@solana/spl-token\";\r\n// import { programs } from \"@metaplex/js\";\r\n// import toast from \"react-hot-toast\";\r\n// import {\r\n//   Keypair,\r\n//   PublicKey,\r\n//   Transaction,\r\n//   ConfirmOptions,\r\n//   LAMPORTS_PER_SOL,\r\n//   Connection,\r\n// } from \"@solana/web3.js\";\r\n// import * as splToken from \"@solana/spl-token\";\r\n// import axios from \"axios\";\r\n// import {\r\n//   STAKE_DATA_SIZE,\r\n//   STAKE_CONTRACT_IDL,\r\n//   COLLECTION_NAME,\r\n// } from \"../constant/contract\";\r\n// import {\r\n//   GLOBAL_AUTHORITY_SEED,\r\n//   NEXT_PUBLIC_SOLANA_NETWORK,\r\n//   NEXT_PUBLIC_STAKE_CONTRACT_ID,\r\n//   REWARD_TOKEN,\r\n//   REWARD_TOKEN_DECIMALS,\r\n//   USER_POOL_DATA_SEED,\r\n//   USER_POOL_SEED,\r\n// } from \"../constant/env\";\r\n// import { printLog } from \"../utils/utility\";\r\n// import { sendTransactions } from \"../helpers/sol/connection\";\r\n\r\n// const {\r\n//   metadata: { Metadata },\r\n// } = programs;\r\n// const TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\r\n//   \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\r\n// );\r\n// // const connection = new anchor.web3.Connection(\r\n// //   NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\"\r\n// //     ? \"https://metaplex.devnet.rpcpool.com\"\r\n// //     : \"https://metaplex.mainnet.rpcpool.com\"\r\n// // );\r\n\r\n// const connection = new anchor.web3.Connection(\r\n//   NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\"\r\n//     ? \"https://api.devnet.solana.com\"\r\n//     : \"https://metaplex.mainnet.rpcpool.com\"\r\n// );\r\n\r\n\r\n// const programId = new PublicKey(NEXT_PUBLIC_STAKE_CONTRACT_ID!);\r\n// const idl = STAKE_CONTRACT_IDL as anchor.Idl;\r\n// const confirmOption: ConfirmOptions = {\r\n//   commitment: \"finalized\",\r\n//   preflightCommitment: \"finalized\",\r\n//   skipPreflight: false,\r\n// };\r\n\r\n// const rewardMint = new PublicKey(REWARD_TOKEN);\r\n\r\n// const createAssociatedTokenAccountInstruction = (\r\n//   associatedTokenAddress: anchor.web3.PublicKey,\r\n//   payer: anchor.web3.PublicKey,\r\n//   walletAddress: anchor.web3.PublicKey,\r\n//   splTokenMintAddress: anchor.web3.PublicKey\r\n// ) => {\r\n//   const keys = [\r\n//     { pubkey: payer, isSigner: true, isWritable: true },\r\n//     { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\r\n//     { pubkey: walletAddress, isSigner: false, isWritable: false },\r\n//     { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\r\n//     {\r\n//       pubkey: anchor.web3.SystemProgram.programId,\r\n//       isSigner: false,\r\n//       isWritable: false,\r\n//     },\r\n//     { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\r\n//     {\r\n//       pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n//       isSigner: false,\r\n//       isWritable: false,\r\n//     },\r\n//   ];\r\n//   return new anchor.web3.TransactionInstruction({\r\n//     keys,\r\n//     programId: ASSOCIATED_TOKEN_PROGRAM_ID,\r\n//     data: Buffer.from([]),\r\n//   });\r\n// };\r\n\r\n// const sendTransaction = async (\r\n//   transaction: Transaction,\r\n//   signers: Keypair[],\r\n//   wallet: AnchorWallet\r\n// ) => {\r\n//   try {\r\n//     transaction.feePayer = wallet.publicKey;\r\n//     transaction.recentBlockhash = (\r\n//       await connection.getRecentBlockhash(\"max\")\r\n//     ).blockhash;\r\n//     await transaction.setSigners(\r\n//       wallet.publicKey,\r\n//       ...signers.map((s) => s.publicKey)\r\n//     );\r\n//     if (signers.length != 0) await transaction.partialSign(...signers);\r\n//     const signedTransaction = await wallet.signTransaction(transaction);\r\n//     let hash = await connection.sendRawTransaction(\r\n//       await signedTransaction.serialize()\r\n//     );\r\n//     await connection.confirmTransaction(hash);\r\n//     toast.success(\"Transaction succeed.\");\r\n//   } catch (err) {\r\n//     toast.error(\"Transaction failed. Please try again.\");\r\n//   }\r\n// };\r\n\r\n// const getTokenWallet = async (\r\n//   wallet: anchor.web3.PublicKey,\r\n//   mint: anchor.web3.PublicKey\r\n// ) => {\r\n//   return (\r\n//     await anchor.web3.PublicKey.findProgramAddress(\r\n//       [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\r\n//       ASSOCIATED_TOKEN_PROGRAM_ID\r\n//     )\r\n//   )[0];\r\n// };\r\n\r\n// const getMetadata = async (\r\n//   mint: anchor.web3.PublicKey\r\n// ): Promise<anchor.web3.PublicKey> => {\r\n//   return (\r\n//     await anchor.web3.PublicKey.findProgramAddress(\r\n//       [\r\n//         Buffer.from(\"metadata\"),\r\n//         TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n//         mint.toBuffer(),\r\n//       ],\r\n//       TOKEN_METADATA_PROGRAM_ID\r\n//     )\r\n//   )[0];\r\n// };\r\n\r\n// const getStakedNftsForOwner = async (wallet: AnchorWallet) => {\r\n//   const provider = new anchor.Provider(\r\n//     connection,\r\n//     wallet,\r\n//     anchor.Provider.defaultOptions()\r\n//   );\r\n//   const program = new anchor.Program(idl, programId, provider);\r\n//   const allTokens: any = [];\r\n\r\n//   // let [globalAuthority] = await PublicKey.findProgramAddress(\r\n//   //     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n//   //     program.programId\r\n//   // );\r\n\r\n//   let stakedNftList = await connection.getParsedProgramAccounts(programId);\r\n//   for (let nftAccount of stakedNftList) {\r\n//     try {\r\n//       let stakedNft = await program.account.userPoolData.fetch(\r\n//         nftAccount.pubkey\r\n//       );\r\n//       console.log(nftAccount);\r\n\r\n//       if (stakedNft.owner.toString() !== wallet.publicKey.toString()) {\r\n//         continue;\r\n//       }\r\n\r\n//       let mint = stakedNft.nftMint;\r\n//       let pda = await getMetadata(mint);\r\n//       let account = await getTokenWallet(wallet.publicKey, mint);\r\n//       const accountInfo: any = await connection.getParsedAccountInfo(pda);\r\n//       let metadata: any = new Metadata(\r\n//         wallet.publicKey.toString(),\r\n//         accountInfo.value\r\n//       );\r\n//       // if (metadata.data.data.symbol == COLLECTION_NAME) {\r\n//         const { data }: any = await axios.get(metadata.data.data.uri);\r\n//         const entireData = {\r\n//           ...data,\r\n//           id: Number(data.name.replace(/^\\D+/g, \"\").split(\" - \")[0]),\r\n//         };\r\n//         allTokens.push({\r\n//           account: account,\r\n//           poolKey: nftAccount.pubkey,\r\n//           address: mint,\r\n//           ...entireData,\r\n//         });\r\n//       // }\r\n//     } catch (err) {\r\n//       console.log(err);\r\n//     }\r\n//   }\r\n//   return allTokens;\r\n// };\r\n\r\n// const getStakedNftsForOwner1 = async (wallet: AnchorWallet) => {\r\n//   const provider = new anchor.Provider(\r\n//     connection,\r\n//     wallet,\r\n//     anchor.Provider.defaultOptions()\r\n//   );\r\n//   const program = new anchor.Program(idl, programId, provider);\r\n\r\n//   const allTokens: any = [];\r\n//   try {\r\n//     let resp = await connection.getProgramAccounts(programId, {\r\n//       dataSlice: {\r\n//         length: 0,\r\n//         offset: 0,\r\n//       },\r\n//       filters: [\r\n//         {\r\n//           dataSize: STAKE_DATA_SIZE,\r\n//         },\r\n//         {\r\n//           memcmp: {\r\n//             offset: 8,\r\n//             bytes: wallet.publicKey.toBase58(),\r\n//           },\r\n//         },\r\n//       ],\r\n//     });\r\n\r\n//     for (let nftAccount of resp) {\r\n//       let stakedNft = await program.account.userPool.fetch(nftAccount.pubkey);\r\n//       if (stakedNft.itemCount == 0) {\r\n//         continue;\r\n//       }\r\n\r\n//       for (let i = 0; i < stakedNft.itemCount; i++) {\r\n//         let mint = stakedNft.nftMintList[i];\r\n//         let pda = await getMetadata(mint);\r\n//         const accountInfo: any = await connection.getParsedAccountInfo(pda);\r\n//         let metadata: any = new Metadata(\r\n//           wallet.publicKey.toString(),\r\n//           accountInfo.value\r\n//         );\r\n//         const { data }: any = await axios.get(metadata.data.data.uri);\r\n//         const entireData = {\r\n//           ...data,\r\n//           id: Number(data.name.replace(/^\\D+/g, \"\").split(\" - \")[0]),\r\n//         };\r\n//         allTokens.push({\r\n//           poolKey: nftAccount.pubkey,\r\n//           address: mint,\r\n//           ...entireData,\r\n//         });\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     console.log(e);\r\n//   }\r\n//   return allTokens;\r\n// };\r\n\r\n// const getPoolInfo = async (wallet: AnchorWallet) => {\r\n//   const provider = new anchor.Provider(\r\n//     connection,\r\n//     wallet,\r\n//     anchor.Provider.defaultOptions()\r\n//   );\r\n//   const program = new anchor.Program(idl, programId, provider);\r\n//   let userPoolInfo = null;\r\n//   // for (let stakeAccount of resp) {\r\n//   let [userPool] = await PublicKey.findProgramAddress(\r\n//     [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\r\n//     program.programId\r\n//   );\r\n//   try {\r\n//     userPoolInfo = await program.account.userPool.fetch(userPool);\r\n//   } catch { }\r\n//   return userPoolInfo;\r\n// };\r\n\r\n// const getGlobalInfo = async (wallet: AnchorWallet) => {\r\n//   const provider = new anchor.Provider(\r\n//     connection,\r\n//     wallet,\r\n//     anchor.Provider.defaultOptions()\r\n//   );\r\n//   const program = new anchor.Program(idl, programId, provider);\r\n//   let globalInfo = null;\r\n//   // for (let stakeAccount of resp) {\r\n//   let [globalAuthority] = await PublicKey.findProgramAddress(\r\n//     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n//     program.programId\r\n//   );\r\n\r\n//   try {\r\n//     globalInfo = await program.account.globalPool.fetch(globalAuthority); //\r\n//   } catch (err) {\r\n//     console.log(err);\r\n//   }\r\n//   return globalInfo;\r\n// };\r\n\r\n// const _stakeNftList = async (\r\n//   wallet: AnchorWallet,\r\n//   stakeMode: any,\r\n//   nftMintList: any\r\n// ) => {\r\n//   let provider = new anchor.Provider(\r\n//     connection,\r\n//     wallet,\r\n//     anchor.Provider.defaultOptions()\r\n//   );\r\n//   let program = new anchor.Program(idl, programId, provider);\r\n//   let [userPool] = await PublicKey.findProgramAddress(\r\n//     [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\r\n//     program.programId\r\n//   );\r\n//   // let transaction = new Transaction();\r\n//   // let signers: Keypair[] = [];\r\n\r\n//   try {\r\n//     const signersMatrix = [];\r\n//     const instructionsMatrix = [];\r\n\r\n//     let userPoolInfo = await getPoolInfo(wallet);\r\n//     let instructions: any[] = [];\r\n//     if (userPoolInfo == null) {\r\n//       instructions.push(\r\n//         await program.instruction.initUserPool({\r\n//           accounts: {\r\n//             owner: wallet.publicKey,\r\n//             userPool: userPool,\r\n//             systemProgram: anchor.web3.SystemProgram.programId,\r\n//           },\r\n//         })\r\n//       );\r\n//       let keypair = anchor.web3.Keypair.generate();\r\n//       let signers = [keypair];\r\n\r\n//       signersMatrix.push(signers);\r\n//       instructionsMatrix.push(instructions);\r\n//     }\r\n\r\n//     const [globalAuthority] = await PublicKey.findProgramAddress(\r\n//       [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n//       program.programId\r\n//     );\r\n\r\n//     for (let i = 0; i < nftMintList.length; i++) {\r\n//       let instructions: any[] = [];\r\n//       let nftMint = nftMintList[i];\r\n\r\n//       const sourceNftAccount = nftMint.account;\r\n//       const destNftAccount = await getTokenWallet(\r\n//         globalAuthority,\r\n//         nftMint.address\r\n//       );\r\n//       console.log(\r\n//         \"mint-2\",\r\n//         nftMint.address.toString(),\r\n//         \"sourceNftAccount\",\r\n//         sourceNftAccount.toString(),\r\n//         \"destNftAccount\",\r\n//         destNftAccount.toString()\r\n//       );\r\n\r\n//       if ((await connection.getAccountInfo(destNftAccount)) == null) {\r\n//         // transaction.add(createAssociatedTokenAccountInstruction(destNftAccount, wallet.publicKey, globalAuthority, nftMint.address))\r\n//         instructions.push(\r\n//           createAssociatedTokenAccountInstruction(\r\n//             destNftAccount,\r\n//             wallet.publicKey,\r\n//             globalAuthority,\r\n//             nftMint.address\r\n//           )\r\n//         );\r\n//       }\r\n\r\n//       let [userPoolData] = await PublicKey.findProgramAddress(\r\n//         [\r\n//           Buffer.from(USER_POOL_DATA_SEED),\r\n//           wallet.publicKey.toBuffer(),\r\n//           nftMint.address.toBuffer(),\r\n//         ],\r\n//         program.programId\r\n//       );\r\n\r\n//       instructions.push(\r\n//         await program.instruction.stakeNft(1,{\r\n//           accounts: {\r\n//             owner: wallet.publicKey,\r\n//             userPool: userPool,\r\n//             userPoolData: userPoolData,\r\n//             globalAuthority: globalAuthority,\r\n//             nftMint: nftMint.address,\r\n//             sourceNftAccount: sourceNftAccount,\r\n//             destNftAccount: destNftAccount,\r\n//             tokenProgram: TOKEN_PROGRAM_ID,\r\n//             systemProgram: anchor.web3.SystemProgram.programId,\r\n//           },\r\n//         })\r\n//       );\r\n\r\n//       // transaction.add(\r\n//       //     await program.instruction.stakeNft({\r\n//       //         accounts: {\r\n//       //             owner: wallet.publicKey,\r\n//       //             userPool: userPool,\r\n//       //             userPoolData: userPoolData,\r\n//       //             globalAuthority: globalAuthority,\r\n//       //             nftMint: nftMint.address,\r\n//       //             sourceNftAccount: sourceNftAccount,\r\n//       //             destNftAccount: destNftAccount,\r\n//       //             tokenProgram: TOKEN_PROGRAM_ID,\r\n//       //             systemProgram: anchor.web3.SystemProgram.programId,\r\n//       //         }\r\n//       //     })\r\n//       // );\r\n\r\n//       let keypair = anchor.web3.Keypair.generate();\r\n//       let signers = [keypair];\r\n\r\n//       signersMatrix.push(signers);\r\n//       instructionsMatrix.push(instructions);\r\n//     }\r\n\r\n//     await sendTransactions(\r\n//       connection,\r\n//       wallet,\r\n//       instructionsMatrix,\r\n//       signersMatrix\r\n//     );\r\n//     // await delay(20000);\r\n\r\n//     toast.success(\"Transaction succeed.\");\r\n//     return 1;\r\n//   } catch (err) {\r\n//     toast.error(\"Transaction failed.\");\r\n//     console.log(err);\r\n//     return 0;\r\n//   }\r\n//   // await sendTransaction(transaction, signers, wallet);\r\n// };\r\n\r\n// function delay(ms: any) {\r\n//   return new Promise((resolve) => {\r\n//     setTimeout(resolve, ms);\r\n//   });\r\n// }\r\n\r\n// const stake = async (\r\n//   PoolKey: PublicKey,\r\n//   nftMint: PublicKey,\r\n//   wallet: AnchorWallet\r\n// ) => {\r\n//   let provider = new anchor.Provider(connection, wallet, confirmOption);\r\n//   let program = new anchor.Program(idl, programId, provider);\r\n\r\n//   const [globalAuthority, globalBump] = await PublicKey.findProgramAddress(\r\n//     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n//     program.programId\r\n//   );\r\n\r\n//   const sourceNftAccount = await getTokenWallet(wallet.publicKey, nftMint);\r\n//   const destNftAccount = await getTokenWallet(globalAuthority, nftMint);\r\n//   let transaction = new Transaction();\r\n//   let signers: Keypair[] = [];\r\n//   let [userPoolData] = await PublicKey.findProgramAddress(\r\n//     [\r\n//       Buffer.from(USER_POOL_DATA_SEED),\r\n//       wallet.publicKey.toBuffer(),\r\n//       nftMint.toBuffer(),\r\n//     ],\r\n//     program.programId\r\n//   );\r\n\r\n//   if ((await connection.getAccountInfo(destNftAccount)) == null)\r\n//     transaction.add(\r\n//       createAssociatedTokenAccountInstruction(\r\n//         destNftAccount,\r\n//         wallet.publicKey,\r\n//         globalAuthority,\r\n//         nftMint\r\n//       )\r\n//     );\r\n//   transaction.add(\r\n//     await program.instruction.stakeNft(1,{\r\n//       accounts: {\r\n//         owner: wallet.publicKey,\r\n//         userPool: PoolKey,\r\n//         userPoolData: userPoolData,\r\n//         globalAuthority: globalAuthority,\r\n//         nftMint: nftMint,\r\n//         sourceNftAccount: sourceNftAccount,\r\n//         destNftAccount: destNftAccount,\r\n//         tokenProgram: TOKEN_PROGRAM_ID,\r\n//         systemProgram: anchor.web3.SystemProgram.programId,\r\n//       },\r\n//     })\r\n//   );\r\n//   await sendTransaction(transaction, signers, wallet);\r\n// };\r\n\r\n// const unStake = async (nfts: any[], wallet: AnchorWallet) => {\r\n//   let provider = new anchor.Provider(\r\n//     connection,\r\n//     wallet,\r\n//     anchor.Provider.defaultOptions()\r\n//   );\r\n//   let program = new anchor.Program(idl, programId, provider);\r\n\r\n//   const [globalAuthority, globalBump] = await PublicKey.findProgramAddress(\r\n//     [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n//     program.programId\r\n//   );\r\n\r\n//   let [userPool] = await PublicKey.findProgramAddress(\r\n//     [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\r\n//     program.programId\r\n//   );\r\n\r\n//   const signersMatrix = [];\r\n//   const instructionsMatrix = [];\r\n\r\n//   // let transaction = new Transaction();\r\n//   for (let i = 0; i < nfts.length; i++) {\r\n//     let instructions: any[] = [];\r\n//     let destAccount = await getTokenWallet(wallet.publicKey, nfts[i].address);\r\n//     let sourceAccount = await getTokenWallet(globalAuthority, nfts[i].address);\r\n\r\n//     console.log(\r\n//       \"mint-1\",\r\n//       nfts[i].address.toString(),\r\n//       \"sourceNftAccount\",\r\n//       sourceAccount.toString(),\r\n//       \"destNftAccount\",\r\n//       destAccount.toString()\r\n//     );\r\n\r\n//     if ((await connection.getAccountInfo(destAccount)) == null) {\r\n//       // transaction.add(createAssociatedTokenAccountInstruction(destAccount, wallet.publicKey, wallet.publicKey, nfts[i].address))\r\n//       instructions.push(\r\n//         createAssociatedTokenAccountInstruction(\r\n//           destAccount,\r\n//           wallet.publicKey,\r\n//           wallet.publicKey,\r\n//           nfts[i].address\r\n//         )\r\n//       );\r\n//     }\r\n\r\n//     let [userPoolData] = await PublicKey.findProgramAddress(\r\n//       [\r\n//         Buffer.from(USER_POOL_DATA_SEED),\r\n//         wallet.publicKey.toBuffer(),\r\n//         nfts[i].address.toBuffer(),\r\n//       ],\r\n//       program.programId\r\n//     );\r\n\r\n//     // transaction.add(\r\n//     //     await program.instruction.unstakeNft(globalBump, {\r\n//     //         accounts: {\r\n//     //             owner: wallet.publicKey,\r\n//     //             userPool: userPool,\r\n//     //             userPoolData: userPoolData,\r\n//     //             globalAuthority: globalAuthority,\r\n//     //             nftMint: nfts[i].address,\r\n//     //             sourceNftAccount: sourceAccount,\r\n//     //             destNftAccount: destAccount,\r\n//     //             tokenProgram: TOKEN_PROGRAM_ID,\r\n//     //         }\r\n//     //     })\r\n//     // );\r\n\r\n//     instructions.push(\r\n//       await program.instruction.unstakeNft(globalBump,1, {\r\n//         accounts: {\r\n//           owner: wallet.publicKey,\r\n//           userPool: userPool,\r\n//           userPoolData: userPoolData,\r\n//           globalAuthority: globalAuthority,\r\n//           nftMint: nfts[i].address,\r\n//           sourceNftAccount: sourceAccount,\r\n//           destNftAccount: destAccount,\r\n//           tokenProgram: TOKEN_PROGRAM_ID,\r\n//         },\r\n//       })\r\n//     );\r\n//     let keypair = anchor.web3.Keypair.generate();\r\n//     let signers = [keypair];\r\n\r\n//     signersMatrix.push(signers);\r\n//     instructionsMatrix.push(instructions);\r\n//   }\r\n\r\n//   // await sendTransaction(transaction, [], wallet);\r\n//   try {\r\n//     await sendTransactions(\r\n//       connection,\r\n//       wallet,\r\n//       instructionsMatrix,\r\n//       signersMatrix\r\n//     );\r\n//     // await delay(20000);\r\n//     toast.success(\"Transaction succeed.\");\r\n//     return 1;\r\n//   } catch (err) {\r\n//     toast.error(\"Transaction failed.\");\r\n//     console.log(err);\r\n//     return 0;\r\n//   }\r\n// };\r\n\r\n// async function claim(wallet: AnchorWallet) {\r\n\r\n//   let provider = new anchor.Provider(connection, wallet, confirmOption);\r\n//   let program = new anchor.Program(idl, programId, provider)\r\n\r\n//   const [globalAuthority, globalBump] = await PublicKey.findProgramAddress(\r\n//       [Buffer.from(GLOBAL_AUTHORITY_SEED)],\r\n//       program.programId\r\n//   );\r\n\r\n//   var myToken = new Token(\r\n//       connection,\r\n//       rewardMint,\r\n//       TOKEN_PROGRAM_ID,\r\n//       wallet as any\r\n//   );\r\n//   let sourceRewardAccount = await getTokenWallet(globalAuthority, rewardMint);\r\n//   let srcAccInfo = await myToken.getAccountInfo(sourceRewardAccount);\r\n//   if (!srcAccInfo) {\r\n//       return;\r\n//   }\r\n\r\n//   let transaction = new Transaction();\r\n\r\n//   let destRewardAccount = await withFindOrInitAssociatedTokenAccount(\r\n//       transaction,\r\n//       provider.connection,\r\n//       rewardMint,\r\n//       wallet.publicKey,\r\n//       wallet.publicKey,\r\n//       true\r\n//   );\r\n\r\n//   let [userPool, userBump] = await PublicKey.findProgramAddress(\r\n//       [Buffer.from(USER_POOL_SEED), wallet.publicKey.toBuffer()],\r\n//       program.programId\r\n//   );\r\n\r\n//   transaction.add(\r\n//       await program.instruction.claimReward({\r\n//           accounts: {\r\n//               owner: wallet.publicKey,\r\n//               userPool: userPool,\r\n//               globalAuthority: globalAuthority,\r\n//               sourceAccount: sourceRewardAccount,\r\n//               destAccount: destRewardAccount,\r\n//               tokenProgram: TOKEN_PROGRAM_ID,\r\n//           }\r\n//       })\r\n//   )\r\n//   try {\r\n//       await sendTransaction(transaction, [], wallet);\r\n//   } catch (err: any) {\r\n//       printLog(err.reason || err.error?.message || err.message)\r\n//   }\r\n// }\r\n\r\n// const useNftStake = () => {\r\n//   const [balance, setBalance] = useWalletBalance();\r\n//   const anchorWallet = useAnchorWallet();\r\n//   const [isLoading, setIsLoading] = useState(false);\r\n//   const [stakedNfts, setStakedNfts] = useState<Array<any>>([]);\r\n//   // const [claimedAmount, setClaimedAmount] = useState(0);\r\n//   // const [dailyReward, setDailyReward] = useState(0);\r\n//   const [claimAmount, setClaimAmount] = useState(0);\r\n//   const [stakedCount, setStakedCount] = useState(0);\r\n//   const [totalStakedNFT, setTotalStakedNFT] = useState(0);\r\n//   const [rewardedTime, setRewardedTime] = useState(0);\r\n\r\n//   useEffect(() => {\r\n//     getStakedNfts();\r\n//   }, [anchorWallet, balance]);\r\n\r\n//   useEffect(() => {\r\n//     // const interval = setInterval(async () => {\r\n//     //   try {\r\n//     //     if (\r\n//     //       !anchorWallet ||\r\n//     //       !anchorWallet.publicKey ||\r\n//     //       !anchorWallet.signAllTransactions ||\r\n//     //       !anchorWallet.signTransaction\r\n//     //     ) {\r\n//     //       return;\r\n//     //     }\r\n//     //     let poolInfo = await getPoolInfo(anchorWallet);\r\n//     //     if (poolInfo != null) {\r\n//     //       // let days = 0;\r\n//     //       // if (Math.floor(Date.now() / 1000) > poolInfo.rewardTime.toNumber()) {\r\n//     //       //   days =\r\n//     //       //     (Math.floor(Date.now() / 1000) - poolInfo.rewardTime.toNumber()) /\r\n//     //       //     DAY_TIME;\r\n//     //       // }\r\n//     //       // let reward = poolInfo.claimable.toNumber() / LAMPORTS_PER_SOL + poolInfo.stakedCount * days;\r\n//     //       // setClaimAmount(Math.floor(reward * 100) / 100);\r\n//     //       setStakedCount(poolInfo.stakedCount);\r\n//     //     }\r\n//     //   } catch (err) {\r\n//     //     console.log(err);\r\n//     //   }\r\n//     // }, 10000);\r\n//     // return () => clearInterval(interval);\r\n//   }, [anchorWallet]);\r\n\r\n//   const getStakedNfts = async () => {\r\n//     try {\r\n//       if (\r\n//         !anchorWallet ||\r\n//         !anchorWallet.publicKey ||\r\n//         !anchorWallet.signAllTransactions ||\r\n//         !anchorWallet.signTransaction\r\n//       ) {\r\n//         return;\r\n//       }\r\n\r\n//       setIsLoading(true);\r\n//       const stakedNftsForOwner = await getStakedNftsForOwner(anchorWallet);\r\n//       console.log(\"loaded staked nfts\", stakedNftsForOwner);\r\n//       setStakedNfts(stakedNftsForOwner);\r\n//       let globalInfo = await getGlobalInfo(anchorWallet);\r\n//       console.log(\"globalInfo\", globalInfo);\r\n//       setTotalStakedNFT(globalInfo?.stakedCount);\r\n//       const poolInfo = await getPoolInfo(anchorWallet);\r\n//       console.log(\"poolInfo\", poolInfo);\r\n//       if (poolInfo != null) {\r\n//         // setClaimAmount(poolInfo.claimableReward.toNumber() / LAMPORTS_PER_SOL);\r\n//         // setDailyReward(get_daily_reward(poolInfo.stakedCount));\r\n//         console.log(\"claimableReward\", poolInfo.claimableReward.toNumber() / REWARD_TOKEN_DECIMALS);\r\n//         console.log(\"durationPoint\", poolInfo.durationPoint.toNumber());\r\n//         console.log(\"dailyReward\", poolInfo.dailyReward.toNumber());     \r\n//         console.log(\"stakedCount\", poolInfo.stakedCount);     \r\n//         console.log(\"gangCreatedTime\", poolInfo.gangCreatedTime.toNumber(), new Date(poolInfo.gangCreatedTime.toNumber()).toUTCString());     \r\n//         setClaimAmount(Math.floor(poolInfo.claimableReward.toNumber() / REWARD_TOKEN_DECIMALS * 100) / 100);\r\n//         setStakedCount(poolInfo.stakedCount);\r\n//         // console.log(\"poolinfo->totalrewards\", poolInfo?.totalReward.toNumber() / LAMPORTS_PER_SOL)\r\n//         setRewardedTime(poolInfo.rewardTime.toNumber());\r\n//       }\r\n//       setIsLoading(false);\r\n//     } catch (e){\r\n//       console.error(e)\r\n//       setIsLoading(false);\r\n//     }\r\n//   };\r\n\r\n//   const get_daily_reward_multiplier = (cnt: number) => {\r\n//     let res = 0.0;\r\n//     if (cnt == 1) {\r\n//       res = 1;\r\n//     } else if (cnt == 2) {\r\n//       res = 1.25;\r\n//     } else if (cnt == 4) {\r\n//       res = 1.5;\r\n//     } else if (cnt == 6) {\r\n//       res = 1.75;\r\n//     } else if (cnt == 8) {\r\n//       res = 2;\r\n//     }\r\n//     return res;\r\n//   };\r\n\r\n//   const get_daily_reward = (staked_count: number) => {\r\n//     let rest = staked_count % 8;\r\n//     let daily_reward = 0;\r\n//     if (rest % 2 == 0) {\r\n//       daily_reward =\r\n//         8.0 * 2.0 * 2.0 * Math.floor(staked_count / 8) +\r\n//         rest * 2.0 * get_daily_reward_multiplier(rest);\r\n//     } else {\r\n//       daily_reward =\r\n//         8.0 * 2.0 * 2.0 * Math.floor(staked_count / 8) +\r\n//         (rest - 1) * 2.0 * get_daily_reward_multiplier(rest - 1) +\r\n//         1.0 * 2.0 * 1.0;\r\n//     }\r\n//     // let days = (now - self.reward_time) / DAY_TIME;\r\n//     // self.total_reward = self.total_reward + daily_reward as u64 * days as u64 * DECIMAL;\r\n//     // self.reward_time = now;\r\n//     // Ok(self.total_reward)\r\n//     return daily_reward;\r\n//   };\r\n\r\n//   const updateBalance = async (wallet: AnchorWallet) => {\r\n//     const balance = await connection.getBalance(wallet.publicKey);\r\n//     setBalance(balance / LAMPORTS_PER_SOL);\r\n//   };\r\n\r\n//   const stakeNftList = async (stakeMode: any, nftMintList: any) => {\r\n//     if (!anchorWallet) {\r\n//       toast.error(\"Connect wallet first, please.\");\r\n//       return 0;\r\n//     }\r\n//     setIsLoading(true);\r\n//     try {\r\n//       const res = await _stakeNftList(anchorWallet, stakeMode, nftMintList);\r\n//       // await updateBalance(anchorWallet);\r\n//       // if (res == 1) {\r\n//       //   const poolInfo = await getPoolInfo(anchorWallet);\r\n//       //   console.log(\"poolInfo\", poolInfo);\r\n//       //   if (poolInfo != null) {\r\n//       //     // setClaimAmount(poolInfo.stakedCount);\r\n//       //     console.log(\r\n//       //       \"poolInfo->totalReward\",\r\n//       //       poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL\r\n//       //     );\r\n//       //     console.log(\"setClaimAmt3\", poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL)  \r\n//       //     setClaimAmount(Math.floor(poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL * 100) / 100);\r\n//       //     setRewardedTime(poolInfo.rewardTime.toNumber());\r\n//       //   }\r\n//       // }\r\n//       setIsLoading(false);\r\n//       return res;\r\n//     } catch (err) {\r\n//       setIsLoading(false);\r\n//       console.log(err);\r\n//       return 0;\r\n//     }\r\n//   };\r\n\r\n//   const stakeNft = async (PoolKey: PublicKey, nftMint: PublicKey) => {\r\n//     if (!anchorWallet) {\r\n//       toast.error(\"Connect wallet first, please.\");\r\n//       return;\r\n//     }\r\n\r\n//     setIsLoading(true);\r\n\r\n//     await stake(PoolKey, nftMint, anchorWallet);\r\n//     // await updateBalance(anchorWallet);\r\n\r\n//     setIsLoading(false);\r\n//   };\r\n\r\n//   const unStakeNft = async (nfts: any[]) => {\r\n//     if (!anchorWallet) {\r\n//       toast.error(\"Connect wallet first, please.\");\r\n//       return;\r\n//     }\r\n//     setIsLoading(true);\r\n//     const res = await unStake(nfts, anchorWallet);\r\n//     // if (res == 1) {\r\n//     //   const poolInfo = await getPoolInfo(anchorWallet);\r\n//     //   console.log(\"poolInfo\", poolInfo);\r\n//     //   if (poolInfo != null) {\r\n//     //     console.log(\r\n//     //       \"poolInfo->totalReward\",\r\n//     //       poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL\r\n//     //     );\r\n//     //     console.log(\"setClaimAmt4\", poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL)  \r\n//     //     setClaimAmount(Math.floor(poolInfo.totalReward.toNumber() / LAMPORTS_PER_SOL * 100) / 100);\r\n//     //     setRewardedTime(poolInfo.rewardTime.toNumber());\r\n//     //   }\r\n//     // }\r\n//     setIsLoading(false);\r\n//     return res;\r\n//   };\r\n\r\n//   const claimRewards = async () => {\r\n//     if (!anchorWallet) {\r\n//       toast.error(\"Connect wallet first, please.\");\r\n//       return;\r\n//     }\r\n\r\n//     setIsLoading(true);\r\n//     await claim(anchorWallet);\r\n//     setIsLoading(false);\r\n//   };\r\n\r\n//   return {\r\n//     isLoading,\r\n//     stakedNfts,\r\n//     stakedCount,\r\n//     claimAmount,\r\n//     totalStakedNFT,\r\n//     stakeNftList,\r\n//     stakeNft,\r\n//     unStakeNft,\r\n//     claimRewards,\r\n//     getStakedNfts,\r\n//     setStakedNfts,\r\n//   };\r\n// };\r\n\r\n// async function withFindOrInitAssociatedTokenAccount(\r\n//   transaction: Transaction,\r\n//   connection: Connection,\r\n//   mint: PublicKey,\r\n//   owner: PublicKey,\r\n//   payer: PublicKey,\r\n//   allowOwnerOffCurve: boolean\r\n// ) {\r\n//   const associatedAddress = await splToken.Token.getAssociatedTokenAddress(\r\n//     splToken.ASSOCIATED_TOKEN_PROGRAM_ID,\r\n//     splToken.TOKEN_PROGRAM_ID,\r\n//     mint,\r\n//     owner,\r\n//     allowOwnerOffCurve\r\n//   );\r\n//   const account = await connection.getAccountInfo(associatedAddress);\r\n//   if (!account) {\r\n//     transaction.add(\r\n//       splToken.Token.createAssociatedTokenAccountInstruction(\r\n//         splToken.ASSOCIATED_TOKEN_PROGRAM_ID,\r\n//         splToken.TOKEN_PROGRAM_ID,\r\n//         mint,\r\n//         associatedAddress,\r\n//         owner,\r\n//         payer\r\n//       )\r\n//     );\r\n//   }\r\n//   return associatedAddress;\r\n// }\r\n\r\n// export default useNftStake;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA"},"metadata":{},"sourceType":"module"}