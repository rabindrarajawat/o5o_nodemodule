{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenLendingError = exports.AnchorError = exports.CustomProgramError = exports.CusperUnknownError = exports.initCusper = exports.ErrorResolver = void 0;\n\nconst parse_error_1 = require(\"./parse-error\");\n\nconst anchor = __importStar(require(\"./errors/anchor\"));\n\nconst token_lending_1 = require(\"./errors/token-lending\"); // -----------------\n// Error Resolver\n// -----------------\n\n\nclass ErrorResolver {\n  constructor(resolveErrorFromCode) {\n    this.resolveErrorFromCode = resolveErrorFromCode;\n  }\n  /**\n   * Attempts to resolve the provided error code to a known or custom error.\n   *\n   * @param captureBoundaryFn is used to exclude everything after (including)\n   * that function from the stack trace if possible\n   * @param fallbackToUnknown unless `false` a {@link CusperUnknownError} is\n   * returned when resolution fails\n   */\n\n\n  errorFromCode(code, captureBoundaryFn) {\n    let fallbackToUnknown = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // Try specific program errors first since they're more likely\n    let err = this.resolveErrorFromCode != null ? this.resolveErrorFromCode(code) : null;\n\n    if (err != null) {\n      return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);\n    } // Then try errors of known programs\n\n\n    err = AnchorError.fromCode(code);\n\n    if (err != null) {\n      return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);\n    }\n\n    err = TokenLendingError.fromCode(code);\n\n    if (err != null) {\n      return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);\n    }\n\n    if (fallbackToUnknown) {\n      err = new CusperUnknownError(code, 'CusperUnknownError', 'cusper does not know this error');\n      return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);\n    }\n  }\n  /**\n   * Attempts to parse the error code from the provied logs and then resolve it\n   * to a known or custom error.\n   * @param fallbackToUnknown unless `false` a {@link CusperUnknownError} is\n   * returned when resolution fails\n   */\n\n\n  errorFromProgramLogs(logs) {\n    let fallbackToUnknown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const code = (0, parse_error_1.errorCodeFromLogs)(logs);\n    return code == null ? null : this.errorFromCode(code, this.errorFromProgramLogs, fallbackToUnknown);\n  }\n  /**\n   * Throws an error that it attempts to resolve from the logs of the provided error.\n   * If no error can be resolved it throws a {@link CusperUnknownError} instead\n   */\n\n\n  throwError(error) {\n    const err = error.logs != null && this.errorFromProgramLogs(error.logs, true) || new CusperUnknownError(-1, 'Error created without logs and thus without error code');\n    throw this.passPreparedError(err, this.throwError);\n  }\n\n  passPreparedError(err, captureBoundaryFn) {\n    if (err == null) return null;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(err, captureBoundaryFn);\n    }\n\n    return err;\n  }\n\n}\n\nexports.ErrorResolver = ErrorResolver;\n/**\n * Initializes a Custom Program Error Resolver, aka _Cusper_.\n *\n * @param resolveErrorFromCode if provided it will be used to resolve custom\n * errors before falling back to known program errors\n */\n\nfunction initCusper(resolveErrorFromCode) {\n  return new ErrorResolver(resolveErrorFromCode);\n}\n\nexports.initCusper = initCusper; // -----------------\n// Unknown Error\n// -----------------\n\n/**\n * This error is returned/raised when an error code couldn't be found or resolved to a\n * custom or known error.\n */\n\nclass CusperUnknownError extends Error {\n  constructor(code) {\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n\n    super(...params);\n    this.code = code;\n    this.name = 'CusperUnknownError';\n  }\n\n}\n\nexports.CusperUnknownError = CusperUnknownError; // -----------------\n// Custom Program Error\n// -----------------\n\n/**\n * Used by implementers to provide their own errors to be resolved by cusper.\n */\n\nclass CustomProgramError extends Error {\n  /**\n   * Creates an instance of a {@link CustomProgramError}.\n   *\n   * @param code the error code for which this error was resolved\n   * @param name the name of the error\n   */\n  constructor(code, name) {\n    for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      params[_key2 - 2] = arguments[_key2];\n    }\n\n    super(...params);\n    this.code = code;\n    this.name = `CustomProgramError#${name}`;\n  }\n\n}\n\nexports.CustomProgramError = CustomProgramError; // -----------------\n// Anchor\n// -----------------\n\n/**\n * An error raised by the anchor program before getting to the actual program\n * implementation.\n */\n\nclass AnchorError extends Error {\n  constructor(code, name) {\n    for (var _len3 = arguments.length, params = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      params[_key3 - 2] = arguments[_key3];\n    }\n\n    super(...params);\n    this.code = code;\n    this.name = `AnchorError#${name}`;\n  }\n\n  static fromCode(code) {\n    const errorMeta = AnchorError.errorMap.get(code);\n    return errorMeta != null ? new AnchorError(errorMeta.code, errorMeta.name, errorMeta.message) : null;\n  }\n\n  toString() {\n    return `${this.name}: ${this.message}`;\n  }\n\n}\n\nexports.AnchorError = AnchorError;\nAnchorError.errorMap = Object.entries(anchor.LangErrorCode).reduce((acc, _ref) => {\n  let [key, code] = _ref;\n  acc.set(code, {\n    code,\n    name: key,\n    message: anchor.LangErrorMessage.get(code)\n  });\n  return acc;\n}, new Map()); // -----------------\n// Token Lending\n// -----------------\n\n/**\n * Error raised by the token lending program.\n * Please note that error codes overlap with other _known_ programs as they start at `0`.\n * Thus in some cases they might be wrongly represented and actually not\n * originate from the token lending program.\n */\n\nclass TokenLendingError extends Error {\n  constructor(code, name) {\n    for (var _len4 = arguments.length, params = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n      params[_key4 - 2] = arguments[_key4];\n    }\n\n    super(...params);\n    this.code = code;\n    this.name = `TokenLendingError#${name}`;\n  }\n\n  static fromCode(code) {\n    const errorMeta = TokenLendingError.errorMap.get(code);\n    return errorMeta != null ? new TokenLendingError(errorMeta.code, errorMeta.name, errorMeta.message) : null;\n  }\n\n  toString() {\n    return `${this.name}: ${this.message}`;\n  }\n\n}\n\nexports.TokenLendingError = TokenLendingError;\nTokenLendingError.errorMap = token_lending_1.tokenLendingErrors;","map":{"version":3,"sources":["../../src/resolve-error.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TokenLendingError = exports.AnchorError = exports.CustomProgramError = exports.CusperUnknownError = exports.initCusper = exports.ErrorResolver = void 0;\nconst parse_error_1 = require(\"./parse-error\");\nconst anchor = __importStar(require(\"./errors/anchor\"));\nconst token_lending_1 = require(\"./errors/token-lending\");\n// -----------------\n// Error Resolver\n// -----------------\nclass ErrorResolver {\n    constructor(resolveErrorFromCode) {\n        this.resolveErrorFromCode = resolveErrorFromCode;\n    }\n    /**\n     * Attempts to resolve the provided error code to a known or custom error.\n     *\n     * @param captureBoundaryFn is used to exclude everything after (including)\n     * that function from the stack trace if possible\n     * @param fallbackToUnknown unless `false` a {@link CusperUnknownError} is\n     * returned when resolution fails\n     */\n    errorFromCode(code, captureBoundaryFn, fallbackToUnknown = true) {\n        // Try specific program errors first since they're more likely\n        let err = this.resolveErrorFromCode != null ? this.resolveErrorFromCode(code) : null;\n        if (err != null) {\n            return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);\n        }\n        // Then try errors of known programs\n        err = AnchorError.fromCode(code);\n        if (err != null) {\n            return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);\n        }\n        err = TokenLendingError.fromCode(code);\n        if (err != null) {\n            return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);\n        }\n        if (fallbackToUnknown) {\n            err = new CusperUnknownError(code, 'CusperUnknownError', 'cusper does not know this error');\n            return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);\n        }\n    }\n    /**\n     * Attempts to parse the error code from the provied logs and then resolve it\n     * to a known or custom error.\n     * @param fallbackToUnknown unless `false` a {@link CusperUnknownError} is\n     * returned when resolution fails\n     */\n    errorFromProgramLogs(logs, fallbackToUnknown = true) {\n        const code = (0, parse_error_1.errorCodeFromLogs)(logs);\n        return code == null\n            ? null\n            : this.errorFromCode(code, this.errorFromProgramLogs, fallbackToUnknown);\n    }\n    /**\n     * Throws an error that it attempts to resolve from the logs of the provided error.\n     * If no error can be resolved it throws a {@link CusperUnknownError} instead\n     */\n    throwError(error) {\n        const err = (error.logs != null && this.errorFromProgramLogs(error.logs, true)) ||\n            new CusperUnknownError(-1, 'Error created without logs and thus without error code');\n        throw this.passPreparedError(err, this.throwError);\n    }\n    passPreparedError(err, captureBoundaryFn) {\n        if (err == null)\n            return null;\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(err, captureBoundaryFn);\n        }\n        return err;\n    }\n}\nexports.ErrorResolver = ErrorResolver;\n/**\n * Initializes a Custom Program Error Resolver, aka _Cusper_.\n *\n * @param resolveErrorFromCode if provided it will be used to resolve custom\n * errors before falling back to known program errors\n */\nfunction initCusper(resolveErrorFromCode) {\n    return new ErrorResolver(resolveErrorFromCode);\n}\nexports.initCusper = initCusper;\n// -----------------\n// Unknown Error\n// -----------------\n/**\n * This error is returned/raised when an error code couldn't be found or resolved to a\n * custom or known error.\n */\nclass CusperUnknownError extends Error {\n    constructor(code, ...params) {\n        super(...params);\n        this.code = code;\n        this.name = 'CusperUnknownError';\n    }\n}\nexports.CusperUnknownError = CusperUnknownError;\n// -----------------\n// Custom Program Error\n// -----------------\n/**\n * Used by implementers to provide their own errors to be resolved by cusper.\n */\nclass CustomProgramError extends Error {\n    /**\n     * Creates an instance of a {@link CustomProgramError}.\n     *\n     * @param code the error code for which this error was resolved\n     * @param name the name of the error\n     */\n    constructor(code, name, ...params) {\n        super(...params);\n        this.code = code;\n        this.name = `CustomProgramError#${name}`;\n    }\n}\nexports.CustomProgramError = CustomProgramError;\n// -----------------\n// Anchor\n// -----------------\n/**\n * An error raised by the anchor program before getting to the actual program\n * implementation.\n */\nclass AnchorError extends Error {\n    constructor(code, name, ...params) {\n        super(...params);\n        this.code = code;\n        this.name = `AnchorError#${name}`;\n    }\n    static fromCode(code) {\n        const errorMeta = AnchorError.errorMap.get(code);\n        return errorMeta != null\n            ? new AnchorError(errorMeta.code, errorMeta.name, errorMeta.message)\n            : null;\n    }\n    toString() {\n        return `${this.name}: ${this.message}`;\n    }\n}\nexports.AnchorError = AnchorError;\nAnchorError.errorMap = Object.entries(anchor.LangErrorCode).reduce((acc, [key, code]) => {\n    acc.set(code, {\n        code,\n        name: key,\n        message: anchor.LangErrorMessage.get(code),\n    });\n    return acc;\n}, new Map());\n// -----------------\n// Token Lending\n// -----------------\n/**\n * Error raised by the token lending program.\n * Please note that error codes overlap with other _known_ programs as they start at `0`.\n * Thus in some cases they might be wrongly represented and actually not\n * originate from the token lending program.\n */\nclass TokenLendingError extends Error {\n    constructor(code, name, ...params) {\n        super(...params);\n        this.code = code;\n        this.name = `TokenLendingError#${name}`;\n    }\n    static fromCode(code) {\n        const errorMeta = TokenLendingError.errorMap.get(code);\n        return errorMeta != null\n            ? new TokenLendingError(errorMeta.code, errorMeta.name, errorMeta.message)\n            : null;\n    }\n    toString() {\n        return `${this.name}: ${this.message}`;\n    }\n}\nexports.TokenLendingError = TokenLendingError;\nTokenLendingError.errorMap = token_lending_1.tokenLendingErrors;\n//# sourceMappingURL=resolve-error.js.map"]},"metadata":{},"sourceType":"script"}