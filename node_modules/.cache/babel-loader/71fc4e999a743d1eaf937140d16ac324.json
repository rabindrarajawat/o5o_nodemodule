{"ast":null,"code":"import { BeetReader, BeetWriter } from './read-write';\nimport { beetBytes, logDebug, logTrace } from './utils';\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. All fields of that class have to be of fixed size.\n * If a field requires a {@link FixableBeet} use the {@link FixableBeetStruct}\n * instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */\n\nexport class BeetStruct {\n  /**\n   * Creates an instance of the BeetStruct.\n   *\n   * @param fields de/serializers for each field of the {@link Class}\n   * @param construct the function that creates an instance of {@link Class}\n   * from the args\n   * @param description identifies this struct for diagnostics/debugging\n   * purposes\n   */\n  constructor(fields, construct) {\n    let description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BeetStruct.description;\n    this.fields = fields;\n    this.construct = construct;\n    this.description = description;\n    this.byteSize = this.getByteSize();\n\n    if (logDebug.enabled) {\n      const flds = fields.map(_ref => {\n        let [key, val] = _ref;\n        return `${String(key)}: ${val.description} ${beetBytes(val)}`;\n      }).join('\\n  ');\n      logDebug(`struct ${description} {\\n  ${flds}\\n} ${beetBytes(this)}`);\n    }\n  }\n  /**\n   * Along with `write` this allows structs to be treated as {@link Beet}s and\n   * thus supports composing/nesting them the same way.\n   * @private\n   */\n\n\n  read(buf, offset) {\n    const [value] = this.deserialize(buf, offset);\n    return value;\n  }\n  /**\n   * Along with `read` this allows structs to be treated as {@link Beet}s and\n   * thus supports composing/nesting them the same way.\n   * @private\n   */\n\n\n  write(buf, offset, value) {\n    const [innerBuf, innerOffset] = this.serialize(value);\n    innerBuf.copy(buf, offset, 0, innerOffset);\n  }\n  /**\n   * Deserializes an instance of the Class from the provided buffer starting to\n   * read at the provided offset.\n   *\n   * @returns `[instance of Class, offset into buffer after deserialization completed]`\n   */\n\n\n  deserialize(buffer) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (logTrace.enabled) {\n      logTrace('deserializing [%s] from %d bytes buffer', this.description, buffer.byteLength);\n      logTrace(buffer);\n      logTrace(buffer.toJSON().data);\n    }\n\n    const reader = new BeetReader(buffer, offset);\n    const args = reader.readStruct(this.fields);\n    return [this.construct(args), reader.offset];\n  }\n  /**\n   * Serializes the provided instance into a new {@link Buffer}\n   *\n   * @param instance of the struct to serialize\n   * @param byteSize allows to override the size fo the created Buffer and\n   * defaults to the size of the struct to serialize\n   */\n\n\n  serialize(instance) {\n    let byteSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.byteSize;\n    logTrace('serializing [%s] %o to %d bytes buffer', this.description, instance, byteSize);\n    const writer = new BeetWriter(byteSize);\n    writer.writeStruct(instance, this.fields);\n    return [writer.buffer, writer.offset];\n  }\n\n  getByteSize() {\n    return this.fields.reduce((acc, _ref2) => {\n      let [_, beet] = _ref2;\n      return acc + beet.byteSize;\n    }, 0);\n  }\n\n  get type() {\n    return BeetStruct.TYPE;\n  }\n\n}\nBeetStruct.description = 'BeetStruct';\nBeetStruct.TYPE = 'BeetStruct';\nexport function isBeetStruct(beet) {\n  return beet.type === BeetStruct.TYPE;\n}\n/**\n * Convenience wrapper around {@link BeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */\n\nexport class BeetArgsStruct extends BeetStruct {\n  constructor(fields) {\n    let description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BeetArgsStruct.description;\n    super(fields, args => args, description);\n  }\n\n}\nBeetArgsStruct.description = 'BeetArgsStruct';","map":{"version":3,"sources":["../../../src/struct.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BeetReader, BeetWriter } from './read-write';\nimport { beetBytes, logDebug, logTrace } from './utils';\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. All fields of that class have to be of fixed size.\n * If a field requires a {@link FixableBeet} use the {@link FixableBeetStruct}\n * instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */\nexport class BeetStruct {\n    /**\n     * Creates an instance of the BeetStruct.\n     *\n     * @param fields de/serializers for each field of the {@link Class}\n     * @param construct the function that creates an instance of {@link Class}\n     * from the args\n     * @param description identifies this struct for diagnostics/debugging\n     * purposes\n     */\n    constructor(fields, construct, description = BeetStruct.description) {\n        this.fields = fields;\n        this.construct = construct;\n        this.description = description;\n        this.byteSize = this.getByteSize();\n        if (logDebug.enabled) {\n            const flds = fields\n                .map(([key, val]) => `${String(key)}: ${val.description} ${beetBytes(val)}`)\n                .join('\\n  ');\n            logDebug(`struct ${description} {\\n  ${flds}\\n} ${beetBytes(this)}`);\n        }\n    }\n    /**\n     * Along with `write` this allows structs to be treated as {@link Beet}s and\n     * thus supports composing/nesting them the same way.\n     * @private\n     */\n    read(buf, offset) {\n        const [value] = this.deserialize(buf, offset);\n        return value;\n    }\n    /**\n     * Along with `read` this allows structs to be treated as {@link Beet}s and\n     * thus supports composing/nesting them the same way.\n     * @private\n     */\n    write(buf, offset, value) {\n        const [innerBuf, innerOffset] = this.serialize(value);\n        innerBuf.copy(buf, offset, 0, innerOffset);\n    }\n    /**\n     * Deserializes an instance of the Class from the provided buffer starting to\n     * read at the provided offset.\n     *\n     * @returns `[instance of Class, offset into buffer after deserialization completed]`\n     */\n    deserialize(buffer, offset = 0) {\n        if (logTrace.enabled) {\n            logTrace('deserializing [%s] from %d bytes buffer', this.description, buffer.byteLength);\n            logTrace(buffer);\n            logTrace(buffer.toJSON().data);\n        }\n        const reader = new BeetReader(buffer, offset);\n        const args = reader.readStruct(this.fields);\n        return [this.construct(args), reader.offset];\n    }\n    /**\n     * Serializes the provided instance into a new {@link Buffer}\n     *\n     * @param instance of the struct to serialize\n     * @param byteSize allows to override the size fo the created Buffer and\n     * defaults to the size of the struct to serialize\n     */\n    serialize(instance, byteSize = this.byteSize) {\n        logTrace('serializing [%s] %o to %d bytes buffer', this.description, instance, byteSize);\n        const writer = new BeetWriter(byteSize);\n        writer.writeStruct(instance, this.fields);\n        return [writer.buffer, writer.offset];\n    }\n    getByteSize() {\n        return this.fields.reduce((acc, [_, beet]) => acc + beet.byteSize, 0);\n    }\n    get type() {\n        return BeetStruct.TYPE;\n    }\n}\nBeetStruct.description = 'BeetStruct';\nBeetStruct.TYPE = 'BeetStruct';\nexport function isBeetStruct(beet) {\n    return beet.type === BeetStruct.TYPE;\n}\n/**\n * Convenience wrapper around {@link BeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */\nexport class BeetArgsStruct extends BeetStruct {\n    constructor(fields, description = BeetArgsStruct.description) {\n        super(fields, (args) => args, description);\n    }\n}\nBeetArgsStruct.description = 'BeetArgsStruct';\n//# sourceMappingURL=struct.js.map"]},"metadata":{},"sourceType":"module"}