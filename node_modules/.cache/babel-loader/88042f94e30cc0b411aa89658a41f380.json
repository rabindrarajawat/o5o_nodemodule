{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enumsTypeMap = exports.dataEnum = exports.uniformDataEnum = exports.fixedScalarEnum = void 0;\n\nconst types_1 = require(\"../types\");\n\nconst numbers_1 = require(\"./numbers\");\n\nconst assert_1 = require(\"assert\");\n\nconst struct_1 = require(\"../struct\");\n\nconst struct_fixable_1 = require(\"../struct.fixable\");\n\nconst unit_1 = require(\"./unit\"); // -----------------\n// Fixed Scalar Enum\n// -----------------\n\n\nfunction resolveEnumVariant(value, isNumVariant) {\n  return isNumVariant ? `${value}` : value;\n}\n/**\n * De/serializer for enums with up to 255 less variants which have no data.\n *\n * @param enumType type of enum to process, i.e. Color or Direction\n *\n * @category beet/enum\n */\n\n\nfunction fixedScalarEnum(enumType) {\n  const keys = Object.keys(enumType);\n  return {\n    write(buf, offset, value) {\n      const isNumVariant = typeof value === 'number';\n      const variantKey = resolveEnumVariant(value, isNumVariant);\n\n      if (!keys.includes(variantKey)) {\n        assert_1.strict.fail(`${value} should be a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);\n      }\n\n      if (isNumVariant) {\n        numbers_1.u8.write(buf, offset, value);\n      } else {\n        const enumValue = enumType[variantKey];\n        numbers_1.u8.write(buf, offset, enumValue);\n      }\n    },\n\n    read(buf, offset) {\n      const value = numbers_1.u8.read(buf, offset);\n      const isNumVariant = typeof value === 'number';\n      const variantKey = resolveEnumVariant(value, isNumVariant);\n\n      if (!keys.includes(variantKey)) {\n        assert_1.strict.fail(`${value} should be a of a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);\n      }\n\n      return isNumVariant ? value : enumType[variantKey];\n    },\n\n    byteSize: numbers_1.u8.byteSize,\n    description: 'Enum'\n  };\n}\n\nexports.fixedScalarEnum = fixedScalarEnum;\n/**\n * De/Serializes an {@link Enum} that contains a type of data, i.e. a {@link Struct}.\n * The main difference to a Rust enum is that the type of data has to be the\n * same for all enum variants.\n *\n * @template T inner enum data type\n *\n * @param inner the De/Serializer for the data type\n *\n * @category beet/enum\n */\n\nfunction uniformDataEnum(inner) {\n  return {\n    write: function (buf, offset, value) {\n      numbers_1.u8.write(buf, offset, value.kind);\n      inner.write(buf, offset + 1, value.data);\n    },\n    read: function (buf, offset) {\n      const kind = numbers_1.u8.read(buf, offset);\n      const data = inner.read(buf, offset + 1);\n      return {\n        kind,\n        data\n      };\n    },\n    byteSize: 1 + inner.byteSize,\n    description: `UniformDataEnum<${inner.description}>`\n  };\n}\n\nexports.uniformDataEnum = uniformDataEnum;\n\nfunction enumDataVariantBeet(inner, discriminant, kind) {\n  return {\n    write(buf, offset, value) {\n      numbers_1.u8.write(buf, offset, discriminant);\n      inner.write(buf, offset + numbers_1.u8.byteSize, value);\n    },\n\n    read(buf, offset) {\n      const val = inner.read(buf, offset + numbers_1.u8.byteSize);\n      return {\n        __kind: kind,\n        ...val\n      };\n    },\n\n    byteSize: inner.byteSize + numbers_1.u8.byteSize,\n    description: `EnumData<${inner.description}>`\n  };\n}\n/**\n * De/serializes Data Enums.\n * They are represented as a discriminated unions in TypeScript.\n *\n * NOTE: only structs, i.e. {@link BeetArgsStruct} and\n * {@link FixableBeetArgsStruct} are supported as the data of each enum variant.\n *\n * ## Example\n *\n * ```ts\n * type Simple = {\n *   First: { n1: number }\n *   Second: { n2: number }\n * }\n *\n * const beet = dataEnum<Simple>([\n *   ['First', new BeetArgsStruct<Simple['First']>([['n1', u32]])],\n *   ['Second', new BeetArgsStruct<Simple['Second']>([['n2', u32]])],\n * ])\n * ```\n *\n * @category beet/enum\n * @param variants an array of {@link DataEnumBeet}s each a tuple of `[ kind, data ]`\n */\n\n\nfunction dataEnum(variants) {\n  for (const [_, beet] of variants) {\n    (0, assert_1.strict)((0, struct_1.isBeetStruct)(beet) || (0, struct_fixable_1.isFixableBeetStruct)(beet) || // scalar variant\n    beet === unit_1.unit, 'dataEnum: variants must be a data beet struct or a scalar unit');\n  }\n\n  return {\n    toFixedFromData(buf, offset) {\n      const discriminant = numbers_1.u8.read(buf, offset);\n      const variant = variants[discriminant];\n      (0, assert_1.strict)(variant != null, `Discriminant ${discriminant} out of range for ${variants.length} variants`);\n      const [__kind, dataBeet] = variant;\n      const fixed = (0, types_1.isFixedSizeBeet)(dataBeet) ? dataBeet : dataBeet.toFixedFromData(buf, offset + 1);\n      return enumDataVariantBeet(fixed, discriminant, __kind);\n    },\n\n    toFixedFromValue(val) {\n      if (val.__kind == null) {\n        const keys = Object.keys(val).join(', ');\n        const validKinds = variants.map(_ref => {\n          let [__kind] = _ref;\n          return __kind;\n        }).join(', ');\n        assert_1.strict.fail(`Value with fields [ ${keys} ] is missing __kind, ` + `which needs to be set to one of [ ${validKinds} ]`);\n      }\n\n      const discriminant = variants.findIndex(_ref2 => {\n        let [__kind] = _ref2;\n        return __kind === val.__kind;\n      });\n\n      if (discriminant < 0) {\n        const validKinds = variants.map(_ref3 => {\n          let [__kind] = _ref3;\n          return __kind;\n        }).join(', ');\n        assert_1.strict.fail(`${val.__kind} is not a valid kind, needs to be one of [ ${validKinds} ]`);\n      }\n\n      const variant = variants[discriminant];\n      const {\n        __kind,\n        ...dataValue\n      } = val;\n      const [__variantKind, dataBeet] = variant;\n      const fixed = (0, types_1.isFixedSizeBeet)(dataBeet) ? dataBeet : dataBeet.toFixedFromValue(dataValue);\n      return enumDataVariantBeet(fixed, discriminant, __variantKind);\n    },\n\n    description: `DataEnum<${variants.length} variants>`\n  };\n}\n\nexports.dataEnum = dataEnum;\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexports.enumsTypeMap = {\n  fixedScalarEnum: {\n    beet: 'fixedScalarEnum',\n    isFixable: false,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: '<TypeName>',\n    arg: types_1.BEET_TYPE_ARG_INNER,\n    pack: types_1.BEET_PACKAGE\n  },\n  dataEnum: {\n    beet: 'dataEnum',\n    isFixable: false,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: 'DataEnum<Kind, Inner>',\n    arg: types_1.BEET_TYPE_ARG_INNER,\n    pack: types_1.BEET_PACKAGE\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/enums.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.enumsTypeMap = exports.dataEnum = exports.uniformDataEnum = exports.fixedScalarEnum = void 0;\nconst types_1 = require(\"../types\");\nconst numbers_1 = require(\"./numbers\");\nconst assert_1 = require(\"assert\");\nconst struct_1 = require(\"../struct\");\nconst struct_fixable_1 = require(\"../struct.fixable\");\nconst unit_1 = require(\"./unit\");\n// -----------------\n// Fixed Scalar Enum\n// -----------------\nfunction resolveEnumVariant(value, isNumVariant) {\n    return (isNumVariant ? `${value}` : value);\n}\n/**\n * De/serializer for enums with up to 255 less variants which have no data.\n *\n * @param enumType type of enum to process, i.e. Color or Direction\n *\n * @category beet/enum\n */\nfunction fixedScalarEnum(enumType) {\n    const keys = Object.keys(enumType);\n    return {\n        write(buf, offset, value) {\n            const isNumVariant = typeof value === 'number';\n            const variantKey = resolveEnumVariant(value, isNumVariant);\n            if (!keys.includes(variantKey)) {\n                assert_1.strict.fail(`${value} should be a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);\n            }\n            if (isNumVariant) {\n                numbers_1.u8.write(buf, offset, value);\n            }\n            else {\n                const enumValue = enumType[variantKey];\n                numbers_1.u8.write(buf, offset, enumValue);\n            }\n        },\n        read(buf, offset) {\n            const value = numbers_1.u8.read(buf, offset);\n            const isNumVariant = typeof value === 'number';\n            const variantKey = resolveEnumVariant(value, isNumVariant);\n            if (!keys.includes(variantKey)) {\n                assert_1.strict.fail(`${value} should be a of a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);\n            }\n            return (isNumVariant ? value : enumType[variantKey]);\n        },\n        byteSize: numbers_1.u8.byteSize,\n        description: 'Enum',\n    };\n}\nexports.fixedScalarEnum = fixedScalarEnum;\n/**\n * De/Serializes an {@link Enum} that contains a type of data, i.e. a {@link Struct}.\n * The main difference to a Rust enum is that the type of data has to be the\n * same for all enum variants.\n *\n * @template T inner enum data type\n *\n * @param inner the De/Serializer for the data type\n *\n * @category beet/enum\n */\nfunction uniformDataEnum(inner) {\n    return {\n        write: function (buf, offset, value) {\n            numbers_1.u8.write(buf, offset, value.kind);\n            inner.write(buf, offset + 1, value.data);\n        },\n        read: function (buf, offset) {\n            const kind = numbers_1.u8.read(buf, offset);\n            const data = inner.read(buf, offset + 1);\n            return { kind, data };\n        },\n        byteSize: 1 + inner.byteSize,\n        description: `UniformDataEnum<${inner.description}>`,\n    };\n}\nexports.uniformDataEnum = uniformDataEnum;\nfunction enumDataVariantBeet(inner, discriminant, kind) {\n    return {\n        write(buf, offset, value) {\n            numbers_1.u8.write(buf, offset, discriminant);\n            inner.write(buf, offset + numbers_1.u8.byteSize, value);\n        },\n        read(buf, offset) {\n            const val = inner.read(buf, offset + numbers_1.u8.byteSize);\n            return { __kind: kind, ...val };\n        },\n        byteSize: inner.byteSize + numbers_1.u8.byteSize,\n        description: `EnumData<${inner.description}>`,\n    };\n}\n/**\n * De/serializes Data Enums.\n * They are represented as a discriminated unions in TypeScript.\n *\n * NOTE: only structs, i.e. {@link BeetArgsStruct} and\n * {@link FixableBeetArgsStruct} are supported as the data of each enum variant.\n *\n * ## Example\n *\n * ```ts\n * type Simple = {\n *   First: { n1: number }\n *   Second: { n2: number }\n * }\n *\n * const beet = dataEnum<Simple>([\n *   ['First', new BeetArgsStruct<Simple['First']>([['n1', u32]])],\n *   ['Second', new BeetArgsStruct<Simple['Second']>([['n2', u32]])],\n * ])\n * ```\n *\n * @category beet/enum\n * @param variants an array of {@link DataEnumBeet}s each a tuple of `[ kind, data ]`\n */\nfunction dataEnum(variants) {\n    for (const [_, beet] of variants) {\n        (0, assert_1.strict)((0, struct_1.isBeetStruct)(beet) ||\n            (0, struct_fixable_1.isFixableBeetStruct)(beet) ||\n            // scalar variant\n            beet === unit_1.unit, 'dataEnum: variants must be a data beet struct or a scalar unit');\n    }\n    return {\n        toFixedFromData(buf, offset) {\n            const discriminant = numbers_1.u8.read(buf, offset);\n            const variant = variants[discriminant];\n            (0, assert_1.strict)(variant != null, `Discriminant ${discriminant} out of range for ${variants.length} variants`);\n            const [__kind, dataBeet] = variant;\n            const fixed = (0, types_1.isFixedSizeBeet)(dataBeet)\n                ? dataBeet\n                : dataBeet.toFixedFromData(buf, offset + 1);\n            return enumDataVariantBeet(fixed, discriminant, __kind);\n        },\n        toFixedFromValue(val) {\n            if (val.__kind == null) {\n                const keys = Object.keys(val).join(', ');\n                const validKinds = variants.map(([__kind]) => __kind).join(', ');\n                assert_1.strict.fail(`Value with fields [ ${keys} ] is missing __kind, ` +\n                    `which needs to be set to one of [ ${validKinds} ]`);\n            }\n            const discriminant = variants.findIndex(([__kind]) => __kind === val.__kind);\n            if (discriminant < 0) {\n                const validKinds = variants.map(([__kind]) => __kind).join(', ');\n                assert_1.strict.fail(`${val.__kind} is not a valid kind, needs to be one of [ ${validKinds} ]`);\n            }\n            const variant = variants[discriminant];\n            const { __kind, ...dataValue } = val;\n            const [__variantKind, dataBeet] = variant;\n            const fixed = (0, types_1.isFixedSizeBeet)(dataBeet)\n                ? dataBeet\n                : dataBeet.toFixedFromValue(dataValue);\n            return enumDataVariantBeet(fixed, discriminant, __variantKind);\n        },\n        description: `DataEnum<${variants.length} variants>`,\n    };\n}\nexports.dataEnum = dataEnum;\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.enumsTypeMap = {\n    fixedScalarEnum: {\n        beet: 'fixedScalarEnum',\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: '<TypeName>',\n        arg: types_1.BEET_TYPE_ARG_INNER,\n        pack: types_1.BEET_PACKAGE,\n    },\n    dataEnum: {\n        beet: 'dataEnum',\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: 'DataEnum<Kind, Inner>',\n        arg: types_1.BEET_TYPE_ARG_INNER,\n        pack: types_1.BEET_PACKAGE,\n    },\n};\n//# sourceMappingURL=enums.js.map"]},"metadata":{},"sourceType":"script"}