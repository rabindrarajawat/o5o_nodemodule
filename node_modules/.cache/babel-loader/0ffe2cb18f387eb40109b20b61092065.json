{"ast":null,"code":"import { assertNftOrSftWithToken } from '../../nftModule/models/Nft.mjs';\nimport assert from '../../../utils/assert.mjs';\nimport { useOperation } from '../../../types/Operation.mjs';\nimport { amount } from '../../../types/Amount.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'LoadBidOperation';\n/**\n * Transforms a `LazyBid` model into a `Bid` model.\n *\n * ```ts\n * const bid = await metaplex\n *   .auctionHouse()\n *   .loadBid({ lazyBid };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst loadBidOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst loadBidOperationHandler = {\n  handle: async (operation, metaplex, scope) => {\n    const {\n      lazyBid,\n      loadJsonMetadata = true\n    } = operation.input;\n    const bid = { ...lazyBid,\n      model: 'bid',\n      lazy: false\n    };\n\n    if (lazyBid.tokenAddress) {\n      const asset = await metaplex.nfts().findByToken({\n        token: lazyBid.tokenAddress,\n        loadJsonMetadata\n      }, scope);\n      scope.throwIfCanceled();\n      assertNftOrSftWithToken(asset);\n      assert(asset.metadataAddress.equals(lazyBid.metadataAddress), `Asset metadata address must be ${lazyBid.metadataAddress}`);\n      return { ...bid,\n        isPublic: false,\n        asset,\n        tokens: amount(lazyBid.tokens, asset.mint.currency)\n      };\n    }\n\n    const asset = await metaplex.nfts().findByMetadata({\n      metadata: lazyBid.metadataAddress,\n      loadJsonMetadata\n    }, scope);\n    scope.throwIfCanceled();\n    return { ...bid,\n      isPublic: true,\n      asset,\n      tokens: amount(lazyBid.tokens, asset.mint.currency)\n    };\n  }\n};\nexport { loadBidOperation, loadBidOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/auctionHouseModule/operations/loadBid.ts"],"names":["Key","loadBidOperation","useOperation","loadBidOperationHandler","handle","operation","metaplex","scope","lazyBid","loadJsonMetadata","input","bid","model","lazy","tokenAddress","asset","nfts","findByToken","token","throwIfCanceled","assertNftOrSftWithToken","assert","metadataAddress","equals","isPublic","tokens","amount","mint","currency","findByMetadata","metadata"],"mappings":";;;oDAYA;AACA;AACA;;AAEA,MAAMA,GAAG,GAAG,kBAAZ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;MACaC,gBAAgB,GAAGC,YAAY,CAAmBF,GAAnB,C;AAE5C;AACA;AACA;AACA;;AAmBA;AACA;AACA;AACA;;AACO,MAAMG,uBAA2D,GAAG;EACzEC,MAAM,EAAE,OACNC,SADM,EAENC,QAFM,EAGNC,KAHM,KAIH;IACH,MAAM;MAAEC,OAAF;MAAWC,gBAAgB,GAAG;IAA9B,IAAuCJ,SAAS,CAACK,KAAvD;IAEA,MAAMC,GAAkC,GAAG,EACzC,GAAGH,OADsC;MAEzCI,KAAK,EAAE,KAFkC;MAGzCC,IAAI,EAAE;IAHmC,CAA3C;;IAMA,IAAIL,OAAO,CAACM,YAAZ,EAA0B;MACxB,MAAMC,KAAK,GAAG,MAAMT,QAAQ,CACzBU,IADiBV,GAEjBW,WAFiBX,CAEL;QAAEY,KAAK,EAAEV,OAAO,CAACM,YAAjB;QAA+BL;MAA/B,CAFKH,EAE8CC,KAF9CD,CAApB;MAGAC,KAAK,CAACY,eAANZ;MAEAa,uBAAuB,CAACL,KAAD,CAAvBK;MACAC,MAAM,CACJN,KAAK,CAACO,eAANP,CAAsBQ,MAAtBR,CAA6BP,OAAO,CAACc,eAArCP,CADI,EAEH,kCAAiCP,OAAO,CAACc,eAAgB,EAFtD,CAAND;MAKA,OAAO,EACL,GAAGV,GADE;QAELa,QAAQ,EAAE,KAFL;QAGLT,KAHK;QAILU,MAAM,EAAEC,MAAM,CAAClB,OAAO,CAACiB,MAAT,EAAiBV,KAAK,CAACY,IAANZ,CAAWa,QAA5B;MAJT,CAAP;IAMF;;IACA,MAAMb,KAAK,GAAG,MAAMT,QAAQ,CACzBU,IADiBV,GAEjBuB,cAFiBvB,CAGhB;MAAEwB,QAAQ,EAAEtB,OAAO,CAACc,eAApB;MAAqCb;IAArC,CAHgBH,EAIhBC,KAJgBD,CAApB;IAMAC,KAAK,CAACY,eAANZ;IAEA,OAAO,EACL,GAAGI,GADE;MAELa,QAAQ,EAAE,IAFL;MAGLT,KAHK;MAILU,MAAM,EAAEC,MAAM,CAAClB,OAAO,CAACiB,MAAT,EAAiBV,KAAK,CAACY,IAANZ,CAAWa,QAA5B;IAJT,CAAP;EAMF;AA/CyE,CAApE","sourcesContent":["import { assertNftOrSftWithToken } from '../../nftModule';\nimport { Bid, LazyBid } from '../models/Bid';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  amount,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { assert } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'LoadBidOperation' as const;\n\n/**\n * Transforms a `LazyBid` model into a `Bid` model.\n *\n * ```ts\n * const bid = await metaplex\n *   .auctionHouse()\n *   .loadBid({ lazyBid };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const loadBidOperation = useOperation<LoadBidOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type LoadBidOperation = Operation<typeof Key, LoadBidInput, Bid>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type LoadBidInput = {\n  /** The `LazyBid` model to transform into the `Bid`.  */\n  lazyBid: LazyBid;\n\n  /**\n   * Whether or not we should fetch the JSON Metadata for the NFT or SFT.\n   *\n   * @defaultValue `true`\n   */\n  loadJsonMetadata?: boolean;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const loadBidOperationHandler: OperationHandler<LoadBidOperation> = {\n  handle: async (\n    operation: LoadBidOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ) => {\n    const { lazyBid, loadJsonMetadata = true } = operation.input;\n\n    const bid: Omit<Bid, 'asset' | 'tokens'> = {\n      ...lazyBid,\n      model: 'bid',\n      lazy: false,\n    };\n\n    if (lazyBid.tokenAddress) {\n      const asset = await metaplex\n        .nfts()\n        .findByToken({ token: lazyBid.tokenAddress, loadJsonMetadata }, scope);\n      scope.throwIfCanceled();\n\n      assertNftOrSftWithToken(asset);\n      assert(\n        asset.metadataAddress.equals(lazyBid.metadataAddress),\n        `Asset metadata address must be ${lazyBid.metadataAddress}`\n      );\n\n      return {\n        ...bid,\n        isPublic: false,\n        asset,\n        tokens: amount(lazyBid.tokens, asset.mint.currency),\n      };\n    }\n    const asset = await metaplex\n      .nfts()\n      .findByMetadata(\n        { metadata: lazyBid.metadataAddress, loadJsonMetadata },\n        scope\n      );\n    scope.throwIfCanceled();\n\n    return {\n      ...bid,\n      isPublic: true,\n      asset,\n      tokens: amount(lazyBid.tokens, asset.mint.currency),\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"module"}