{"ast":null,"code":"import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nexport var TransferFeeInstruction;\n\n(function (TransferFeeInstruction) {\n  TransferFeeInstruction[TransferFeeInstruction[\"InitializeTransferFeeConfig\"] = 0] = \"InitializeTransferFeeConfig\";\n  TransferFeeInstruction[TransferFeeInstruction[\"TransferCheckedWithFee\"] = 1] = \"TransferCheckedWithFee\";\n  TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromMint\"] = 2] = \"WithdrawWithheldTokensFromMint\";\n  TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromAccounts\"] = 3] = \"WithdrawWithheldTokensFromAccounts\";\n  TransferFeeInstruction[TransferFeeInstruction[\"HarvestWithheldTokensToMint\"] = 4] = \"HarvestWithheldTokensToMint\";\n  TransferFeeInstruction[TransferFeeInstruction[\"SetTransferFee\"] = 5] = \"SetTransferFee\";\n})(TransferFeeInstruction || (TransferFeeInstruction = {}));\n/** TODO: docs */\n\n\nexport const initializeTransferFeeConfigInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), u8('transferFeeConfigAuthorityOption'), publicKey('transferFeeConfigAuthority'), u8('withdrawWithheldAuthorityOption'), publicKey('withdrawWithheldAuthority'), u16('transferFeeBasisPoints'), u64('maximumFee')]);\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\n\nexport function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee) {\n  let programId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : TOKEN_2022_PROGRAM_ID;\n\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n\n  const keys = [{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }];\n  const data = Buffer.alloc(initializeTransferFeeConfigInstructionData.span);\n  initializeTransferFeeConfigInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n    transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,\n    transferFeeConfigAuthority: transferFeeConfigAuthority || new PublicKey(0),\n    withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,\n    withdrawWithheldAuthority: withdrawWithheldAuthority || new PublicKey(0),\n    transferFeeBasisPoints: transferFeeBasisPoints,\n    maximumFee: maximumFee\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\n\nexport function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== initializeTransferFeeConfigInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint\n    },\n    data\n  } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint\n    },\n    data\n  };\n}\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\n\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked(_ref) {\n  let {\n    programId,\n    keys: [mint],\n    data\n  } = _ref;\n  const {\n    instruction,\n    transferFeeInstruction,\n    transferFeeConfigAuthorityOption,\n    transferFeeConfigAuthority,\n    withdrawWithheldAuthorityOption,\n    withdrawWithheldAuthority,\n    transferFeeBasisPoints,\n    maximumFee\n  } = initializeTransferFeeConfigInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,\n      withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,\n      transferFeeBasisPoints,\n      maximumFee\n    }\n  };\n}\nexport const transferCheckedWithFeeInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), u64('amount'), u8('decimals'), u64('fee')]);\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\n\nexport function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee) {\n  let multiSigners = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];\n  let programId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : TOKEN_2022_PROGRAM_ID;\n\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n\n  const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n  transferCheckedWithFeeInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n    amount,\n    decimals,\n    fee\n  }, data);\n  const keys = [];\n  keys.push({\n    pubkey: source,\n    isSigner: false,\n    isWritable: true\n  });\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: false\n  });\n  keys.push({\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  });\n  keys.push({\n    pubkey: authority,\n    isSigner: !multiSigners.length,\n    isWritable: false\n  });\n\n  for (const signer of multiSigners) {\n    keys.push({\n      pubkey: signer.publicKey,\n      isSigner: true,\n      isWritable: false\n    });\n  }\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\n\nexport function decodeTransferCheckedWithFeeInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== transferCheckedWithFeeInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      source,\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data\n  } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      source,\n      mint,\n      destination,\n      authority,\n      signers: signers ? signers : null\n    },\n    data\n  };\n}\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\n\nexport function decodeTransferCheckedWithFeeInstructionUnchecked(_ref2) {\n  let {\n    programId,\n    keys: [source, mint, destination, authority, ...signers],\n    data\n  } = _ref2;\n  const {\n    instruction,\n    transferFeeInstruction,\n    amount,\n    decimals,\n    fee\n  } = transferCheckedWithFeeInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      source,\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      amount,\n      decimals,\n      fee\n    }\n  };\n}\nexport const withdrawWithheldTokensFromMintInstructionData = struct([u8('instruction'), u8('transferFeeInstruction')]);\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\n\nexport function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority) {\n  let signers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let programId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TOKEN_2022_PROGRAM_ID;\n\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n\n  const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n  withdrawWithheldTokensFromMintInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint\n  }, data);\n  const keys = [];\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: authority,\n    isSigner: !signers.length,\n    isWritable: false\n  });\n\n  for (const signer of signers) {\n    keys.push({\n      pubkey: signer.publicKey,\n      isSigner: true,\n      isWritable: false\n    });\n  }\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\n\nexport function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data\n  } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers: signers ? signers : null\n    },\n    data\n  };\n}\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\n\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked(_ref3) {\n  let {\n    programId,\n    keys: [mint, destination, authority, ...signers],\n    data\n  } = _ref3;\n  const {\n    instruction,\n    transferFeeInstruction\n  } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data: {\n      instruction,\n      transferFeeInstruction\n    }\n  };\n}\nexport const withdrawWithheldTokensFromAccountsInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), u8('numTokenAccounts')]);\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\n\nexport function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources) {\n  let programId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : TOKEN_2022_PROGRAM_ID;\n\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n\n  const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n  withdrawWithheldTokensFromAccountsInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n    numTokenAccounts: sources.length\n  }, data);\n  const keys = [];\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: authority,\n    isSigner: !signers.length,\n    isWritable: false\n  });\n\n  for (const signer of signers) {\n    keys.push({\n      pubkey: signer.publicKey,\n      isSigner: true,\n      isWritable: false\n    });\n  }\n\n  for (const source of sources) {\n    keys.push({\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    });\n  }\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\n\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers,\n      sources\n    },\n    data\n  } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers: signers ? signers : null,\n      sources: sources ? sources : null\n    },\n    data\n  };\n}\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\n\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(_ref4) {\n  let {\n    programId,\n    keys,\n    data\n  } = _ref4;\n  const {\n    instruction,\n    transferFeeInstruction,\n    numTokenAccounts\n  } = withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n  const [mint, destination, authority, signers, sources] = [keys[0], keys[1], keys[2], keys.slice(3, 3 + numTokenAccounts), keys.slice(-1 * numTokenAccounts)];\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers,\n      sources\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      numTokenAccounts\n    }\n  };\n}\nexport const harvestWithheldTokensToMintInstructionData = struct([u8('instruction'), u8('transferFeeInstruction')]);\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\n\nexport function createHarvestWithheldTokensToMintInstruction(mint, sources) {\n  let programId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TOKEN_2022_PROGRAM_ID;\n\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n\n  const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n  harvestWithheldTokensToMintInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint\n  }, data);\n  const keys = [];\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  });\n\n  for (const source of sources) {\n    keys.push({\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    });\n  }\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\n\nexport function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      sources\n    },\n    data\n  } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      sources\n    },\n    data\n  };\n}\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\n\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked(_ref5) {\n  let {\n    programId,\n    keys: [mint, ...sources],\n    data\n  } = _ref5;\n  const {\n    instruction,\n    transferFeeInstruction\n  } = harvestWithheldTokensToMintInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint,\n      sources\n    },\n    data: {\n      instruction,\n      transferFeeInstruction\n    }\n  };\n}","map":{"version":3,"sources":["../../../../src/extensions/transferFee/instructions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, TokenUnsupportedInstructionError, } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nexport var TransferFeeInstruction;\n(function (TransferFeeInstruction) {\n    TransferFeeInstruction[TransferFeeInstruction[\"InitializeTransferFeeConfig\"] = 0] = \"InitializeTransferFeeConfig\";\n    TransferFeeInstruction[TransferFeeInstruction[\"TransferCheckedWithFee\"] = 1] = \"TransferCheckedWithFee\";\n    TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromMint\"] = 2] = \"WithdrawWithheldTokensFromMint\";\n    TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromAccounts\"] = 3] = \"WithdrawWithheldTokensFromAccounts\";\n    TransferFeeInstruction[TransferFeeInstruction[\"HarvestWithheldTokensToMint\"] = 4] = \"HarvestWithheldTokensToMint\";\n    TransferFeeInstruction[TransferFeeInstruction[\"SetTransferFee\"] = 5] = \"SetTransferFee\";\n})(TransferFeeInstruction || (TransferFeeInstruction = {}));\n/** TODO: docs */\nexport const initializeTransferFeeConfigInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u8('transferFeeConfigAuthorityOption'),\n    publicKey('transferFeeConfigAuthority'),\n    u8('withdrawWithheldAuthorityOption'),\n    publicKey('withdrawWithheldAuthority'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(initializeTransferFeeConfigInstructionData.span);\n    initializeTransferFeeConfigInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n        transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,\n        transferFeeConfigAuthority: transferFeeConfigAuthority || new PublicKey(0),\n        withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,\n        withdrawWithheldAuthority: withdrawWithheldAuthority || new PublicKey(0),\n        transferFeeBasisPoints: transferFeeBasisPoints,\n        maximumFee: maximumFee,\n    }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeTransferFeeConfigInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint }, data, } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked({ programId, keys: [mint], data, }) {\n    const { instruction, transferFeeInstruction, transferFeeConfigAuthorityOption, transferFeeConfigAuthority, withdrawWithheldAuthorityOption, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, } = initializeTransferFeeConfigInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,\n            withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\nexport const transferCheckedWithFeeInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u64('amount'),\n    u8('decimals'),\n    u64('fee'),\n]);\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n    transferCheckedWithFeeInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n        amount,\n        decimals,\n        fee,\n    }, data);\n    const keys = [];\n    keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    keys.push({ pubkey: mint, isSigner: false, isWritable: false });\n    keys.push({ pubkey: destination, isSigner: false, isWritable: true });\n    keys.push({ pubkey: authority, isSigner: !multiSigners.length, isWritable: false });\n    for (const signer of multiSigners) {\n        keys.push({ pubkey: signer.publicKey, isSigner: true, isWritable: false });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedWithFeeInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedWithFeeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { source, mint, destination, authority, signers }, data, } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedWithFeeInstructionUnchecked({ programId, keys: [source, mint, destination, authority, ...signers], data, }) {\n    const { instruction, transferFeeInstruction, amount, decimals, fee } = transferCheckedWithFeeInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            amount,\n            decimals,\n            fee,\n        },\n    };\n}\nexport const withdrawWithheldTokensFromMintInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority, signers = [], programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n    withdrawWithheldTokensFromMintInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint,\n    }, data);\n    const keys = [];\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true }, { pubkey: destination, isSigner: false, isWritable: true }, { pubkey: authority, isSigner: !signers.length, isWritable: false });\n    for (const signer of signers) {\n        keys.push({ pubkey: signer.publicKey, isSigner: true, isWritable: false });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, destination, authority, signers }, data, } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({ programId, keys: [mint, destination, authority, ...signers], data, }) {\n    const { instruction, transferFeeInstruction } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\nexport const withdrawWithheldTokensFromAccountsInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u8('numTokenAccounts'),\n]);\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n    withdrawWithheldTokensFromAccountsInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n        numTokenAccounts: sources.length,\n    }, data);\n    const keys = [];\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true }, { pubkey: destination, isSigner: false, isWritable: true }, { pubkey: authority, isSigner: !signers.length, isWritable: false });\n    for (const signer of signers) {\n        keys.push({ pubkey: signer.publicKey, isSigner: true, isWritable: false });\n    }\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, destination, authority, signers, sources }, data, } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n            sources: sources ? sources : null,\n        },\n        data,\n    };\n}\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({ programId, keys, data, }) {\n    const { instruction, transferFeeInstruction, numTokenAccounts } = withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n    const [mint, destination, authority, signers, sources] = [\n        keys[0],\n        keys[1],\n        keys[2],\n        keys.slice(3, 3 + numTokenAccounts),\n        keys.slice(-1 * numTokenAccounts),\n    ];\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            numTokenAccounts,\n        },\n    };\n}\nexport const harvestWithheldTokensToMintInstructionData = struct([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createHarvestWithheldTokensToMintInstruction(mint, sources, programId = TOKEN_2022_PROGRAM_ID) {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n    harvestWithheldTokensToMintInstructionData.encode({\n        instruction: TokenInstruction.TransferFeeExtension,\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint,\n    }, data);\n    const keys = [];\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true });\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {\n    if (!instruction.programId.equals(programId))\n        throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n    const { keys: { mint, sources }, data, } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint)\n        throw new TokenInvalidInstructionKeysError();\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data,\n    };\n}\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked({ programId, keys: [mint, ...sources], data, }) {\n    const { instruction, transferFeeInstruction } = harvestWithheldTokensToMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n//# sourceMappingURL=instructions.js.map"]},"metadata":{},"sourceType":"module"}