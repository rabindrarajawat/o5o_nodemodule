{"ast":null,"code":"import { defineProperty as _defineProperty } from '../_virtual/_rollupPluginBabelHelpers.mjs';\nimport EventEmitterPackage from 'eventemitter3';\nimport { Disposable } from './Disposable.mjs';\nimport { TaskIsAlreadyRunningError } from '../errors/SdkError.mjs';\n\nclass Task {\n  constructor(callback) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _defineProperty(this, \"status\", 'pending');\n\n    _defineProperty(this, \"result\", undefined);\n\n    _defineProperty(this, \"error\", undefined);\n\n    this.callback = callback;\n    this.children = children;\n    this.context = context;\n    this.eventEmitter = new EventEmitterPackage.EventEmitter();\n  }\n\n  async run() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.isRunning()) {\n      throw new TaskIsAlreadyRunningError();\n    }\n\n    if (this.isPending() || (options.force ?? false)) {\n      for (var _len = arguments.length, inputs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        inputs[_key - 1] = arguments[_key];\n      }\n\n      return this.forceRun(options, ...inputs);\n    }\n\n    if (this.isSuccessful()) {\n      return this.getResult();\n    }\n\n    throw this.getError();\n  }\n\n  async forceRun() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    for (var _len2 = arguments.length, inputs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      inputs[_key2 - 1] = arguments[_key2];\n    }\n\n    const disposable = new Disposable(options.signal ?? new AbortController().signal);\n    disposable.onCancel(cancelError => {\n      this.setStatus('canceled');\n      this.error = cancelError;\n    });\n    return disposable.run(async scope => {\n      const {\n        isCanceled,\n        throwIfCanceled\n      } = scope;\n\n      try {\n        // Start loading.\n        this.setStatus('running');\n        this.result = undefined;\n        this.error = undefined;\n        this.result = await Promise.resolve(this.callback(scope, ...inputs));\n        throwIfCanceled();\n        this.setStatus('successful'); // Return the loaded result.\n\n        return this.result;\n      } catch (newError) {\n        // Capture the error and reset the result.\n        this.error = newError;\n        this.result = undefined;\n        this.setStatus(isCanceled() ? 'canceled' : 'failed'); // Re-throw the error.\n\n        throw this.error;\n      }\n    });\n  }\n\n  loadWith(preloadedResult) {\n    this.setStatus('successful');\n    this.result = preloadedResult;\n    this.error = undefined;\n    return this;\n  }\n\n  reset() {\n    this.setStatus('pending');\n    this.result = undefined;\n    this.error = undefined;\n    return this;\n  }\n\n  setChildren(children) {\n    this.children = children;\n    return this;\n  }\n\n  getChildren() {\n    return this.children;\n  }\n\n  getDescendants() {\n    return this.children.flatMap(child => [child, ...child.getDescendants()]);\n  }\n\n  setContext(context) {\n    this.context = context;\n    return this;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getStatus() {\n    return this.status;\n  }\n\n  getResult() {\n    return this.result;\n  }\n\n  getError() {\n    return this.error;\n  }\n\n  isPending() {\n    return this.status === 'pending';\n  }\n\n  isRunning() {\n    return this.status === 'running';\n  }\n\n  isCompleted() {\n    return this.status !== 'pending' && this.status !== 'running';\n  }\n\n  isSuccessful() {\n    return this.status === 'successful';\n  }\n\n  isFailed() {\n    return this.status === 'failed';\n  }\n\n  isCanceled() {\n    return this.status === 'canceled';\n  }\n\n  onStatusChange(callback) {\n    this.eventEmitter.on('statusChange', callback);\n    return this;\n  }\n\n  onStatusChangeTo(status, callback) {\n    return this.onStatusChange(newStatus => status === newStatus ? callback() : undefined);\n  }\n\n  onSuccess(callback) {\n    return this.onStatusChangeTo('successful', callback);\n  }\n\n  onFailure(callback) {\n    return this.onStatusChangeTo('failed', callback);\n  }\n\n  onCancel(callback) {\n    return this.onStatusChangeTo('canceled', callback);\n  }\n\n  setStatus(newStatus) {\n    if (this.status === newStatus) return;\n    this.status = newStatus;\n    this.eventEmitter.emit('statusChange', newStatus);\n  }\n\n}\n\nexport { Task };","map":{"version":3,"sources":["../../../src/utils/Task.ts"],"names":["Task","undefined","constructor","callback","children","context","eventEmitter","EventEmitterPackage","EventEmitter","run","options","inputs","isRunning","TaskIsAlreadyRunningError","isPending","force","forceRun","isSuccessful","getResult","getError","disposable","Disposable","signal","AbortController","onCancel","cancelError","setStatus","error","scope","isCanceled","throwIfCanceled","result","Promise","resolve","newError","loadWith","preloadedResult","reset","setChildren","getChildren","getDescendants","flatMap","child","setContext","getContext","getStatus","status","isCompleted","isFailed","onStatusChange","on","onStatusChangeTo","newStatus","onSuccess","onFailure","emit"],"mappings":";;;;;AAsBO,MAAMA,IAAN,CAAoC;EASzCE,WAAW,CACTC,QADS,EAIT;IAAA,IAFAC,QAEA,uEAF+B,EAE/B;IAAA,IADAC,OACA,uEADkB,EAClB;;IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EAT6B,SAS7B,CAAA;;IATsC,eAAA,CAAA,IAAA,EAAA,QAAA,EACNJ,SADM,CAAA;;IACG,eAAA,CAAA,IAAA,EAAA,OAAA,EAChBA,SADgB,CAAA;;IASzC,KAAKE,QAAL,GAAgBA,QAAhB;IACA,KAAKC,QAAL,GAAgBA,QAAhB;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKC,YAAL,GAAoB,IAAIC,mBAAmB,CAACC,YAAxB,EAApB;EACF;;EAES,MAAHC,GAAG,GAAsD;IAAA,IAArDC,OAAqD,uEAA9B,EAA8B;;IAC7D,IAAI,KAAKE,SAAL,EAAJ,EAAsB;MACpB,MAAM,IAAIC,yBAAJ,EAAN;IACF;;IAEA,IAAI,KAAKC,SAAL,OAAqBJ,OAAO,CAACK,KAARL,IAAiB,KAAtC,CAAJ,EAAkD;MAAA,kCALZC,MAKY;QALZA,MAKY;MAAA;;MAChD,OAAO,KAAKK,QAAL,CAAcN,OAAd,EAAuB,GAAGC,MAA1B,CAAP;IACF;;IAEA,IAAI,KAAKM,YAAL,EAAJ,EAAyB;MACvB,OAAO,KAAKC,SAAL,EAAP;IACF;;IAEA,MAAM,KAAKC,QAAL,EAAN;EACF;;EAEwB,MAARH,QAAQ,GAGV;IAAA,IAFZN,OAEY,uEAFW,EAEX;;IAAA,mCADTC,MACS;MADTA,MACS;IAAA;;IACZ,MAAMS,UAAU,GAAG,IAAIC,UAAJ,CACjBX,OAAO,CAACY,MAARZ,IAAkB,IAAIa,eAAJ,GAAsBD,MADvB,CAAnB;IAIAF,UAAU,CAACI,QAAXJ,CAAqBK,WAAW,IAAK;MACnC,KAAKC,SAAL,CAAe,UAAf;MACA,KAAKC,KAAL,GAAaF,WAAb;IACD,CAHDL;IAKA,OAAOA,UAAU,CAACX,GAAXW,CAAe,MAAOQ,KAAP,IAAkC;MACtD,MAAM;QAAEC,UAAF;QAAcC;MAAd,IAAkCF,KAAxC;;MAEA,IAAI;QACF;QACA,KAAKF,SAAL,CAAe,SAAf;QACA,KAAKK,MAAL,GAAc9B,SAAd;QACA,KAAK0B,KAAL,GAAa1B,SAAb;QACA,KAAK8B,MAAL,GAAc,MAAMC,OAAO,CAACC,OAARD,CAAgB,KAAK7B,QAAL,CAAcyB,KAAd,EAAqB,GAAGjB,MAAxB,CAAhBqB,CAApB;QACAF,eAAe;QACf,KAAKJ,SAAL,CAAe,YAAf,EAPE,CASF;;QACA,OAAO,KAAKK,MAAZ;MACD,CAXD,CAWE,OAAOG,QAAP,EAAiB;QACjB;QACA,KAAKP,KAAL,GAAaO,QAAb;QACA,KAAKH,MAAL,GAAc9B,SAAd;QACA,KAAKyB,SAAL,CAAeG,UAAU,KAAK,UAAL,GAAkB,QAA3C,EAJiB,CAMjB;;QACA,MAAM,KAAKF,KAAX;MACF;IACD,CAvBMP,CAAP;EAwBF;;EAEAe,QAAQ,CAACC,eAAD,EAAqB;IAC3B,KAAKV,SAAL,CAAe,YAAf;IACA,KAAKK,MAAL,GAAcK,eAAd;IACA,KAAKT,KAAL,GAAa1B,SAAb;IAEA,OAAO,IAAP;EACF;;EAEAoC,KAAK,GAAG;IACN,KAAKX,SAAL,CAAe,SAAf;IACA,KAAKK,MAAL,GAAc9B,SAAd;IACA,KAAK0B,KAAL,GAAa1B,SAAb;IAEA,OAAO,IAAP;EACF;;EAEAqC,WAAW,CAAClC,QAAD,EAA+B;IACxC,KAAKA,QAAL,GAAgBA,QAAhB;IAEA,OAAO,IAAP;EACF;;EAEAmC,WAAW,GAAuB;IAChC,OAAO,KAAKnC,QAAZ;EACF;;EAEAoC,cAAc,GAAuB;IACnC,OAAO,KAAKpC,QAAL,CAAcqC,OAAd,CAAuBC,KAAK,IAAK,CAACA,KAAD,EAAQ,GAAGA,KAAK,CAACF,cAANE,EAAX,CAAjC,CAAP;EACF;;EAEAC,UAAU,CAACtC,OAAD,EAAkB;IAC1B,KAAKA,OAAL,GAAeA,OAAf;IAEA,OAAO,IAAP;EACF;;EAEAuC,UAAU,GAAiC;IACzC,OAAO,KAAKvC,OAAZ;EACF;;EAEAwC,SAAS,GAAe;IACtB,OAAO,KAAKC,MAAZ;EACF;;EAEA5B,SAAS,GAAkB;IACzB,OAAO,KAAKa,MAAZ;EACF;;EAEAZ,QAAQ,GAAY;IAClB,OAAO,KAAKQ,KAAZ;EACF;;EAEAb,SAAS,GAAY;IACnB,OAAO,KAAKgC,MAAL,KAAgB,SAAvB;EACF;;EAEAlC,SAAS,GAAY;IACnB,OAAO,KAAKkC,MAAL,KAAgB,SAAvB;EACF;;EAEAC,WAAW,GAAY;IACrB,OAAO,KAAKD,MAAL,KAAgB,SAAhB,IAA6B,KAAKA,MAAL,KAAgB,SAApD;EACF;;EAEA7B,YAAY,GAAY;IACtB,OAAO,KAAK6B,MAAL,KAAgB,YAAvB;EACF;;EAEAE,QAAQ,GAAY;IAClB,OAAO,KAAKF,MAAL,KAAgB,QAAvB;EACF;;EAEAjB,UAAU,GAAY;IACpB,OAAO,KAAKiB,MAAL,KAAgB,UAAvB;EACF;;EAEAG,cAAc,CAAC9C,QAAD,EAA4C;IACxD,KAAKG,YAAL,CAAkB4C,EAAlB,CAAqB,cAArB,EAAqC/C,QAArC;IAEA,OAAO,IAAP;EACF;;EAEAgD,gBAAgB,CAACL,MAAD,EAAqB3C,QAArB,EAA8C;IAC5D,OAAO,KAAK8C,cAAL,CAAqBG,SAAS,IACnCN,MAAM,KAAKM,SAAXN,GAAuB3C,QAAQ,EAA/B2C,GAAoC7C,SAD/B,CAAP;EAGF;;EAEAoD,SAAS,CAAClD,QAAD,EAA0B;IACjC,OAAO,KAAKgD,gBAAL,CAAsB,YAAtB,EAAoChD,QAApC,CAAP;EACF;;EAEAmD,SAAS,CAACnD,QAAD,EAA0B;IACjC,OAAO,KAAKgD,gBAAL,CAAsB,QAAtB,EAAgChD,QAAhC,CAAP;EACF;;EAEAqB,QAAQ,CAACrB,QAAD,EAA0B;IAChC,OAAO,KAAKgD,gBAAL,CAAsB,UAAtB,EAAkChD,QAAlC,CAAP;EACF;;EAEUuB,SAAS,CAAC0B,SAAD,EAAwB;IACzC,IAAI,KAAKN,MAAL,KAAgBM,SAApB,EAA+B;IAC/B,KAAKN,MAAL,GAAcM,SAAd;IACA,KAAK9C,YAAL,CAAkBiD,IAAlB,CAAuB,cAAvB,EAAuCH,SAAvC;EACF;;AAnLyC","sourcesContent":["import EventEmitterPackage from 'eventemitter3';\nimport type EventEmitter from 'eventemitter3';\nimport { Disposable, DisposableScope } from './Disposable';\nimport { TaskIsAlreadyRunningError } from '@/errors';\n\nexport type TaskStatus =\n  | 'pending'\n  | 'running'\n  | 'successful'\n  | 'failed'\n  | 'canceled';\n\nexport type TaskCallback<T, I extends any[]> = (\n  scope: DisposableScope,\n  ...inputs: I\n) => T | Promise<T>;\n\nexport type TaskOptions = {\n  signal?: AbortSignal;\n  force?: boolean;\n};\n\nexport class Task<T, I extends any[] = []> {\n  protected callback: TaskCallback<T, I>;\n  protected children: Task<any, any[]>[];\n  protected context: object;\n  protected status: TaskStatus = 'pending';\n  protected result: T | undefined = undefined;\n  protected error: unknown = undefined;\n  protected eventEmitter: EventEmitter;\n\n  constructor(\n    callback: TaskCallback<T, I>,\n    children: Task<any, any[]>[] = [],\n    context: object = {}\n  ) {\n    this.callback = callback;\n    this.children = children;\n    this.context = context;\n    this.eventEmitter = new EventEmitterPackage.EventEmitter();\n  }\n\n  async run(options: TaskOptions = {}, ...inputs: I): Promise<T> {\n    if (this.isRunning()) {\n      throw new TaskIsAlreadyRunningError();\n    }\n\n    if (this.isPending() || (options.force ?? false)) {\n      return this.forceRun(options, ...inputs);\n    }\n\n    if (this.isSuccessful()) {\n      return this.getResult() as T;\n    }\n\n    throw this.getError();\n  }\n\n  protected async forceRun(\n    options: TaskOptions = {},\n    ...inputs: I\n  ): Promise<T> {\n    const disposable = new Disposable(\n      options.signal ?? new AbortController().signal\n    );\n\n    disposable.onCancel((cancelError) => {\n      this.setStatus('canceled');\n      this.error = cancelError;\n    });\n\n    return disposable.run(async (scope: DisposableScope) => {\n      const { isCanceled, throwIfCanceled } = scope;\n\n      try {\n        // Start loading.\n        this.setStatus('running');\n        this.result = undefined;\n        this.error = undefined;\n        this.result = await Promise.resolve(this.callback(scope, ...inputs));\n        throwIfCanceled();\n        this.setStatus('successful');\n\n        // Return the loaded result.\n        return this.result;\n      } catch (newError) {\n        // Capture the error and reset the result.\n        this.error = newError;\n        this.result = undefined;\n        this.setStatus(isCanceled() ? 'canceled' : 'failed');\n\n        // Re-throw the error.\n        throw this.error;\n      }\n    });\n  }\n\n  loadWith(preloadedResult: T) {\n    this.setStatus('successful');\n    this.result = preloadedResult;\n    this.error = undefined;\n\n    return this;\n  }\n\n  reset() {\n    this.setStatus('pending');\n    this.result = undefined;\n    this.error = undefined;\n\n    return this;\n  }\n\n  setChildren(children: Task<any, any[]>[]) {\n    this.children = children;\n\n    return this;\n  }\n\n  getChildren(): Task<any, any[]>[] {\n    return this.children;\n  }\n\n  getDescendants(): Task<any, any[]>[] {\n    return this.children.flatMap((child) => [child, ...child.getDescendants()]);\n  }\n\n  setContext(context: object) {\n    this.context = context;\n\n    return this;\n  }\n\n  getContext<C extends object = object>(): C {\n    return this.context as C;\n  }\n\n  getStatus(): TaskStatus {\n    return this.status;\n  }\n\n  getResult(): T | undefined {\n    return this.result;\n  }\n\n  getError(): unknown {\n    return this.error;\n  }\n\n  isPending(): boolean {\n    return this.status === 'pending';\n  }\n\n  isRunning(): boolean {\n    return this.status === 'running';\n  }\n\n  isCompleted(): boolean {\n    return this.status !== 'pending' && this.status !== 'running';\n  }\n\n  isSuccessful(): boolean {\n    return this.status === 'successful';\n  }\n\n  isFailed(): boolean {\n    return this.status === 'failed';\n  }\n\n  isCanceled(): boolean {\n    return this.status === 'canceled';\n  }\n\n  onStatusChange(callback: (status: TaskStatus) => unknown) {\n    this.eventEmitter.on('statusChange', callback);\n\n    return this;\n  }\n\n  onStatusChangeTo(status: TaskStatus, callback: () => unknown) {\n    return this.onStatusChange((newStatus) =>\n      status === newStatus ? callback() : undefined\n    );\n  }\n\n  onSuccess(callback: () => unknown) {\n    return this.onStatusChangeTo('successful', callback);\n  }\n\n  onFailure(callback: () => unknown) {\n    return this.onStatusChangeTo('failed', callback);\n  }\n\n  onCancel(callback: () => unknown) {\n    return this.onStatusChangeTo('canceled', callback);\n  }\n\n  protected setStatus(newStatus: TaskStatus) {\n    if (this.status === newStatus) return;\n    this.status = newStatus;\n    this.eventEmitter.emit('statusChange', newStatus);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}