{"ast":null,"code":"import { LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { toBigNumber } from './BigNumber.mjs';\nimport { UnexpectedCurrencyError, CurrencyMismatchError } from '../errors/SdkError.mjs';\n/** @group Constants */\n\nconst SOL = {\n  symbol: 'SOL',\n  decimals: 9\n};\n/** @group Constants */\n\nconst USD = {\n  symbol: 'USD',\n  decimals: 2\n};\n\nconst amount = (basisPoints, currency) => {\n  return {\n    basisPoints: toBigNumber(basisPoints),\n    currency\n  };\n};\n\nconst lamports = lamports => {\n  return amount(lamports, SOL);\n};\n\nconst sol = sol => {\n  return lamports(sol * LAMPORTS_PER_SOL);\n};\n\nconst usd = usd => {\n  return amount(usd * 100, USD);\n};\n\nconst token = function (amount) {\n  let decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let symbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Token';\n\n  if (typeof amount !== 'number') {\n    amount = toBigNumber(amount).toNumber();\n  }\n\n  return {\n    basisPoints: toBigNumber(amount * Math.pow(10, decimals)),\n    currency: {\n      symbol,\n      decimals,\n      namespace: 'spl-token'\n    }\n  };\n};\n\nconst isSol = currencyOrAmount => {\n  return sameCurrencies(currencyOrAmount, SOL);\n};\n\nconst sameAmounts = (left, right) => {\n  return sameCurrencies(left, right) && left.basisPoints.eq(right.basisPoints);\n};\n\nconst sameCurrencies = (left, right) => {\n  if ('currency' in left) {\n    left = left.currency;\n  }\n\n  if ('currency' in right) {\n    right = right.currency;\n  }\n\n  return left.symbol === right.symbol && left.decimals === right.decimals && left.namespace === right.namespace;\n};\n\nfunction assertCurrency(actual, expected) {\n  if ('currency' in actual) {\n    actual = actual.currency;\n  }\n\n  if (!sameCurrencies(actual, expected)) {\n    throw new UnexpectedCurrencyError(actual, expected);\n  }\n}\n\nfunction assertSol(actual) {\n  assertCurrency(actual, SOL);\n}\n\nfunction assertSameCurrencies(left, right, operation) {\n  if ('currency' in left) {\n    left = left.currency;\n  }\n\n  if ('currency' in right) {\n    right = right.currency;\n  }\n\n  if (!sameCurrencies(left, right)) {\n    throw new CurrencyMismatchError(left, right, operation);\n  }\n}\n\nconst addAmounts = (left, right) => {\n  assertSameCurrencies(left, right, 'add');\n  return amount(left.basisPoints.add(right.basisPoints), left.currency);\n};\n\nconst subtractAmounts = (left, right) => {\n  assertSameCurrencies(left, right, 'subtract');\n  return amount(left.basisPoints.sub(right.basisPoints), left.currency);\n};\n\nconst multiplyAmount = (left, multiplier) => {\n  return amount(left.basisPoints.muln(multiplier), left.currency);\n};\n\nconst divideAmount = (left, divisor) => {\n  return amount(left.basisPoints.divn(divisor), left.currency);\n};\n\nconst absoluteAmount = value => {\n  return amount(value.basisPoints.abs(), value.currency);\n};\n\nconst compareAmounts = (left, right) => {\n  assertSameCurrencies(left, right, 'compare');\n  return left.basisPoints.cmp(right.basisPoints);\n};\n\nconst isEqualToAmount = (left, right, tolerance) => {\n  tolerance = tolerance ?? amount(0, left.currency);\n  assertSameCurrencies(left, right, 'isEqualToAmount');\n  assertSameCurrencies(left, tolerance, 'isEqualToAmount');\n  const delta = absoluteAmount(subtractAmounts(left, right));\n  return isLessThanOrEqualToAmount(delta, tolerance);\n};\n\nconst isLessThanAmount = (left, right) => compareAmounts(left, right) < 0;\n\nconst isLessThanOrEqualToAmount = (left, right) => compareAmounts(left, right) <= 0;\n\nconst isGreaterThanAmount = (left, right) => compareAmounts(left, right) > 0;\n\nconst isGreaterThanOrEqualToAmount = (left, right) => compareAmounts(left, right) >= 0;\n\nconst isZeroAmount = value => compareAmounts(value, amount(0, value.currency)) === 0;\n\nconst isPositiveAmount = value => compareAmounts(value, amount(0, value.currency)) >= 0;\n\nconst isNegativeAmount = value => compareAmounts(value, amount(0, value.currency)) < 0;\n\nconst formatAmount = value => {\n  if (value.currency.decimals === 0) {\n    return `${value.currency.symbol} ${value.basisPoints.toString()}`;\n  }\n\n  const power = new BN(10).pow(new BN(value.currency.decimals));\n  const basisPoints = value.basisPoints;\n  const {\n    div,\n    mod\n  } = basisPoints.divmod(power);\n  const units = `${div.toString()}.${mod.abs().toString(10, value.currency.decimals)}`;\n  return `${value.currency.symbol} ${units}`;\n};\n\nexport { SOL, USD, absoluteAmount, addAmounts, amount, assertCurrency, assertSameCurrencies, assertSol, compareAmounts, divideAmount, formatAmount, isEqualToAmount, isGreaterThanAmount, isGreaterThanOrEqualToAmount, isLessThanAmount, isLessThanOrEqualToAmount, isNegativeAmount, isPositiveAmount, isSol, isZeroAmount, lamports, multiplyAmount, sameAmounts, sameCurrencies, sol, subtractAmounts, token, usd };","map":{"version":3,"sources":["../../../src/types/Amount.ts"],"names":["SOL","symbol","decimals","USD","amount","basisPoints","currency","toBigNumber","lamports","sol","LAMPORTS_PER_SOL","usd","token","toNumber","Math","pow","namespace","isSol","currencyOrAmount","sameCurrencies","sameAmounts","left","right","eq","assertCurrency","actual","expected","UnexpectedCurrencyError","assertSol","assertSameCurrencies","operation","CurrencyMismatchError","addAmounts","add","subtractAmounts","sub","multiplyAmount","multiplier","muln","divideAmount","divisor","divn","absoluteAmount","value","abs","compareAmounts","cmp","isEqualToAmount","tolerance","delta","isLessThanOrEqualToAmount","isLessThanAmount","isGreaterThanAmount","isGreaterThanOrEqualToAmount","isZeroAmount","isPositiveAmount","isNegativeAmount","formatAmount","toString","power","BN","div","mod","divmod","units"],"mappings":"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","sourcesContent":["import { LAMPORTS_PER_SOL } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { BigNumber, BigNumberValues, toBigNumber } from './BigNumber';\nimport { CurrencyMismatchError, UnexpectedCurrencyError } from '@/errors';\n\nexport type Amount<T extends Currency = Currency> = {\n  basisPoints: BigNumber;\n  currency: T;\n};\n\nexport type Currency = {\n  symbol: string;\n  decimals: number;\n  namespace?: 'spl-token';\n};\n\nexport type SplTokenCurrency = {\n  symbol: string;\n  decimals: number;\n  namespace: 'spl-token';\n};\nexport type SplTokenAmount = Amount<SplTokenCurrency>;\n\n/** @group Constants */\nexport const SOL = {\n  symbol: 'SOL',\n  decimals: 9,\n} as const;\nexport type SolCurrency = typeof SOL;\nexport type SolAmount = Amount<SolCurrency>;\n\n/** @group Constants */\nexport const USD = {\n  symbol: 'USD',\n  decimals: 2,\n} as const;\nexport type UsdCurrency = typeof USD;\nexport type UsdAmount = Amount<UsdCurrency>;\n\nexport const amount = <T extends Currency = Currency>(\n  basisPoints: BigNumberValues,\n  currency: T\n): Amount<T> => {\n  return {\n    basisPoints: toBigNumber(basisPoints),\n    currency,\n  };\n};\n\nexport const lamports = (lamports: BigNumberValues): SolAmount => {\n  return amount(lamports, SOL);\n};\n\nexport const sol = (sol: number): SolAmount => {\n  return lamports(sol * LAMPORTS_PER_SOL);\n};\n\nexport const usd = (usd: number): UsdAmount => {\n  return amount(usd * 100, USD);\n};\n\nexport const token = (\n  amount: BigNumberValues,\n  decimals = 0,\n  symbol = 'Token'\n): SplTokenAmount => {\n  if (typeof amount !== 'number') {\n    amount = toBigNumber(amount).toNumber();\n  }\n\n  return {\n    basisPoints: toBigNumber(amount * Math.pow(10, decimals)),\n    currency: {\n      symbol,\n      decimals,\n      namespace: 'spl-token',\n    },\n  };\n};\n\nexport const isSol = (currencyOrAmount: Currency | Amount): boolean => {\n  return sameCurrencies(currencyOrAmount, SOL);\n};\n\nexport const sameAmounts = (left: Amount, right: Amount): boolean => {\n  return sameCurrencies(left, right) && left.basisPoints.eq(right.basisPoints);\n};\n\nexport const sameCurrencies = (\n  left: Currency | Amount,\n  right: Currency | Amount\n): boolean => {\n  if ('currency' in left) {\n    left = left.currency;\n  }\n\n  if ('currency' in right) {\n    right = right.currency;\n  }\n\n  return (\n    left.symbol === right.symbol &&\n    left.decimals === right.decimals &&\n    left.namespace === right.namespace\n  );\n};\n\nexport function assertCurrency<T extends Currency>(\n  actual: Currency,\n  expected: T\n): asserts actual is T;\nexport function assertCurrency<T extends Currency>(\n  actual: Amount,\n  expected: T\n): asserts actual is Amount<T>;\nexport function assertCurrency<T extends Currency>(\n  actual: Currency | Amount,\n  expected: T\n): asserts actual is T | Amount<T>;\nexport function assertCurrency<T extends Currency>(\n  actual: Currency | Amount,\n  expected: T\n): asserts actual is T | Amount<T> {\n  if ('currency' in actual) {\n    actual = actual.currency;\n  }\n\n  if (!sameCurrencies(actual, expected)) {\n    throw new UnexpectedCurrencyError(actual, expected);\n  }\n}\nexport function assertSol(actual: Amount): asserts actual is SolAmount;\nexport function assertSol(actual: Currency): asserts actual is SolCurrency;\nexport function assertSol(\n  actual: Currency | Amount\n): asserts actual is SolCurrency | SolAmount;\nexport function assertSol(\n  actual: Currency | Amount\n): asserts actual is SolCurrency | SolAmount {\n  assertCurrency(actual, SOL);\n}\n\nexport function assertSameCurrencies<L extends Currency, R extends Currency>(\n  left: L | Amount<L>,\n  right: R | Amount<R>,\n  operation?: string\n) {\n  if ('currency' in left) {\n    left = left.currency;\n  }\n\n  if ('currency' in right) {\n    right = right.currency;\n  }\n\n  if (!sameCurrencies(left, right)) {\n    throw new CurrencyMismatchError(left, right, operation);\n  }\n}\n\nexport const addAmounts = <T extends Currency>(\n  left: Amount<T>,\n  right: Amount<T>\n): Amount<T> => {\n  assertSameCurrencies(left, right, 'add');\n\n  return amount(left.basisPoints.add(right.basisPoints), left.currency);\n};\n\nexport const subtractAmounts = <T extends Currency>(\n  left: Amount<T>,\n  right: Amount<T>\n): Amount<T> => {\n  assertSameCurrencies(left, right, 'subtract');\n\n  return amount(left.basisPoints.sub(right.basisPoints), left.currency);\n};\n\nexport const multiplyAmount = <T extends Currency>(\n  left: Amount<T>,\n  multiplier: number\n): Amount<T> => {\n  return amount(left.basisPoints.muln(multiplier), left.currency);\n};\n\nexport const divideAmount = <T extends Currency>(\n  left: Amount<T>,\n  divisor: number\n): Amount<T> => {\n  return amount(left.basisPoints.divn(divisor), left.currency);\n};\n\nexport const absoluteAmount = <T extends Currency>(\n  value: Amount<T>\n): Amount<T> => {\n  return amount(value.basisPoints.abs(), value.currency);\n};\n\nexport const compareAmounts = <T extends Currency>(\n  left: Amount<T>,\n  right: Amount<T>\n): -1 | 0 | 1 => {\n  assertSameCurrencies(left, right, 'compare');\n\n  return left.basisPoints.cmp(right.basisPoints);\n};\n\nexport const isEqualToAmount = <T extends Currency>(\n  left: Amount<T>,\n  right: Amount<T>,\n  tolerance?: Amount<T>\n): boolean => {\n  tolerance = tolerance ?? amount(0, left.currency);\n  assertSameCurrencies(left, right, 'isEqualToAmount');\n  assertSameCurrencies(left, tolerance, 'isEqualToAmount');\n\n  const delta = absoluteAmount(subtractAmounts(left, right));\n\n  return isLessThanOrEqualToAmount(delta, tolerance);\n};\n\nexport const isLessThanAmount = <T extends Currency>(\n  left: Amount<T>,\n  right: Amount<T>\n): boolean => compareAmounts(left, right) < 0;\n\nexport const isLessThanOrEqualToAmount = <T extends Currency>(\n  left: Amount<T>,\n  right: Amount<T>\n): boolean => compareAmounts(left, right) <= 0;\n\nexport const isGreaterThanAmount = <T extends Currency>(\n  left: Amount<T>,\n  right: Amount<T>\n): boolean => compareAmounts(left, right) > 0;\n\nexport const isGreaterThanOrEqualToAmount = <T extends Currency>(\n  left: Amount<T>,\n  right: Amount<T>\n): boolean => compareAmounts(left, right) >= 0;\n\nexport const isZeroAmount = (value: Amount): boolean =>\n  compareAmounts(value, amount(0, value.currency)) === 0;\n\nexport const isPositiveAmount = (value: Amount): boolean =>\n  compareAmounts(value, amount(0, value.currency)) >= 0;\n\nexport const isNegativeAmount = (value: Amount): boolean =>\n  compareAmounts(value, amount(0, value.currency)) < 0;\n\nexport const formatAmount = (value: Amount): string => {\n  if (value.currency.decimals === 0) {\n    return `${value.currency.symbol} ${value.basisPoints.toString()}`;\n  }\n\n  const power = new BN(10).pow(new BN(value.currency.decimals));\n  const basisPoints = value.basisPoints as unknown as BN & {\n    divmod: (other: BN) => { div: BN; mod: BN };\n  };\n\n  const { div, mod } = basisPoints.divmod(power);\n  const units = `${div.toString()}.${mod\n    .abs()\n    .toString(10, value.currency.decimals)}`;\n\n  return `${value.currency.symbol} ${units}`;\n};\n"]},"metadata":{},"sourceType":"module"}