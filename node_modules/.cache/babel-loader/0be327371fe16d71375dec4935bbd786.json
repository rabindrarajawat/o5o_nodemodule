{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compositesTypeMap = exports.coption = exports.coptionSome = exports.coptionNone = exports.isNoneBuffer = exports.isSomeBuffer = void 0;\n\nconst assert_1 = require(\"assert\");\n\nconst types_1 = require(\"../types\");\n\nconst types_2 = require(\"../types\");\n\nconst utils_1 = require(\"../utils\");\n\nconst beet_fixable_1 = require(\"../beet.fixable\");\n\nconst NONE = 0;\nconst SOME = 1;\n/**\n * @private\n */\n\nfunction isSomeBuffer(buf, offset) {\n  return buf[offset] === SOME;\n}\n\nexports.isSomeBuffer = isSomeBuffer;\n/**\n * @private\n */\n\nfunction isNoneBuffer(buf, offset) {\n  return buf[offset] === NONE;\n}\n\nexports.isNoneBuffer = isNoneBuffer;\n/**\n * De/Serializes `None` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `0`.\n * This matches the `COption::None` type borsh representation.\n *\n * @template T inner option type\n * @param description the description of the inner type\n *\n * @category beet/option\n */\n\nfunction coptionNone(description) {\n  (0, utils_1.logTrace)(`coptionNone(${description})`);\n  return {\n    write: function (buf, offset, value) {\n      (0, assert_1.strict)(value == null, 'coptionNone can only handle `null` values');\n      buf[offset] = NONE;\n    },\n    read: function (buf, offset) {\n      (0, assert_1.strict)(isNoneBuffer(buf, offset), 'coptionNone can only handle `NONE` data');\n      return null;\n    },\n    byteSize: 1,\n    description: `COption<None(${description})>`\n  };\n}\n\nexports.coptionNone = coptionNone;\n/**\n * De/Serializes `Some` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `1`.\n * This matches the `COption::Some` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\n\nfunction coptionSome(inner) {\n  const byteSize = 1 + inner.byteSize;\n  const beet = {\n    write: function (buf, offset, value) {\n      (0, types_1.assertFixedSizeBeet)(inner, `coption inner type ${inner.description} needs to be fixed before calling write`);\n      (0, assert_1.strict)(value != null, 'coptionSome cannot handle `null` values');\n      buf[offset] = SOME;\n      inner.write(buf, offset + 1, value);\n    },\n    read: function (buf, offset) {\n      (0, types_1.assertFixedSizeBeet)(inner, `coption inner type ${inner.description} needs to be fixed before calling read`);\n      (0, assert_1.strict)(isSomeBuffer(buf, offset), 'coptionSome can only handle `SOME` data');\n      return inner.read(buf, offset + 1);\n    },\n    description: `COption<${inner.description}>[1 + ${inner.byteSize}]`,\n    byteSize,\n    inner\n  };\n  (0, utils_1.logTrace)(beet.description);\n  return beet;\n}\n\nexports.coptionSome = coptionSome;\n/**\n * De/Serializes an _Option_ of type {@link T} represented by {@link COption}.\n *\n * The de/serialized type is prefixed with `1` if the inner value is present\n * and with `0` if not.\n * This matches the `COption` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\n\nfunction coption(inner) {\n  return {\n    toFixedFromData(buf, offset) {\n      if (isSomeBuffer(buf, offset)) {\n        const innerFixed = (0, beet_fixable_1.fixBeetFromData)(inner, buf, offset + 1);\n        return coptionSome(innerFixed);\n      } else {\n        (0, assert_1.strict)(isNoneBuffer(buf, offset), `Expected ${buf} to hold a COption`);\n        return coptionNone(inner.description);\n      }\n    },\n\n    toFixedFromValue(val) {\n      return val == null ? coptionNone(inner.description) : coptionSome((0, beet_fixable_1.fixBeetFromValue)(inner, val));\n    },\n\n    description: `COption<${inner.description}>`\n  };\n}\n\nexports.coption = coption;\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexports.compositesTypeMap = {\n  option: {\n    beet: 'coption',\n    isFixable: true,\n    sourcePack: types_2.BEET_PACKAGE,\n    ts: 'COption<Inner>',\n    arg: types_1.BEET_TYPE_ARG_INNER,\n    pack: types_2.BEET_PACKAGE\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/composites.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compositesTypeMap = exports.coption = exports.coptionSome = exports.coptionNone = exports.isNoneBuffer = exports.isSomeBuffer = void 0;\nconst assert_1 = require(\"assert\");\nconst types_1 = require(\"../types\");\nconst types_2 = require(\"../types\");\nconst utils_1 = require(\"../utils\");\nconst beet_fixable_1 = require(\"../beet.fixable\");\nconst NONE = 0;\nconst SOME = 1;\n/**\n * @private\n */\nfunction isSomeBuffer(buf, offset) {\n    return buf[offset] === SOME;\n}\nexports.isSomeBuffer = isSomeBuffer;\n/**\n * @private\n */\nfunction isNoneBuffer(buf, offset) {\n    return buf[offset] === NONE;\n}\nexports.isNoneBuffer = isNoneBuffer;\n/**\n * De/Serializes `None` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `0`.\n * This matches the `COption::None` type borsh representation.\n *\n * @template T inner option type\n * @param description the description of the inner type\n *\n * @category beet/option\n */\nfunction coptionNone(description) {\n    (0, utils_1.logTrace)(`coptionNone(${description})`);\n    return {\n        write: function (buf, offset, value) {\n            (0, assert_1.strict)(value == null, 'coptionNone can only handle `null` values');\n            buf[offset] = NONE;\n        },\n        read: function (buf, offset) {\n            (0, assert_1.strict)(isNoneBuffer(buf, offset), 'coptionNone can only handle `NONE` data');\n            return null;\n        },\n        byteSize: 1,\n        description: `COption<None(${description})>`,\n    };\n}\nexports.coptionNone = coptionNone;\n/**\n * De/Serializes `Some` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `1`.\n * This matches the `COption::Some` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\nfunction coptionSome(inner) {\n    const byteSize = 1 + inner.byteSize;\n    const beet = {\n        write: function (buf, offset, value) {\n            (0, types_1.assertFixedSizeBeet)(inner, `coption inner type ${inner.description} needs to be fixed before calling write`);\n            (0, assert_1.strict)(value != null, 'coptionSome cannot handle `null` values');\n            buf[offset] = SOME;\n            inner.write(buf, offset + 1, value);\n        },\n        read: function (buf, offset) {\n            (0, types_1.assertFixedSizeBeet)(inner, `coption inner type ${inner.description} needs to be fixed before calling read`);\n            (0, assert_1.strict)(isSomeBuffer(buf, offset), 'coptionSome can only handle `SOME` data');\n            return inner.read(buf, offset + 1);\n        },\n        description: `COption<${inner.description}>[1 + ${inner.byteSize}]`,\n        byteSize,\n        inner,\n    };\n    (0, utils_1.logTrace)(beet.description);\n    return beet;\n}\nexports.coptionSome = coptionSome;\n/**\n * De/Serializes an _Option_ of type {@link T} represented by {@link COption}.\n *\n * The de/serialized type is prefixed with `1` if the inner value is present\n * and with `0` if not.\n * This matches the `COption` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\nfunction coption(inner) {\n    return {\n        toFixedFromData(buf, offset) {\n            if (isSomeBuffer(buf, offset)) {\n                const innerFixed = (0, beet_fixable_1.fixBeetFromData)(inner, buf, offset + 1);\n                return coptionSome(innerFixed);\n            }\n            else {\n                (0, assert_1.strict)(isNoneBuffer(buf, offset), `Expected ${buf} to hold a COption`);\n                return coptionNone(inner.description);\n            }\n        },\n        toFixedFromValue(val) {\n            return val == null\n                ? coptionNone(inner.description)\n                : coptionSome((0, beet_fixable_1.fixBeetFromValue)(inner, val));\n        },\n        description: `COption<${inner.description}>`,\n    };\n}\nexports.coption = coption;\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.compositesTypeMap = {\n    option: {\n        beet: 'coption',\n        isFixable: true,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: 'COption<Inner>',\n        arg: types_1.BEET_TYPE_ARG_INNER,\n        pack: types_2.BEET_PACKAGE,\n    },\n};\n//# sourceMappingURL=composites.js.map"]},"metadata":{},"sourceType":"script"}