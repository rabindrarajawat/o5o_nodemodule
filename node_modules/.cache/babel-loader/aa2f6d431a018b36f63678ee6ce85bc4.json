{"ast":null,"code":"import { createSellInstruction, createAuctioneerSellInstruction, createPrintListingReceiptInstruction } from '@metaplex-foundation/mpl-auction-house';\nimport { SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { AUCTIONEER_PRICE } from '../constants.mjs';\nimport { AuctioneerAuthorityRequiredError, CreateListingRequiresSignerError } from '../errors.mjs';\nimport { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { now } from '../../../types/DateTime.mjs';\nimport { token, lamports, amount } from '../../../types/Amount.mjs';\nimport { isSigner } from '../../../types/Signer.mjs';\nimport { toPublicKey } from '../../../types/PublicKey.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateListingOperation';\n/**\n * Creates a listing on a given asset.\n *\n * ```ts\n * await metaplex\n *   .auctionHouse()\n *   .createListing({ auctionHouse, mintAccount };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst createListingOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst createListingOperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const {\n      auctionHouse\n    } = operation.input;\n    const builder = createListingBuilder(metaplex, operation.input, scope);\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    if (output.receipt) {\n      const listing = await metaplex.auctionHouse().findListingByReceipt({\n        receiptAddress: output.receipt,\n        auctionHouse\n      }, scope);\n      return {\n        listing,\n        ...output\n      };\n    }\n\n    scope.throwIfCanceled();\n    const lazyListing = {\n      model: 'listing',\n      lazy: true,\n      auctionHouse,\n      tradeStateAddress: output.sellerTradeState,\n      bookkeeperAddress: output.bookkeeper,\n      sellerAddress: output.seller,\n      metadataAddress: output.metadata,\n      receiptAddress: output.receipt,\n      purchaseReceiptAddress: null,\n      price: output.price,\n      tokens: output.tokens.basisPoints,\n      createdAt: now(),\n      canceledAt: null\n    };\n    return {\n      listing: await metaplex.auctionHouse().loadListing({\n        lazyListing\n      }, scope),\n      ...output\n    };\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * Creates a listing on a given asset.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .auctionHouse()\n *   .builders()\n *   .createListing({ auctionHouse, mintAccount });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\n/**\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst createListingBuilder = function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    auctionHouse,\n    auctioneerAuthority,\n    mintAccount,\n    tokens = token(1),\n    seller = metaplex.identity(),\n    authority = auctionHouse.authorityAddress\n  } = params; // Data.\n\n  const priceBasisPoint = auctioneerAuthority ? AUCTIONEER_PRICE : params.price?.basisPoints ?? 0;\n  const price = auctionHouse.isNative ? lamports(priceBasisPoint) : amount(priceBasisPoint, auctionHouse.treasuryMint.currency);\n\n  if (auctionHouse.hasAuctioneer && !auctioneerAuthority) {\n    throw new AuctioneerAuthorityRequiredError();\n  }\n\n  if (!isSigner(seller) && !isSigner(authority)) {\n    throw new CreateListingRequiresSignerError();\n  } // Accounts.\n\n\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAccount,\n    programs\n  });\n  const tokenAccount = params.tokenAccount ?? metaplex.tokens().pdas().associatedTokenAccount({\n    mint: mintAccount,\n    owner: toPublicKey(seller),\n    programs\n  });\n  const sellerTradeState = metaplex.auctionHouse().pdas().tradeState({\n    auctionHouse: auctionHouse.address,\n    wallet: toPublicKey(seller),\n    treasuryMint: auctionHouse.treasuryMint.address,\n    tokenMint: mintAccount,\n    price: price.basisPoints,\n    tokenSize: tokens.basisPoints,\n    tokenAccount,\n    programs\n  });\n  const freeSellerTradeState = metaplex.auctionHouse().pdas().tradeState({\n    auctionHouse: auctionHouse.address,\n    wallet: toPublicKey(seller),\n    treasuryMint: auctionHouse.treasuryMint.address,\n    tokenMint: mintAccount,\n    price: lamports(0).basisPoints,\n    tokenSize: tokens.basisPoints,\n    tokenAccount,\n    programs\n  });\n  const programAsSigner = metaplex.auctionHouse().pdas().programAsSigner({\n    programs\n  });\n  const accounts = {\n    wallet: toPublicKey(seller),\n    tokenAccount,\n    metadata,\n    authority: toPublicKey(authority),\n    auctionHouse: auctionHouse.address,\n    auctionHouseFeeAccount: auctionHouse.feeAccountAddress,\n    sellerTradeState,\n    freeSellerTradeState,\n    programAsSigner\n  }; // Args.\n\n  const args = {\n    tradeStateBump: sellerTradeState.bump,\n    freeTradeStateBump: freeSellerTradeState.bump,\n    programAsSignerBump: programAsSigner.bump,\n    buyerPrice: price.basisPoints,\n    tokenSize: tokens.basisPoints\n  }; // Sell Instruction.\n\n  let sellInstruction = createSellInstruction(accounts, args);\n\n  if (auctioneerAuthority) {\n    sellInstruction = createAuctioneerSellInstruction({ ...accounts,\n      auctioneerAuthority: auctioneerAuthority.publicKey,\n      ahAuctioneerPda: metaplex.auctionHouse().pdas().auctioneer({\n        auctionHouse: auctionHouse.address,\n        auctioneerAuthority: auctioneerAuthority.publicKey,\n        programs\n      })\n    }, args);\n  } // Signers.\n\n\n  const signer = isSigner(seller) ? seller : authority;\n  const sellSigners = [signer, auctioneerAuthority].filter(isSigner); // Update the account to be a signer since it's not covered properly by MPL due to its dynamic nature.\n\n  const signerKeyIndex = sellInstruction.keys.findIndex(key => key.pubkey.equals(signer.publicKey));\n  sellInstruction.keys[signerKeyIndex].isSigner = true; // Fixes cross-program invocation with unauthorized writable account\n\n  if (sellInstruction.keys[signerKeyIndex].pubkey.equals(toPublicKey(seller))) {\n    sellInstruction.keys[signerKeyIndex].isWritable = true;\n  } // Receipt.\n  // Since createPrintListingReceiptInstruction can't deserialize createAuctioneerSellInstruction due to a bug\n  // Don't print Auctioneer Sell receipt for the time being.\n\n\n  const shouldPrintReceipt = (params.printReceipt ?? true) && !auctioneerAuthority;\n  const bookkeeper = params.bookkeeper ?? metaplex.identity();\n  const receipt = metaplex.auctionHouse().pdas().listingReceipt({\n    tradeState: sellerTradeState,\n    programs\n  });\n  return TransactionBuilder.make().setFeePayer(payer).setContext({\n    sellerTradeState,\n    freeSellerTradeState,\n    tokenAccount,\n    metadata,\n    seller: toPublicKey(seller),\n    receipt: shouldPrintReceipt ? receipt : null,\n    bookkeeper: shouldPrintReceipt ? bookkeeper.publicKey : null,\n    price,\n    tokens\n  }) // Create Listing.\n  .add({\n    instruction: sellInstruction,\n    signers: sellSigners,\n    key: 'sell'\n  }) // Print the Listing Receipt.\n  .when(shouldPrintReceipt, builder => builder.add({\n    instruction: createPrintListingReceiptInstruction({\n      receipt,\n      bookkeeper: bookkeeper.publicKey,\n      instruction: SYSVAR_INSTRUCTIONS_PUBKEY\n    }, {\n      receiptBump: receipt.bump\n    }),\n    signers: [bookkeeper],\n    key: 'printListingReceipt'\n  }));\n};\n\nexport { createListingBuilder, createListingOperation, createListingOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/auctionHouseModule/operations/createListing.ts"],"names":["Key","createListingOperation","useOperation","createListingOperationHandler","handle","operation","metaplex","scope","auctionHouse","input","builder","createListingBuilder","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","throwIfCanceled","receipt","listing","findListingByReceipt","receiptAddress","lazyListing","model","lazy","tradeStateAddress","sellerTradeState","bookkeeperAddress","bookkeeper","sellerAddress","seller","metadataAddress","metadata","purchaseReceiptAddress","price","tokens","basisPoints","createdAt","now","canceledAt","loadListing","params","options","programs","payer","rpc","getDefaultFeePayer","auctioneerAuthority","mintAccount","token","identity","authority","authorityAddress","priceBasisPoint","AUCTIONEER_PRICE","isNative","lamports","amount","treasuryMint","currency","hasAuctioneer","AuctioneerAuthorityRequiredError","isSigner","CreateListingRequiresSignerError","nfts","pdas","mint","tokenAccount","associatedTokenAccount","owner","toPublicKey","tradeState","address","wallet","tokenMint","tokenSize","freeSellerTradeState","programAsSigner","accounts","auctionHouseFeeAccount","feeAccountAddress","args","tradeStateBump","bump","freeTradeStateBump","programAsSignerBump","buyerPrice","sellInstruction","createSellInstruction","createAuctioneerSellInstruction","publicKey","ahAuctioneerPda","auctioneer","signer","sellSigners","filter","signerKeyIndex","keys","findIndex","key","pubkey","equals","isWritable","shouldPrintReceipt","printReceipt","listingReceipt","TransactionBuilder","make","setFeePayer","setContext","add","instruction","signers","when","createPrintListingReceiptInstruction","SYSVAR_INSTRUCTIONS_PUBKEY","receiptBump"],"mappings":"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","sourcesContent":["import {\n  createAuctioneerSellInstruction,\n  createPrintListingReceiptInstruction,\n  createSellInstruction,\n} from '@metaplex-foundation/mpl-auction-house';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport type { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { AUCTIONEER_PRICE } from '../constants';\nimport {\n  AuctioneerAuthorityRequiredError,\n  CreateListingRequiresSignerError,\n} from '../errors';\nimport { AuctionHouse, LazyListing, Listing } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  amount,\n  isSigner,\n  lamports,\n  makeConfirmOptionsFinalizedOnMainnet,\n  now,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Pda,\n  Signer,\n  SolAmount,\n  SplTokenAmount,\n  token,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateListingOperation' as const;\n\n/**\n * Creates a listing on a given asset.\n *\n * ```ts\n * await metaplex\n *   .auctionHouse()\n *   .createListing({ auctionHouse, mintAccount };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createListingOperation = useOperation<CreateListingOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateListingOperation = Operation<\n  typeof Key,\n  CreateListingInput,\n  CreateListingOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateListingInput = {\n  /** A model of the Auction House related to this listing. */\n  auctionHouse: AuctionHouse;\n\n  /**\n   * Creator of a listing.\n   *\n   * The wallet being a signer is the only condition in which an NFT can sell at a price of 0.\n   * If the user does list at 0 then auction house can change the sale price if the 'can_change_sale_price' option is true.\n   * If the trade is not priced at 0, the wallet holder has to be a signer since auction house cannot sign if listing over 0.\n   * There must be one and only one signer; Authority or Seller must sign.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  seller?: PublicKey | Signer;\n\n  /**\n   * The Auction House authority.\n   *\n   * There must be one and only one signer; Authority or Seller must sign.\n   * Auction house should be the signer for changing the price instead of user wallet for cases when seller lists at 0.\n   *\n   * @defaultValue `auctionHouse.authority`\n   */\n  authority?: PublicKey | Signer;\n\n  /**\n   * The Auctioneer authority key.\n   * It is required when Auction House has Auctioneer enabled.\n   *\n   * @defaultValue No default value.\n   */\n  auctioneerAuthority?: Signer;\n\n  /**\n   * The mint account to create a listing for.\n   * This is used to find the metadata.\n   */\n  mintAccount: PublicKey;\n\n  /**\n   * The token account address that's associated to the asset a listing created is for.\n   *\n   * @defaultValue Seller's Associated Token Account.\n   */\n  tokenAccount?: PublicKey;\n\n  /**\n   * The listing price.\n   *\n   * @defaultValue 0 SOLs or tokens.\n   */\n  price?: SolAmount | SplTokenAmount;\n\n  /**\n   * The number of tokens to list.\n   * For an NFT listing it must be 1 token.\n   *\n   * When a Fungible Asset is put on sale.\n   * The buyer can then create a buy order of said assets that is\n   * less than the token_size of the sell order.\n   *\n   * @defaultValue 1 token.\n   */\n  tokens?: SplTokenAmount;\n\n  /**\n   * The address of the bookkeeper wallet responsible for the receipt.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  bookkeeper?: Signer;\n\n  /**\n   * Prints the listing receipt.\n   * The receipt holds information about the listing,\n   * So it's important to print it if you want to use the `Listing` model\n   *\n   * The receipt printing is skipped for the Auctioneer Auction House\n   * Since it currently doesn't support it.\n   *\n   * @defaultValue `true`\n   */\n  printReceipt?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateListingOutput = {\n  /** Seller trade state account PDA encoding the listing order. */\n  sellerTradeState: Pda;\n\n  /** Seller free trade state account PDA encoding the free listing order. */\n  freeSellerTradeState: Pda;\n\n  /** The asset's token account address. */\n  tokenAccount: PublicKey;\n\n  /** The asset's metadata PDA. */\n  metadata: Pda;\n\n  /** The seller address. */\n  seller: PublicKey;\n\n  /** The PDA of the receipt account in case it was printed. */\n  receipt: Option<Pda>;\n\n  /** The address of the bookkeeper account responsible for the receipt. */\n  bookkeeper: Option<PublicKey>;\n\n  /** The listing price. */\n  price: SolAmount | SplTokenAmount;\n\n  /** The number of tokens listed. */\n  tokens: SplTokenAmount;\n\n  /** A model that keeps information about the Listing. */\n  listing: Listing;\n\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createListingOperationHandler: OperationHandler<CreateListingOperation> =\n  {\n    async handle(\n      operation: CreateListingOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateListingOutput> {\n      const { auctionHouse } = operation.input;\n      const builder = createListingBuilder(metaplex, operation.input, scope);\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      if (output.receipt) {\n        const listing = await metaplex\n          .auctionHouse()\n          .findListingByReceipt(\n            { receiptAddress: output.receipt, auctionHouse },\n            scope\n          );\n\n        return { listing, ...output };\n      }\n\n      scope.throwIfCanceled();\n      const lazyListing: LazyListing = {\n        model: 'listing',\n        lazy: true,\n        auctionHouse,\n        tradeStateAddress: output.sellerTradeState,\n        bookkeeperAddress: output.bookkeeper,\n        sellerAddress: output.seller,\n        metadataAddress: output.metadata,\n        receiptAddress: output.receipt,\n        purchaseReceiptAddress: null,\n        price: output.price,\n        tokens: output.tokens.basisPoints,\n        createdAt: now(),\n        canceledAt: null,\n      };\n\n      return {\n        listing: await metaplex\n          .auctionHouse()\n          .loadListing({ lazyListing }, scope),\n        ...output,\n      };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * Creates a listing on a given asset.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .auctionHouse()\n *   .builders()\n *   .createListing({ auctionHouse, mintAccount });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport type CreateListingBuilderParams = Omit<\n  CreateListingInput,\n  'confirmOptions'\n> & {\n  instructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateListingBuilderContext = Omit<\n  CreateListingOutput,\n  'response' | 'listing'\n>;\n\n/**\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createListingBuilder = (\n  metaplex: Metaplex,\n  params: CreateListingBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder<CreateListingBuilderContext> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    auctionHouse,\n    auctioneerAuthority,\n    mintAccount,\n    tokens = token(1),\n    seller = metaplex.identity(),\n    authority = auctionHouse.authorityAddress,\n  } = params;\n\n  // Data.\n  const priceBasisPoint = auctioneerAuthority\n    ? AUCTIONEER_PRICE\n    : params.price?.basisPoints ?? 0;\n  const price = auctionHouse.isNative\n    ? lamports(priceBasisPoint)\n    : amount(priceBasisPoint, auctionHouse.treasuryMint.currency);\n\n  if (auctionHouse.hasAuctioneer && !auctioneerAuthority) {\n    throw new AuctioneerAuthorityRequiredError();\n  }\n  if (!isSigner(seller) && !isSigner(authority)) {\n    throw new CreateListingRequiresSignerError();\n  }\n\n  // Accounts.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAccount,\n    programs,\n  });\n  const tokenAccount =\n    params.tokenAccount ??\n    metaplex\n      .tokens()\n      .pdas()\n      .associatedTokenAccount({\n        mint: mintAccount,\n        owner: toPublicKey(seller),\n        programs,\n      });\n  const sellerTradeState = metaplex\n    .auctionHouse()\n    .pdas()\n    .tradeState({\n      auctionHouse: auctionHouse.address,\n      wallet: toPublicKey(seller),\n      treasuryMint: auctionHouse.treasuryMint.address,\n      tokenMint: mintAccount,\n      price: price.basisPoints,\n      tokenSize: tokens.basisPoints,\n      tokenAccount,\n      programs,\n    });\n  const freeSellerTradeState = metaplex\n    .auctionHouse()\n    .pdas()\n    .tradeState({\n      auctionHouse: auctionHouse.address,\n      wallet: toPublicKey(seller),\n      treasuryMint: auctionHouse.treasuryMint.address,\n      tokenMint: mintAccount,\n      price: lamports(0).basisPoints,\n      tokenSize: tokens.basisPoints,\n      tokenAccount,\n      programs,\n    });\n  const programAsSigner = metaplex\n    .auctionHouse()\n    .pdas()\n    .programAsSigner({ programs });\n  const accounts = {\n    wallet: toPublicKey(seller),\n    tokenAccount,\n    metadata,\n    authority: toPublicKey(authority),\n    auctionHouse: auctionHouse.address,\n    auctionHouseFeeAccount: auctionHouse.feeAccountAddress,\n    sellerTradeState,\n    freeSellerTradeState,\n    programAsSigner,\n  };\n\n  // Args.\n  const args = {\n    tradeStateBump: sellerTradeState.bump,\n    freeTradeStateBump: freeSellerTradeState.bump,\n    programAsSignerBump: programAsSigner.bump,\n    buyerPrice: price.basisPoints,\n    tokenSize: tokens.basisPoints,\n  };\n\n  // Sell Instruction.\n  let sellInstruction = createSellInstruction(accounts, args);\n  if (auctioneerAuthority) {\n    sellInstruction = createAuctioneerSellInstruction(\n      {\n        ...accounts,\n        auctioneerAuthority: auctioneerAuthority.publicKey,\n        ahAuctioneerPda: metaplex.auctionHouse().pdas().auctioneer({\n          auctionHouse: auctionHouse.address,\n          auctioneerAuthority: auctioneerAuthority.publicKey,\n          programs,\n        }),\n      },\n      args\n    );\n  }\n\n  // Signers.\n  const signer = isSigner(seller) ? seller : (authority as Signer);\n  const sellSigners = [signer, auctioneerAuthority].filter(isSigner);\n\n  // Update the account to be a signer since it's not covered properly by MPL due to its dynamic nature.\n  const signerKeyIndex = sellInstruction.keys.findIndex((key) =>\n    key.pubkey.equals(signer.publicKey)\n  );\n  sellInstruction.keys[signerKeyIndex].isSigner = true;\n\n  // Fixes cross-program invocation with unauthorized writable account\n  if (sellInstruction.keys[signerKeyIndex].pubkey.equals(toPublicKey(seller))) {\n    sellInstruction.keys[signerKeyIndex].isWritable = true;\n  }\n\n  // Receipt.\n  // Since createPrintListingReceiptInstruction can't deserialize createAuctioneerSellInstruction due to a bug\n  // Don't print Auctioneer Sell receipt for the time being.\n  const shouldPrintReceipt =\n    (params.printReceipt ?? true) && !auctioneerAuthority;\n  const bookkeeper = params.bookkeeper ?? metaplex.identity();\n  const receipt = metaplex.auctionHouse().pdas().listingReceipt({\n    tradeState: sellerTradeState,\n    programs,\n  });\n\n  return (\n    TransactionBuilder.make<CreateListingBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        sellerTradeState,\n        freeSellerTradeState,\n        tokenAccount,\n        metadata,\n        seller: toPublicKey(seller),\n        receipt: shouldPrintReceipt ? receipt : null,\n        bookkeeper: shouldPrintReceipt ? bookkeeper.publicKey : null,\n        price,\n        tokens,\n      })\n\n      // Create Listing.\n      .add({\n        instruction: sellInstruction,\n        signers: sellSigners,\n        key: 'sell',\n      })\n\n      // Print the Listing Receipt.\n      .when(shouldPrintReceipt, (builder) =>\n        builder.add({\n          instruction: createPrintListingReceiptInstruction(\n            {\n              receipt,\n              bookkeeper: bookkeeper.publicKey,\n              instruction: SYSVAR_INSTRUCTIONS_PUBKEY,\n            },\n            { receiptBump: receipt.bump }\n          ),\n          signers: [bookkeeper],\n          key: 'printListingReceipt',\n        })\n      )\n  );\n};\n"]},"metadata":{},"sourceType":"module"}