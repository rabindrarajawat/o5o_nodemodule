{"ast":null,"code":"import { nftPaymentBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { GuardMintSettingsMissingError } from '../errors.mjs';\nimport { createSerializerFromBeet } from '../../../types/Serializer.mjs';\n/**\n * The nftPayment guard allows minting by charging the\n * payer an NFT from a specified NFT collection.\n * The NFT will be transfered to a predefined destination.\n *\n * This means the mint address of the NFT to transfer must be\n * passed when minting. This guard alone does not limit how many\n * times a holder can mint. A holder can mint as many times\n * as they have NFTs from the required collection to pay with.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link NftPaymentGuardMintSettings} for more\n * information on the mint settings of this guard.\n */\n\n/** @internal */\n\nconst nftPaymentGuardManifest = {\n  name: 'nftPayment',\n  settingsBytes: 64,\n  settingsSerializer: createSerializerFromBeet(nftPaymentBeet),\n  mintSettingsParser: _ref => {\n    let {\n      metaplex,\n      settings,\n      mintSettings,\n      payer,\n      programs\n    } = _ref;\n\n    if (!mintSettings) {\n      throw new GuardMintSettingsMissingError('nftPayment');\n    }\n\n    const associatedTokenProgram = metaplex.programs().getAssociatedToken(programs);\n    const nftTokenAccount = mintSettings.tokenAccount ?? metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintSettings.mint,\n      owner: payer.publicKey,\n      programs\n    });\n    const nftMetadata = metaplex.nfts().pdas().metadata({\n      mint: mintSettings.mint,\n      programs\n    });\n    const destinationAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintSettings.mint,\n      owner: settings.destination,\n      programs\n    });\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [{\n        isSigner: false,\n        address: nftTokenAccount,\n        isWritable: true\n      }, {\n        isSigner: false,\n        address: nftMetadata,\n        isWritable: true\n      }, {\n        isSigner: false,\n        address: mintSettings.mint,\n        isWritable: false\n      }, {\n        isSigner: false,\n        address: settings.destination,\n        isWritable: false\n      }, {\n        isSigner: false,\n        address: destinationAta,\n        isWritable: true\n      }, {\n        isSigner: false,\n        address: associatedTokenProgram.address,\n        isWritable: false\n      }]\n    };\n  }\n};\nexport { nftPaymentGuardManifest };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineModule/guards/nftPayment.ts"],"names":["nftPaymentGuardManifest","name","settingsBytes","settingsSerializer","createSerializerFromBeet","nftPaymentBeet","mintSettingsParser","metaplex","settings","mintSettings","payer","programs","GuardMintSettingsMissingError","associatedTokenProgram","getAssociatedToken","nftTokenAccount","tokenAccount","tokens","pdas","associatedTokenAccount","mint","owner","publicKey","nftMetadata","nfts","metadata","destinationAta","destination","arguments","Buffer","from","remainingAccounts","isSigner","address","isWritable"],"mappings":";;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAkCA;;AACO,MAAMA,uBAGZ,GAAG;EACFC,IAAI,EAAE,YADJ;EAEFC,aAAa,EAAE,EAFb;EAGFC,kBAAkB,EAAEC,wBAAwB,CAACC,cAAD,CAH1C;EAIFC,kBAAkB,EAAE,QAMd;IAAA,IANe;MACnBC,QADmB;MAEnBC,QAFmB;MAGnBC,YAHmB;MAInBC,KAJmB;MAKnBC;IALmB,CAMf;;IACJ,IAAI,CAACF,YAAL,EAAmB;MACjB,MAAM,IAAIG,6BAAJ,CAAkC,YAAlC,CAAN;IACF;;IAEA,MAAMC,sBAAsB,GAAGN,QAAQ,CACpCI,QAD4BJ,GAE5BO,kBAF4BP,CAETI,QAFSJ,CAA/B;IAIA,MAAMQ,eAAe,GACnBN,YAAY,CAACO,YAAbP,IACAF,QAAQ,CAACU,MAATV,GAAkBW,IAAlBX,GAAyBY,sBAAzBZ,CAAgD;MAC9Ca,IAAI,EAAEX,YAAY,CAACW,IAD2B;MAE9CC,KAAK,EAAEX,KAAK,CAACY,SAFiC;MAG9CX;IAH8C,CAAhDJ,CAFF;IAQA,MAAMgB,WAAW,GAAGhB,QAAQ,CAACiB,IAATjB,GAAgBW,IAAhBX,GAAuBkB,QAAvBlB,CAAgC;MAClDa,IAAI,EAAEX,YAAY,CAACW,IAD+B;MAElDT;IAFkD,CAAhCJ,CAApB;IAKA,MAAMmB,cAAc,GAAGnB,QAAQ,CAACU,MAATV,GAAkBW,IAAlBX,GAAyBY,sBAAzBZ,CAAgD;MACrEa,IAAI,EAAEX,YAAY,CAACW,IADkD;MAErEC,KAAK,EAAEb,QAAQ,CAACmB,WAFqD;MAGrEhB;IAHqE,CAAhDJ,CAAvB;IAMA,OAAO;MACLqB,SAAS,EAAEC,MAAM,CAACC,IAAPD,CAAY,EAAZA,CADN;MAELE,iBAAiB,EAAE,CACjB;QACEC,QAAQ,EAAE,KADZ;QAEEC,OAAO,EAAElB,eAFX;QAGEmB,UAAU,EAAE;MAHd,CADiB,EAMjB;QACEF,QAAQ,EAAE,KADZ;QAEEC,OAAO,EAAEV,WAFX;QAGEW,UAAU,EAAE;MAHd,CANiB,EAWjB;QACEF,QAAQ,EAAE,KADZ;QAEEC,OAAO,EAAExB,YAAY,CAACW,IAFxB;QAGEc,UAAU,EAAE;MAHd,CAXiB,EAgBjB;QACEF,QAAQ,EAAE,KADZ;QAEEC,OAAO,EAAEzB,QAAQ,CAACmB,WAFpB;QAGEO,UAAU,EAAE;MAHd,CAhBiB,EAqBjB;QACEF,QAAQ,EAAE,KADZ;QAEEC,OAAO,EAAEP,cAFX;QAGEQ,UAAU,EAAE;MAHd,CArBiB,EA0BjB;QACEF,QAAQ,EAAE,KADZ;QAEEC,OAAO,EAAEpB,sBAAsB,CAACoB,OAFlC;QAGEC,UAAU,EAAE;MAHd,CA1BiB;IAFd,CAAP;EAmCF;AAzEE,CAHG","sourcesContent":["import { nftPaymentBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { GuardMintSettingsMissingError } from '../errors';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet, PublicKey } from '@/types';\n\n/**\n * The nftPayment guard allows minting by charging the\n * payer an NFT from a specified NFT collection.\n * The NFT will be transfered to a predefined destination.\n *\n * This means the mint address of the NFT to transfer must be\n * passed when minting. This guard alone does not limit how many\n * times a holder can mint. A holder can mint as many times\n * as they have NFTs from the required collection to pay with.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link NftPaymentGuardMintSettings} for more\n * information on the mint settings of this guard.\n */\nexport type NftPaymentGuardSettings = {\n  /** The mint address of the required NFT Collection. */\n  requiredCollection: PublicKey;\n\n  /** The address of the account to send the NFTs to. */\n  destination: PublicKey;\n};\n\n/**\n * The settings for the nftPayment guard that could\n * be provided when minting from the Candy Machine.\n *\n * @see {@link NftPaymentGuardSettings} for more\n * information on the nftPayment guard itself.\n */\nexport type NftPaymentGuardMintSettings = {\n  /**\n   * The mint address of the NFT to pay with.\n   * This must be part of the required collection and must\n   * belong to the payer.\n   */\n  mint: PublicKey;\n\n  /**\n   * The token account linking the NFT with its owner.\n   *\n   * @defaultValue\n   * Defaults to the associated token address using the\n   * mint address of the NFT and the payer's address.\n   */\n  tokenAccount?: PublicKey;\n};\n\n/** @internal */\nexport const nftPaymentGuardManifest: CandyGuardManifest<\n  NftPaymentGuardSettings,\n  NftPaymentGuardMintSettings\n> = {\n  name: 'nftPayment',\n  settingsBytes: 64,\n  settingsSerializer: createSerializerFromBeet(nftPaymentBeet),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    mintSettings,\n    payer,\n    programs,\n  }) => {\n    if (!mintSettings) {\n      throw new GuardMintSettingsMissingError('nftPayment');\n    }\n\n    const associatedTokenProgram = metaplex\n      .programs()\n      .getAssociatedToken(programs);\n\n    const nftTokenAccount =\n      mintSettings.tokenAccount ??\n      metaplex.tokens().pdas().associatedTokenAccount({\n        mint: mintSettings.mint,\n        owner: payer.publicKey,\n        programs,\n      });\n\n    const nftMetadata = metaplex.nfts().pdas().metadata({\n      mint: mintSettings.mint,\n      programs,\n    });\n\n    const destinationAta = metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintSettings.mint,\n      owner: settings.destination,\n      programs,\n    });\n\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          address: nftTokenAccount,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: nftMetadata,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: mintSettings.mint,\n          isWritable: false,\n        },\n        {\n          isSigner: false,\n          address: settings.destination,\n          isWritable: false,\n        },\n        {\n          isSigner: false,\n          address: destinationAta,\n          isWritable: true,\n        },\n        {\n          isSigner: false,\n          address: associatedTokenProgram.address,\n          isWritable: false,\n        },\n      ],\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"module"}