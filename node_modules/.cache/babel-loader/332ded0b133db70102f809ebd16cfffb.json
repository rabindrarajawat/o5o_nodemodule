{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tuplesTypeMap = exports.tuple = exports.fixedSizeTuple = void 0;\n\nconst types_1 = require(\"../types\");\n\nconst assert_1 = require(\"assert\");\n\nconst beet_fixable_1 = require(\"../beet.fixable\"); // Tuples are a special kind of composite which can be understood as\n// fixed length arrays where each tuple element can have a different data type.\n// Since the Tuple type itself dictates the length, and buffer layout, no extra\n// information is included in the serialized data.\n\n/**\n * De/Serializes a tuple with all fixed size tuple elements .\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n *\n * @category beet/composite\n */\n\n\nfunction fixedSizeTuple(elements) {\n  const len = elements.length;\n  const elDescs = elements.map(x => x.description);\n  const byteSizes = elements.map(x => x.byteSize);\n  const byteSize = byteSizes.reduce((acc, x) => acc + x, 0);\n  return {\n    write: function (buf, offset, value) {\n      assert_1.strict.equal(value.length, len, `tuple value element size ${value.length} should match len ${len}`);\n      let cursor = offset;\n\n      for (let i = 0; i < len; i++) {\n        const v = value[i];\n        const beetEl = elements[i];\n        beetEl.write(buf, cursor, v);\n        cursor += beetEl.byteSize;\n      }\n    },\n    read: function (buf, offset) {\n      const els = [];\n      let cursor = offset;\n\n      for (let i = 0; i < len; i++) {\n        const elBeet = elements[i];\n        els[i] = elBeet.read(buf, cursor);\n        cursor += elBeet.byteSize;\n      }\n\n      return els;\n    },\n    byteSize,\n    length: len,\n    description: `FixedSizeTuple<${elDescs.join(',')}>[ ${byteSizes.join(', ')} ]`\n  };\n}\n\nexports.fixedSizeTuple = fixedSizeTuple;\n/**\n * De/Serializes a tuple which contains some non-fixed size tuple elements.\n *\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n * @category beet/composite\n */\n\nfunction tuple(elements) {\n  const len = elements.length;\n  const elDescs = elements.map(x => x.description);\n  return {\n    toFixedFromData(buf, offset) {\n      let cursor = offset;\n      const fixedElements = new Array(len);\n\n      for (let i = 0; i < len; i++) {\n        const fixedElement = (0, beet_fixable_1.fixBeetFromData)(elements[i], buf, cursor);\n        fixedElements[i] = fixedElement;\n        cursor += fixedElement.byteSize;\n      }\n\n      return fixedSizeTuple(fixedElements);\n    },\n\n    toFixedFromValue(vals) {\n      (0, assert_1.strict)(Array.isArray(vals), `${vals} should be an array of tuple values`);\n      assert_1.strict.equal(vals.length, len, `There should be ${len} tuple values, but there are ${vals.length}`);\n      const fixedElements = new Array(len);\n\n      for (let i = 0; i < vals.length; i++) {\n        const fixedElement = (0, beet_fixable_1.fixBeetFromValue)(elements[i], vals[i]);\n        fixedElements[i] = fixedElement;\n      }\n\n      return fixedSizeTuple(fixedElements);\n    },\n\n    description: `Tuple<${elDescs.join(',')}>`\n  };\n}\n\nexports.tuple = tuple;\n/**\n * Maps tuples beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexports.tuplesTypeMap = {\n  Tuple: {\n    beet: 'tuple',\n    isFixable: true,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: '[__tuple_elements__]'\n  },\n  FixedSizeTuple: {\n    beet: 'fixedSizeTuple',\n    isFixable: false,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: '[__tuple_elements__]'\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/tuples.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAMA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,iBAAA,CAAA,C,CAEA;AACA;AACA;AACA;;AAEA;;;;;;;;AAQG;;;AACH,SAAgB,cAAhB,CACE,QADF,EACgC;EAE9B,MAAM,GAAG,GAAG,QAAQ,CAAC,MAArB;EACA,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAT,CAAc,CAAD,IAAO,CAAC,CAAC,WAAtB,CAAhB;EACA,MAAM,SAAS,GAAG,QAAQ,CAAC,GAAT,CAAc,CAAD,IAAO,CAAC,CAAC,QAAtB,CAAlB;EACA,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAV,CAAiB,CAAC,GAAD,EAAM,CAAN,KAAY,GAAG,GAAG,CAAnC,EAAsC,CAAtC,CAAjB;EAEA,OAAO;IACL,KAAK,EAAE,UAAU,GAAV,EAAuB,MAAvB,EAAuC,KAAvC,EAA+C;MACpD,QAAA,CAAA,MAAA,CAAO,KAAP,CACE,KAAK,CAAC,MADR,EAEE,GAFF,EAGE,4BAA4B,KAAK,CAAC,MAAM,qBAAqB,GAAG,EAHlE;MAKA,IAAI,MAAM,GAAG,MAAb;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;QAC5B,MAAM,CAAC,GAAG,KAAK,CAAC,CAAD,CAAf;QACA,MAAM,MAAM,GAAG,QAAQ,CAAC,CAAD,CAAvB;QACA,MAAM,CAAC,KAAP,CAAa,GAAb,EAAkB,MAAlB,EAA0B,CAA1B;QACA,MAAM,IAAI,MAAM,CAAC,QAAjB;MACD;IACF,CAdI;IAgBL,IAAI,EAAE,UAAU,GAAV,EAAuB,MAAvB,EAAqC;MACzC,MAAM,GAAG,GAAG,EAAZ;MACA,IAAI,MAAM,GAAG,MAAb;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;QAC5B,MAAM,MAAM,GAAG,QAAQ,CAAC,CAAD,CAAvB;QACA,GAAG,CAAC,CAAD,CAAH,GAAS,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,MAAjB,CAAT;QACA,MAAM,IAAI,MAAM,CAAC,QAAjB;MACD;;MACD,OAAO,GAAP;IACD,CAzBI;IA2BL,QA3BK;IA4BL,MAAM,EAAE,GA5BH;IA6BL,WAAW,EAAE,kBAAkB,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,MAAM,SAAS,CAAC,IAAV,CACpD,IADoD,CAErD;EA/BI,CAAP;AAiCD;;AAzCD,OAAA,CAAA,cAAA,GAAA,cAAA;AA2CA;;;;;;;;AAQG;;AACH,SAAgB,KAAhB,CACE,QADF,EAC+D;EAE7D,MAAM,GAAG,GAAG,QAAQ,CAAC,MAArB;EACA,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAT,CAAc,CAAD,IAAO,CAAC,CAAC,WAAtB,CAAhB;EAEA,OAAO;IACL,eAAe,CAAC,GAAD,EAAc,MAAd,EAA4B;MACzC,IAAI,MAAM,GAAG,MAAb;MACA,MAAM,aAAa,GAAuB,IAAI,KAAJ,CAAU,GAAV,CAA1C;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;QAC5B,MAAM,YAAY,GAAG,CAAA,GAAA,cAAA,CAAA,eAAA,EAAgB,QAAQ,CAAC,CAAD,CAAxB,EAA6B,GAA7B,EAAkC,MAAlC,CAArB;QACA,aAAa,CAAC,CAAD,CAAb,GAAmB,YAAnB;QACA,MAAM,IAAI,YAAY,CAAC,QAAvB;MACD;;MACD,OAAO,cAAc,CAAC,aAAD,CAArB;IACD,CAVI;;IAYL,gBAAgB,CAAC,IAAD,EAAY;MAC1B,CAAA,GAAA,QAAA,CAAA,MAAA,EAAO,KAAK,CAAC,OAAN,CAAc,IAAd,CAAP,EAA4B,GAAG,IAAI,qCAAnC;MACA,QAAA,CAAA,MAAA,CAAO,KAAP,CACE,IAAI,CAAC,MADP,EAEE,GAFF,EAGE,mBAAmB,GAAG,gCAAgC,IAAI,CAAC,MAAM,EAHnE;MAMA,MAAM,aAAa,GAAuB,IAAI,KAAJ,CAAU,GAAV,CAA1C;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,EAAlC,EAAsC;QACpC,MAAM,YAAY,GAAG,CAAA,GAAA,cAAA,CAAA,gBAAA,EAAiB,QAAQ,CAAC,CAAD,CAAzB,EAA8B,IAAI,CAAC,CAAD,CAAlC,CAArB;QACA,aAAa,CAAC,CAAD,CAAb,GAAmB,YAAnB;MACD;;MACD,OAAO,cAAc,CAAC,aAAD,CAArB;IACD,CA1BI;;IA4BL,WAAW,EAAE,SAAS,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB;EA5BlC,CAAP;AA8BD;;AApCD,OAAA,CAAA,KAAA,GAAA,KAAA;AA2DA;;;;;;AAMG;;AACU,OAAA,CAAA,aAAA,GAA+B;EAC1C,KAAK,EAAE;IACL,IAAI,EAAE,OADD;IAEL,SAAS,EAAE,IAFN;IAGL,UAAU,EAAE,OAAA,CAAA,YAHP;IAIL,EAAE,EAAE;EAJC,CADmC;EAO1C,cAAc,EAAE;IACd,IAAI,EAAE,gBADQ;IAEd,SAAS,EAAE,KAFG;IAGd,UAAU,EAAE,OAAA,CAAA,YAHE;IAId,EAAE,EAAE;EAJU;AAP0B,CAA/B","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tuplesTypeMap = exports.tuple = exports.fixedSizeTuple = void 0;\nconst types_1 = require(\"../types\");\nconst assert_1 = require(\"assert\");\nconst beet_fixable_1 = require(\"../beet.fixable\");\n// Tuples are a special kind of composite which can be understood as\n// fixed length arrays where each tuple element can have a different data type.\n// Since the Tuple type itself dictates the length, and buffer layout, no extra\n// information is included in the serialized data.\n/**\n * De/Serializes a tuple with all fixed size tuple elements .\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n *\n * @category beet/composite\n */\nfunction fixedSizeTuple(elements) {\n    const len = elements.length;\n    const elDescs = elements.map((x) => x.description);\n    const byteSizes = elements.map((x) => x.byteSize);\n    const byteSize = byteSizes.reduce((acc, x) => acc + x, 0);\n    return {\n        write: function (buf, offset, value) {\n            assert_1.strict.equal(value.length, len, `tuple value element size ${value.length} should match len ${len}`);\n            let cursor = offset;\n            for (let i = 0; i < len; i++) {\n                const v = value[i];\n                const beetEl = elements[i];\n                beetEl.write(buf, cursor, v);\n                cursor += beetEl.byteSize;\n            }\n        },\n        read: function (buf, offset) {\n            const els = [];\n            let cursor = offset;\n            for (let i = 0; i < len; i++) {\n                const elBeet = elements[i];\n                els[i] = elBeet.read(buf, cursor);\n                cursor += elBeet.byteSize;\n            }\n            return els;\n        },\n        byteSize,\n        length: len,\n        description: `FixedSizeTuple<${elDescs.join(',')}>[ ${byteSizes.join(', ')} ]`,\n    };\n}\nexports.fixedSizeTuple = fixedSizeTuple;\n/**\n * De/Serializes a tuple which contains some non-fixed size tuple elements.\n *\n * Since each tuple element can be of a different type not much type safety can\n * be provided here.\n *\n * @param elements the De/Serializer for each tuple element type\n * @category beet/composite\n */\nfunction tuple(elements) {\n    const len = elements.length;\n    const elDescs = elements.map((x) => x.description);\n    return {\n        toFixedFromData(buf, offset) {\n            let cursor = offset;\n            const fixedElements = new Array(len);\n            for (let i = 0; i < len; i++) {\n                const fixedElement = (0, beet_fixable_1.fixBeetFromData)(elements[i], buf, cursor);\n                fixedElements[i] = fixedElement;\n                cursor += fixedElement.byteSize;\n            }\n            return fixedSizeTuple(fixedElements);\n        },\n        toFixedFromValue(vals) {\n            (0, assert_1.strict)(Array.isArray(vals), `${vals} should be an array of tuple values`);\n            assert_1.strict.equal(vals.length, len, `There should be ${len} tuple values, but there are ${vals.length}`);\n            const fixedElements = new Array(len);\n            for (let i = 0; i < vals.length; i++) {\n                const fixedElement = (0, beet_fixable_1.fixBeetFromValue)(elements[i], vals[i]);\n                fixedElements[i] = fixedElement;\n            }\n            return fixedSizeTuple(fixedElements);\n        },\n        description: `Tuple<${elDescs.join(',')}>`,\n    };\n}\nexports.tuple = tuple;\n/**\n * Maps tuples beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.tuplesTypeMap = {\n    Tuple: {\n        beet: 'tuple',\n        isFixable: true,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: '[__tuple_elements__]',\n    },\n    FixedSizeTuple: {\n        beet: 'fixedSizeTuple',\n        isFixable: false,\n        sourcePack: types_1.BEET_PACKAGE,\n        ts: '[__tuple_elements__]',\n    },\n};\n//# sourceMappingURL=tuples.js.map"]},"metadata":{},"sourceType":"script"}