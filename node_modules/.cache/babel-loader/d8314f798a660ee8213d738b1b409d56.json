{"ast":null,"code":"import { createMintNftInstruction, createSetCollectionDuringMintInstruction } from '@metaplex-foundation/mpl-candy-machine';\nimport { Keypair, SYSVAR_CLOCK_PUBKEY, SYSVAR_SLOT_HASHES_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { parseCandyMachineV2CollectionAccount } from '../accounts.mjs';\nimport { assertCanMintCandyMachineV2 } from '../asserts.mjs';\nimport { CandyMachineV2BotTaxError } from '../errors.mjs';\nimport { findCandyMachineV2CreatorPda, findCandyMachineV2CollectionPda } from '../pdas.mjs';\nimport { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { token } from '../../../types/Amount.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs';\nimport { assertAccountExists } from '../../../types/Account.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'MintCandyMachineV2Operation';\n/**\n * Mint an NFT from an existing Candy Machine.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .candyMachinesV2()\n *   .mint({ candyMachine };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst mintCandyMachineV2Operation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst mintCandyMachineV2OperationHandler = {\n  async handle(operation, metaplex, scope) {\n    assertCanMintCandyMachineV2(operation.input.candyMachine, scope.payer);\n    const builder = await mintCandyMachineV2Builder(metaplex, operation.input, scope);\n    scope.throwIfCanceled();\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n    let nft;\n\n    try {\n      nft = await metaplex.nfts().findByMint({\n        mintAddress: output.mintSigner.publicKey,\n        tokenAddress: output.tokenAddress\n      }, scope);\n    } catch (error) {\n      throw new CandyMachineV2BotTaxError(metaplex.rpc().getSolanaExporerUrl(output.response.signature), error);\n    }\n\n    return {\n      nft,\n      ...output\n    };\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Mint an NFT from an existing Candy Machine.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .mint({ candyMachine });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst mintCandyMachineV2Builder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    candyMachine,\n    newMint = Keypair.generate(),\n    newOwner = metaplex.identity().publicKey,\n    newToken\n  } = params;\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs).address;\n  const newMetadata = metaplex.nfts().pdas().metadata({\n    mint: newMint.publicKey,\n    programs\n  });\n  const newEdition = metaplex.nfts().pdas().masterEdition({\n    mint: newMint.publicKey,\n    programs\n  });\n  const candyMachineCreator = findCandyMachineV2CreatorPda(candyMachine.address);\n  const candyMachineCollectionAddress = findCandyMachineV2CollectionPda(candyMachine.address);\n  const candyMachineCollectionAccount = parseCandyMachineV2CollectionAccount(await metaplex.rpc().getAccount(candyMachineCollectionAddress));\n  const tokenWithMintBuilder = await metaplex.tokens().builders().createTokenWithMint({\n    decimals: 0,\n    initialSupply: token(1),\n    mint: newMint,\n    mintAuthority: payer,\n    freezeAuthority: payer.publicKey,\n    owner: newOwner,\n    token: newToken,\n    createMintAccountInstructionKey: params.createMintAccountInstructionKey,\n    initializeMintInstructionKey: params.initializeMintInstructionKey,\n    createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey,\n    createTokenAccountInstructionKey: params.createTokenAccountInstructionKey,\n    initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n    mintTokensInstructionKey: params.mintTokensInstructionKey\n  }, {\n    payer,\n    programs\n  });\n  const {\n    tokenAddress\n  } = tokenWithMintBuilder.getContext();\n  const mintNftInstruction = createMintNftInstruction({\n    candyMachine: candyMachine.address,\n    candyMachineCreator,\n    payer: payer.publicKey,\n    wallet: candyMachine.walletAddress,\n    metadata: newMetadata,\n    mint: newMint.publicKey,\n    mintAuthority: payer.publicKey,\n    updateAuthority: payer.publicKey,\n    masterEdition: newEdition,\n    tokenMetadataProgram,\n    clock: SYSVAR_CLOCK_PUBKEY,\n    recentBlockhashes: SYSVAR_SLOT_HASHES_PUBKEY,\n    instructionSysvarAccount: SYSVAR_INSTRUCTIONS_PUBKEY\n  }, {\n    creatorBump: candyMachineCreator.bump\n  });\n\n  if (candyMachine.whitelistMintSettings) {\n    const whitelistToken = params.whitelistToken ?? metaplex.tokens().pdas().associatedTokenAccount({\n      mint: candyMachine.whitelistMintSettings.mint,\n      owner: payer.publicKey\n    });\n    mintNftInstruction.keys.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: candyMachine.whitelistMintSettings.mint,\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: payer.publicKey,\n      isWritable: false,\n      isSigner: true\n    });\n  }\n\n  if (candyMachine.tokenMintAddress) {\n    const payerToken = params.payerToken ?? metaplex.tokens().pdas().associatedTokenAccount({\n      mint: candyMachine.tokenMintAddress,\n      owner: payer.publicKey\n    });\n    mintNftInstruction.keys.push({\n      pubkey: payerToken,\n      isWritable: true,\n      isSigner: false\n    }, {\n      pubkey: payer.publicKey,\n      isWritable: false,\n      isSigner: true\n    });\n  }\n\n  return TransactionBuilder.make().setFeePayer(payer).setContext({\n    mintSigner: newMint,\n    tokenAddress\n  }) // Create token and mint accounts.\n  .add(tokenWithMintBuilder) // Create the new NFT.\n  .add({\n    instruction: mintNftInstruction,\n    signers: [payer, newMint],\n    key: params.mintNftInstructionKey ?? 'mintNft'\n  }) // Set the collection on the NFT.\n  .when(candyMachineCollectionAccount.exists, builder => {\n    assertAccountExists(candyMachineCollectionAccount);\n    const collectionMint = candyMachineCollectionAccount.data.mint;\n    const collectionMetadata = metaplex.nfts().pdas().metadata({\n      mint: collectionMint,\n      programs\n    });\n    const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({\n      mint: collectionMint,\n      programs\n    });\n    const collectionAuthorityRecord = metaplex.nfts().pdas().collectionAuthorityRecord({\n      mint: collectionMint,\n      collectionAuthority: candyMachineCollectionAccount.publicKey,\n      programs\n    });\n    return builder.add({\n      instruction: createSetCollectionDuringMintInstruction({\n        candyMachine: candyMachine.address,\n        metadata: newMetadata,\n        payer: payer.publicKey,\n        collectionPda: candyMachineCollectionAccount.publicKey,\n        tokenMetadataProgram,\n        instructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n        collectionMint: candyMachineCollectionAccount.data.mint,\n        collectionMetadata,\n        collectionMasterEdition,\n        authority: candyMachine.authorityAddress,\n        collectionAuthorityRecord\n      }),\n      signers: [payer],\n      key: params.setCollectionInstructionKey ?? 'setCollection'\n    });\n  });\n};\n\nexport { mintCandyMachineV2Builder, mintCandyMachineV2Operation, mintCandyMachineV2OperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineV2Module/operations/mintCandyMachineV2.ts"],"names":["Key","mintCandyMachineV2Operation","useOperation","mintCandyMachineV2OperationHandler","handle","operation","metaplex","scope","assertCanMintCandyMachineV2","input","candyMachine","payer","builder","mintCandyMachineV2Builder","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","nft","nfts","findByMint","mintAddress","mintSigner","publicKey","tokenAddress","error","CandyMachineV2BotTaxError","rpc","getSolanaExporerUrl","response","signature","params","options","programs","getDefaultFeePayer","newMint","Keypair","generate","newOwner","identity","newToken","tokenMetadataProgram","getTokenMetadata","address","newMetadata","pdas","metadata","mint","newEdition","masterEdition","candyMachineCreator","findCandyMachineV2CreatorPda","candyMachineCollectionAddress","findCandyMachineV2CollectionPda","candyMachineCollectionAccount","parseCandyMachineV2CollectionAccount","getAccount","tokenWithMintBuilder","tokens","builders","createTokenWithMint","decimals","initialSupply","token","mintAuthority","freezeAuthority","owner","createMintAccountInstructionKey","initializeMintInstructionKey","createAssociatedTokenAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","mintTokensInstructionKey","getContext","mintNftInstruction","createMintNftInstruction","wallet","walletAddress","updateAuthority","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_SLOT_HASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","creatorBump","bump","whitelistMintSettings","whitelistToken","associatedTokenAccount","keys","push","pubkey","isWritable","isSigner","tokenMintAddress","payerToken","TransactionBuilder","make","setFeePayer","setContext","add","instruction","signers","key","mintNftInstructionKey","when","exists","assertAccountExists","collectionMint","data","collectionMetadata","collectionMasterEdition","collectionAuthorityRecord","collectionAuthority","createSetCollectionDuringMintInstruction","collectionPda","instructions","authority","authorityAddress","setCollectionInstructionKey"],"mappings":"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","sourcesContent":["import {\n  createMintNftInstruction,\n  createSetCollectionDuringMintInstruction,\n} from '@metaplex-foundation/mpl-candy-machine';\nimport {\n  Keypair,\n  PublicKey,\n  SYSVAR_CLOCK_PUBKEY,\n  SYSVAR_INSTRUCTIONS_PUBKEY,\n  SYSVAR_SLOT_HASHES_PUBKEY,\n} from '@solana/web3.js';\nimport { NftWithToken } from '../../nftModule';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { parseCandyMachineV2CollectionAccount } from '../accounts';\nimport { assertCanMintCandyMachineV2 } from '../asserts';\nimport { CandyMachineV2BotTaxError } from '../errors';\nimport { CandyMachineV2 } from '../models';\nimport {\n  findCandyMachineV2CollectionPda,\n  findCandyMachineV2CreatorPda,\n} from '../pdas';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  assertAccountExists,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  token,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'MintCandyMachineV2Operation' as const;\n\n/**\n * Mint an NFT from an existing Candy Machine.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .candyMachinesV2()\n *   .mint({ candyMachine };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const mintCandyMachineV2Operation =\n  useOperation<MintCandyMachineV2Operation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type MintCandyMachineV2Operation = Operation<\n  typeof Key,\n  MintCandyMachineV2Input,\n  MintCandyMachineV2Output\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type MintCandyMachineV2Input = {\n  /**\n   * The Candy Machine to mint from.\n   * We only need a subset of the `CandyMachine` model but we\n   * need enough information regarding its settings to know how\n   * to mint from it.\n   *\n   * This includes, its wallet address, its item statistics, it live date,\n   * its whitelist settings, etc.\n   */\n  candyMachine: Pick<\n    CandyMachineV2,\n    | 'address'\n    | 'walletAddress'\n    | 'authorityAddress'\n    | 'tokenMintAddress'\n    | 'itemsRemaining'\n    | 'itemsAvailable'\n    | 'itemsMinted'\n    | 'whitelistMintSettings'\n    | 'goLiveDate'\n    | 'endSettings'\n  >;\n\n  /**\n   * The mint account to create as a Signer.\n   * This expects a brand new Keypair with no associated account.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  newMint?: Signer;\n\n  /**\n   * The owner of the minted NFT.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  newOwner?: PublicKey;\n\n  /**\n   * The new token account to create as a Signer.\n   *\n   * This property would typically be ignored as, by default, it will create a\n   * associated token account from the `newOwner` and `newMint` properties.\n   *\n   * When provided, the `newOwner` property will be ignored.\n   *\n   * @defaultValue associated token address of `newOwner` and `newMint`.\n   */\n  newToken?: Signer;\n\n  /**\n   * The token account that should pay for the minted NFT.\n   *\n   * This is only relevant when the Candy Machine uses a mint treasury\n   * (i.e. payments are made using SPL tokens and not SOL).\n   *\n   * @defaultValue associated token address of `payer` and\n   * `candyMachine.tokenMintAddress`.\n   */\n  payerToken?: PublicKey;\n\n  /**\n   * The token account that contains whitelist tokens.\n   *\n   * This is only relevant when the Candy Machine uses\n   * whitelist settings.\n   *\n   * @defaultValue associated token address of `payer` and\n   * `candyMachine.whitelistMintSettings.mint`.\n   */\n  whitelistToken?: PublicKey; // Defaults to associated token.\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type MintCandyMachineV2Output = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The minted NFT. */\n  nft: NftWithToken;\n\n  /** The mint account of the minted NFT as a Signer. */\n  mintSigner: Signer;\n\n  /** The token account's address of the minted NFT. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const mintCandyMachineV2OperationHandler: OperationHandler<MintCandyMachineV2Operation> =\n  {\n    async handle(\n      operation: MintCandyMachineV2Operation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<MintCandyMachineV2Output> {\n      assertCanMintCandyMachineV2(operation.input.candyMachine, scope.payer);\n\n      const builder = await mintCandyMachineV2Builder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      let nft: NftWithToken;\n      try {\n        nft = (await metaplex.nfts().findByMint(\n          {\n            mintAddress: output.mintSigner.publicKey,\n            tokenAddress: output.tokenAddress,\n          },\n          scope\n        )) as NftWithToken;\n      } catch (error) {\n        throw new CandyMachineV2BotTaxError(\n          metaplex.rpc().getSolanaExporerUrl(output.response.signature),\n          error as Error\n        );\n      }\n\n      return { nft, ...output };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type MintCandyMachineV2BuilderParams = Omit<\n  MintCandyMachineV2Input,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the mint account of the NFT. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account of the NFT. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account of the NFT. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account of the NFT. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account of the NFT. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints the one token. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints the NFT. */\n  mintNftInstructionKey?: string;\n\n  /** A key to distinguish the instruction that sets the collection on the minted NFT. */\n  setCollectionInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type MintCandyMachineV2BuilderContext = Omit<\n  MintCandyMachineV2Output,\n  'response' | 'nft'\n>;\n\n/**\n * Mint an NFT from an existing Candy Machine.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachinesV2()\n *   .builders()\n *   .mint({ candyMachine });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const mintCandyMachineV2Builder = async (\n  metaplex: Metaplex,\n  params: MintCandyMachineV2BuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<MintCandyMachineV2BuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyMachine,\n    newMint = Keypair.generate(),\n    newOwner = metaplex.identity().publicKey,\n    newToken,\n  } = params;\n\n  const tokenMetadataProgram = metaplex\n    .programs()\n    .getTokenMetadata(programs).address;\n\n  const newMetadata = metaplex.nfts().pdas().metadata({\n    mint: newMint.publicKey,\n    programs,\n  });\n  const newEdition = metaplex.nfts().pdas().masterEdition({\n    mint: newMint.publicKey,\n    programs,\n  });\n  const candyMachineCreator = findCandyMachineV2CreatorPda(\n    candyMachine.address\n  );\n  const candyMachineCollectionAddress = findCandyMachineV2CollectionPda(\n    candyMachine.address\n  );\n  const candyMachineCollectionAccount = parseCandyMachineV2CollectionAccount(\n    await metaplex.rpc().getAccount(candyMachineCollectionAddress)\n  );\n\n  const tokenWithMintBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createTokenWithMint(\n      {\n        decimals: 0,\n        initialSupply: token(1),\n        mint: newMint,\n        mintAuthority: payer,\n        freezeAuthority: payer.publicKey,\n        owner: newOwner,\n        token: newToken,\n        createMintAccountInstructionKey: params.createMintAccountInstructionKey,\n        initializeMintInstructionKey: params.initializeMintInstructionKey,\n        createAssociatedTokenAccountInstructionKey:\n          params.createAssociatedTokenAccountInstructionKey,\n        createTokenAccountInstructionKey:\n          params.createTokenAccountInstructionKey,\n        initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n        mintTokensInstructionKey: params.mintTokensInstructionKey,\n      },\n      { payer, programs }\n    );\n\n  const { tokenAddress } = tokenWithMintBuilder.getContext();\n\n  const mintNftInstruction = createMintNftInstruction(\n    {\n      candyMachine: candyMachine.address,\n      candyMachineCreator,\n      payer: payer.publicKey,\n      wallet: candyMachine.walletAddress,\n      metadata: newMetadata,\n      mint: newMint.publicKey,\n      mintAuthority: payer.publicKey,\n      updateAuthority: payer.publicKey,\n      masterEdition: newEdition,\n      tokenMetadataProgram,\n      clock: SYSVAR_CLOCK_PUBKEY,\n      recentBlockhashes: SYSVAR_SLOT_HASHES_PUBKEY,\n      instructionSysvarAccount: SYSVAR_INSTRUCTIONS_PUBKEY,\n    },\n    { creatorBump: candyMachineCreator.bump }\n  );\n\n  if (candyMachine.whitelistMintSettings) {\n    const whitelistToken =\n      params.whitelistToken ??\n      metaplex.tokens().pdas().associatedTokenAccount({\n        mint: candyMachine.whitelistMintSettings.mint,\n        owner: payer.publicKey,\n      });\n\n    mintNftInstruction.keys.push(\n      {\n        pubkey: whitelistToken,\n        isWritable: true,\n        isSigner: false,\n      },\n      {\n        pubkey: candyMachine.whitelistMintSettings.mint,\n        isWritable: true,\n        isSigner: false,\n      },\n      {\n        pubkey: payer.publicKey,\n        isWritable: false,\n        isSigner: true,\n      }\n    );\n  }\n\n  if (candyMachine.tokenMintAddress) {\n    const payerToken =\n      params.payerToken ??\n      metaplex.tokens().pdas().associatedTokenAccount({\n        mint: candyMachine.tokenMintAddress,\n        owner: payer.publicKey,\n      });\n\n    mintNftInstruction.keys.push(\n      {\n        pubkey: payerToken,\n        isWritable: true,\n        isSigner: false,\n      },\n      {\n        pubkey: payer.publicKey,\n        isWritable: false,\n        isSigner: true,\n      }\n    );\n  }\n\n  return (\n    TransactionBuilder.make<MintCandyMachineV2BuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintSigner: newMint,\n        tokenAddress,\n      })\n\n      // Create token and mint accounts.\n      .add(tokenWithMintBuilder)\n\n      // Create the new NFT.\n      .add({\n        instruction: mintNftInstruction,\n        signers: [payer, newMint],\n        key: params.mintNftInstructionKey ?? 'mintNft',\n      })\n\n      // Set the collection on the NFT.\n      .when(candyMachineCollectionAccount.exists, (builder) => {\n        assertAccountExists(candyMachineCollectionAccount);\n        const collectionMint = candyMachineCollectionAccount.data.mint;\n        const collectionMetadata = metaplex.nfts().pdas().metadata({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({\n          mint: collectionMint,\n          programs,\n        });\n        const collectionAuthorityRecord = metaplex\n          .nfts()\n          .pdas()\n          .collectionAuthorityRecord({\n            mint: collectionMint,\n            collectionAuthority: candyMachineCollectionAccount.publicKey,\n            programs,\n          });\n\n        return builder.add({\n          instruction: createSetCollectionDuringMintInstruction({\n            candyMachine: candyMachine.address,\n            metadata: newMetadata,\n            payer: payer.publicKey,\n            collectionPda: candyMachineCollectionAccount.publicKey,\n            tokenMetadataProgram,\n            instructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            collectionMint: candyMachineCollectionAccount.data.mint,\n            collectionMetadata,\n            collectionMasterEdition,\n            authority: candyMachine.authorityAddress,\n            collectionAuthorityRecord,\n          }),\n          signers: [payer],\n          key: params.setCollectionInstructionKey ?? 'setCollection',\n        });\n      })\n  );\n};\n"]},"metadata":{},"sourceType":"module"}