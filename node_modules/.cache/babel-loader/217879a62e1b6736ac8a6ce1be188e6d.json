{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport { allowListBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { mapSerializer, createSerializerFromBeet } from '../../../types/Serializer.mjs';\n/**\n * The allowList guard validates the minting wallet against\n * a predefined list of wallets.\n *\n * Instead of passing the entire list of wallets as settings,\n * this guard accepts the Root of a Merkle Tree created from\n * this allow list. The program can then validate that the minting\n * wallet is part of the allow list by requiring a Merkle Proof.\n * Minting will fail if either the minting address is not part of\n * the merkle tree or if no Merkle Proof is specified.\n *\n * You may use the `getMerkleRoot` and `getMerkleProof` helper\n * functions provided by the SDK to help you set up this guard.\n * Here is an example.\n *\n * ```ts\n * import { getMerkleProof, getMerkleRoot } from '@metaplex-foundation/js';\n * const allowList = [\n *   'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',\n *   'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',\n *   'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',\n * ];\n * const merkleRoot = getMerkleRoot(allowList);\n * const validMerkleProof = getMerkleProof(allowList, 'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB');\n * const invalidMerkleProof = getMerkleProof(allowList, 'invalid-address');\n * ```\n *\n * Note that you will need to provide the Merkle Proof for the\n * minting wallet before calling the mint instruction via the\n * special \"route\" instruction of the guard.\n * See {@link AllowListGuardRouteSettings} for more information.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link AllowListGuardRouteSettings} to learn more about\n * the instructions that can be executed against this guard.\n */\n\n/** @internal */\n\nconst allowListGuardManifest = {\n  name: 'allowList',\n  settingsBytes: 32,\n  settingsSerializer: mapSerializer(createSerializerFromBeet(allowListBeet), settings => ({\n    merkleRoot: new Uint8Array(settings.merkleRoot)\n  }), settings => ({\n    merkleRoot: Array.from(settings.merkleRoot)\n  })),\n  mintSettingsParser: _ref => {\n    let {\n      metaplex,\n      settings,\n      payer,\n      candyMachine,\n      candyGuard\n    } = _ref;\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [{\n        isSigner: false,\n        isWritable: false,\n        address: metaplex.candyMachines().pdas().merkleProof({\n          merkleRoot: settings.merkleRoot,\n          user: payer.publicKey,\n          candyMachine,\n          candyGuard\n        })\n      }]\n    };\n  },\n  routeSettingsParser: _ref2 => {\n    let {\n      metaplex,\n      settings,\n      routeSettings,\n      programs,\n      candyMachine,\n      candyGuard,\n      payer\n    } = _ref2;\n    const proof = routeSettings.merkleProof;\n    const vectorSize = Buffer.alloc(4);\n    beet.u32.write(vectorSize, 0, proof.length);\n    return {\n      arguments: Buffer.concat([vectorSize, ...proof]),\n      remainingAccounts: [{\n        isSigner: false,\n        isWritable: true,\n        address: metaplex.candyMachines().pdas().merkleProof({\n          merkleRoot: settings.merkleRoot,\n          user: payer.publicKey,\n          candyMachine,\n          candyGuard\n        })\n      }, {\n        isSigner: false,\n        isWritable: false,\n        address: metaplex.programs().getSystem(programs).address\n      }]\n    };\n  }\n};\nexport { allowListGuardManifest };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineModule/guards/allowList.ts"],"names":["allowListGuardManifest","name","settingsBytes","settingsSerializer","mapSerializer","createSerializerFromBeet","allowListBeet","settings","merkleRoot","Uint8Array","Array","from","mintSettingsParser","metaplex","payer","candyMachine","candyGuard","arguments","Buffer","remainingAccounts","isSigner","isWritable","address","candyMachines","pdas","merkleProof","user","publicKey","routeSettingsParser","routeSettings","programs","proof","vectorSize","alloc","beet","u32","write","length","concat","getSystem"],"mappings":";;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA+CA;;AACO,MAAMA,sBAIZ,GAAG;EACFC,IAAI,EAAE,WADJ;EAEFC,aAAa,EAAE,EAFb;EAGFC,kBAAkB,EAAEC,aAAa,CAC/BC,wBAAwB,CAACC,aAAD,CADO,EAE9BC,QAAQ,KAAM;IAAEC,UAAU,EAAE,IAAIC,UAAJ,CAAeF,QAAQ,CAACC,UAAxB;EAAd,CAAN,CAFsB,EAG9BD,QAAQ,KAAM;IAAEC,UAAU,EAAEE,KAAK,CAACC,IAAND,CAAWH,QAAQ,CAACC,UAApBE;EAAd,CAAN,CAHsB,CAH/B;EAQFE,kBAAkB,EAAE,QAMd;IAAA,IANe;MACnBC,QADmB;MAEnBN,QAFmB;MAGnBO,KAHmB;MAInBC,YAJmB;MAKnBC;IALmB,CAMf;IACJ,OAAO;MACLC,SAAS,EAAEC,MAAM,CAACP,IAAPO,CAAY,EAAZA,CADN;MAELC,iBAAiB,EAAE,CACjB;QACEC,QAAQ,EAAE,KADZ;QAEEC,UAAU,EAAE,KAFd;QAGEC,OAAO,EAAET,QAAQ,CAACU,aAATV,GAAyBW,IAAzBX,GAAgCY,WAAhCZ,CAA4C;UACnDL,UAAU,EAAED,QAAQ,CAACC,UAD8B;UAEnDkB,IAAI,EAAEZ,KAAK,CAACa,SAFuC;UAGnDZ,YAHmD;UAInDC;QAJmD,CAA5CH;MAHX,CADiB;IAFd,CAAP;EAeD,CA9BC;EA+BFe,mBAAmB,EAAE,SAQf;IAAA,IARgB;MACpBf,QADoB;MAEpBN,QAFoB;MAGpBsB,aAHoB;MAIpBC,QAJoB;MAKpBf,YALoB;MAMpBC,UANoB;MAOpBF;IAPoB,CAQhB;IACJ,MAAMiB,KAAK,GAAGF,aAAa,CAACJ,WAA5B;IACA,MAAMO,UAAU,GAAGd,MAAM,CAACe,KAAPf,CAAa,CAAbA,CAAnB;IACAgB,IAAI,CAACC,GAALD,CAASE,KAATF,CAAeF,UAAfE,EAA2B,CAA3BA,EAA8BH,KAAK,CAACM,MAApCH;IAEA,OAAO;MACLjB,SAAS,EAAEC,MAAM,CAACoB,MAAPpB,CAAc,CAACc,UAAD,EAAa,GAAGD,KAAhB,CAAdb,CADN;MAELC,iBAAiB,EAAE,CACjB;QACEC,QAAQ,EAAE,KADZ;QAEEC,UAAU,EAAE,IAFd;QAGEC,OAAO,EAAET,QAAQ,CAACU,aAATV,GAAyBW,IAAzBX,GAAgCY,WAAhCZ,CAA4C;UACnDL,UAAU,EAAED,QAAQ,CAACC,UAD8B;UAEnDkB,IAAI,EAAEZ,KAAK,CAACa,SAFuC;UAGnDZ,YAHmD;UAInDC;QAJmD,CAA5CH;MAHX,CADiB,EAWjB;QACEO,QAAQ,EAAE,KADZ;QAEEC,UAAU,EAAE,KAFd;QAGEC,OAAO,EAAET,QAAQ,CAACiB,QAATjB,GAAoB0B,SAApB1B,CAA8BiB,QAA9BjB,EAAwCS;MAHnD,CAXiB;IAFd,CAAP;EAoBF;AAhEE,CAJG","sourcesContent":["import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport { AllowList, allowListBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet, mapSerializer } from '@/types';\n\n/**\n * The allowList guard validates the minting wallet against\n * a predefined list of wallets.\n *\n * Instead of passing the entire list of wallets as settings,\n * this guard accepts the Root of a Merkle Tree created from\n * this allow list. The program can then validate that the minting\n * wallet is part of the allow list by requiring a Merkle Proof.\n * Minting will fail if either the minting address is not part of\n * the merkle tree or if no Merkle Proof is specified.\n *\n * You may use the `getMerkleRoot` and `getMerkleProof` helper\n * functions provided by the SDK to help you set up this guard.\n * Here is an example.\n *\n * ```ts\n * import { getMerkleProof, getMerkleRoot } from '@metaplex-foundation/js';\n * const allowList = [\n *   'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',\n *   'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',\n *   'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',\n * ];\n * const merkleRoot = getMerkleRoot(allowList);\n * const validMerkleProof = getMerkleProof(allowList, 'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB');\n * const invalidMerkleProof = getMerkleProof(allowList, 'invalid-address');\n * ```\n *\n * Note that you will need to provide the Merkle Proof for the\n * minting wallet before calling the mint instruction via the\n * special \"route\" instruction of the guard.\n * See {@link AllowListGuardRouteSettings} for more information.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link AllowListGuardRouteSettings} to learn more about\n * the instructions that can be executed against this guard.\n */\nexport type AllowListGuardSettings = {\n  /**\n   * The Root of the Merkle Tree representing the allow list.\n   * You may use the `getMerkleRoot` helper function to generate this.\n   */\n  merkleRoot: Uint8Array;\n};\n\n/**\n * The settings for the allowList guard that should be provided\n * when accessing the guard's special \"route\" instruction.\n *\n * ## Proof\n * The `proof` path allows you to provide a Merkle Proof\n * for a specific wallet in order to allow minting for that wallet.\n * This will create a small PDA account on the Program as a proof\n * that the wallet has been allowed to mint.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'allowList',\n *   settings: {\n *     path: 'proof',\n *     merkleProof: getMerkleProof(allowedWallets, metaplex.identity().publicKey.toBase58()),\n *   },\n * });\n *\n * // You are now allows to mint with this wallet.\n * ```\n *\n * @see {@link AllowListGuardSettings} for more\n * information on the allowList guard itself.\n */\nexport type AllowListGuardRouteSettings = {\n  /** Selects the path to execute in the route instruction. */\n  path: 'proof';\n\n  /**\n   * The Proof that the minting wallet is part of the\n   * Merkle Tree-based allow list. You may use the\n   * `getMerkleProof` helper function to generate this.\n   */\n  merkleProof: Uint8Array[];\n};\n\n/** @internal */\nexport const allowListGuardManifest: CandyGuardManifest<\n  AllowListGuardSettings,\n  {},\n  AllowListGuardRouteSettings\n> = {\n  name: 'allowList',\n  settingsBytes: 32,\n  settingsSerializer: mapSerializer<AllowList, AllowListGuardSettings>(\n    createSerializerFromBeet(allowListBeet),\n    (settings) => ({ merkleRoot: new Uint8Array(settings.merkleRoot) }),\n    (settings) => ({ merkleRoot: Array.from(settings.merkleRoot) })\n  ),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    payer,\n    candyMachine,\n    candyGuard,\n  }) => {\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          isWritable: false,\n          address: metaplex.candyMachines().pdas().merkleProof({\n            merkleRoot: settings.merkleRoot,\n            user: payer.publicKey,\n            candyMachine,\n            candyGuard,\n          }),\n        },\n      ],\n    };\n  },\n  routeSettingsParser: ({\n    metaplex,\n    settings,\n    routeSettings,\n    programs,\n    candyMachine,\n    candyGuard,\n    payer,\n  }) => {\n    const proof = routeSettings.merkleProof;\n    const vectorSize = Buffer.alloc(4);\n    beet.u32.write(vectorSize, 0, proof.length);\n\n    return {\n      arguments: Buffer.concat([vectorSize, ...proof]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          isWritable: true,\n          address: metaplex.candyMachines().pdas().merkleProof({\n            merkleRoot: settings.merkleRoot,\n            user: payer.publicKey,\n            candyMachine,\n            candyGuard,\n          }),\n        },\n        {\n          isSigner: false,\n          isWritable: false,\n          address: metaplex.programs().getSystem(programs).address,\n        },\n      ],\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"module"}