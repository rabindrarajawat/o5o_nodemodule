{"ast":null,"code":"import { createMintInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport { createMintInstruction as createMintInstruction$1 } from '@metaplex-foundation/mpl-candy-machine-core';\nimport { Keypair, SYSVAR_SLOT_HASHES_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { CandyMachineBotTaxError } from '../errors.mjs';\nimport { makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { token } from '../../../types/Amount.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'MintFromCandyMachineOperation';\n/**\n * Mints the next NFT from a given candy machine.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .candyMachines()\n *   .mint({\n *     candyMachine,\n *     collectionUpdateAuthority,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst mintFromCandyMachineOperation = _mintFromCandyMachineOperation; // eslint-disable-next-line @typescript-eslint/naming-convention\n\nfunction _mintFromCandyMachineOperation(input) {\n  return {\n    key: Key,\n    input\n  };\n}\n\n_mintFromCandyMachineOperation.key = Key;\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst mintFromCandyMachineOperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const builder = await mintFromCandyMachineBuilder(metaplex, operation.input, scope);\n    scope.throwIfCanceled();\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n    let nft;\n\n    try {\n      nft = await metaplex.nfts().findByMint({\n        mintAddress: output.mintSigner.publicKey,\n        tokenAddress: output.tokenAddress\n      }, scope);\n    } catch (error) {\n      const {\n        candyGuard\n      } = operation.input.candyMachine;\n\n      if (!candyGuard) {\n        throw error;\n      }\n\n      const activeGuards = metaplex.candyMachines().guards().resolveGroupSettings(candyGuard.guards, candyGuard.groups, operation.input.group ?? null);\n\n      if (!('botTax' in activeGuards)) {\n        throw error;\n      }\n\n      throw new CandyMachineBotTaxError(metaplex.rpc().getSolanaExporerUrl(output.response.signature), error);\n    }\n\n    return {\n      nft,\n      ...output\n    };\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Mints the next NFT from a given candy machine.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .mint({\n *     candyMachine,\n *     collectionUpdateAuthority,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst mintFromCandyMachineBuilder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    candyMachine,\n    collectionUpdateAuthority,\n    mintAuthority = metaplex.identity(),\n    mint = Keypair.generate(),\n    owner = payer.publicKey,\n    group = null,\n    guards = {},\n    token: token$1\n  } = params; // Programs.\n\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const systemProgram = metaplex.programs().getSystem(programs); // PDAs.\n\n  const authorityPda = metaplex.candyMachines().pdas().authority({\n    candyMachine: candyMachine.address,\n    programs\n  });\n  const nftMetadata = metaplex.nfts().pdas().metadata({\n    mint: mint.publicKey,\n    programs\n  });\n  const nftMasterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: mint.publicKey,\n    programs\n  });\n  const collectionMetadata = metaplex.nfts().pdas().metadata({\n    mint: candyMachine.collectionMintAddress,\n    programs\n  });\n  const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: candyMachine.collectionMintAddress,\n    programs\n  });\n  const collectionAuthorityRecord = metaplex.nfts().pdas().collectionAuthorityRecord({\n    mint: candyMachine.collectionMintAddress,\n    collectionAuthority: authorityPda,\n    programs\n  }); // Transaction Builder that prepares the mint and token accounts.\n\n  const tokenWithMintBuilder = await metaplex.tokens().builders().createTokenWithMint({\n    decimals: 0,\n    initialSupply: token(1),\n    mint,\n    mintAuthority: payer,\n    freezeAuthority: payer.publicKey,\n    owner,\n    token: token$1,\n    createMintAccountInstructionKey: params.createMintAccountInstructionKey,\n    initializeMintInstructionKey: params.initializeMintInstructionKey,\n    createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey,\n    createTokenAccountInstructionKey: params.createTokenAccountInstructionKey,\n    initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n    mintTokensInstructionKey: params.mintTokensInstructionKey\n  }, {\n    payer,\n    programs\n  });\n  const {\n    tokenAddress\n  } = tokenWithMintBuilder.getContext(); // Shared mint accounts\n\n  const sharedMintAccounts = {\n    candyMachine: candyMachine.address,\n    payer: payer.publicKey,\n    nftMetadata,\n    nftMint: mint.publicKey,\n    nftMintAuthority: payer.publicKey,\n    nftMasterEdition,\n    collectionAuthorityRecord,\n    collectionMint: candyMachine.collectionMintAddress,\n    collectionMetadata,\n    collectionMasterEdition,\n    collectionUpdateAuthority,\n    candyMachineProgram: candyMachineProgram.address,\n    tokenMetadataProgram: tokenMetadataProgram.address,\n    tokenProgram: tokenProgram.address,\n    systemProgram: systemProgram.address,\n    recentSlothashes: SYSVAR_SLOT_HASHES_PUBKEY,\n    instructionSysvarAccount: SYSVAR_INSTRUCTIONS_PUBKEY\n  }; // Mint instruction.\n\n  let mintNftInstruction;\n  let mintNftSigners;\n\n  if (!!candyMachine.candyGuard) {\n    const {\n      candyGuard\n    } = candyMachine;\n    const guardClient = metaplex.candyMachines().guards();\n    const parsedMintSettings = guardClient.parseMintSettings(candyMachine.address, candyGuard, owner, payer, mint, guards, group, programs);\n    mintNftSigners = [payer, mint, ...parsedMintSettings.signers];\n    mintNftInstruction = createMintInstruction({ ...sharedMintAccounts,\n      candyGuard: candyMachine.candyGuard.address,\n      candyMachineAuthorityPda: authorityPda\n    }, {\n      mintArgs: parsedMintSettings.arguments,\n      label: group\n    }, candyGuardProgram.address);\n    mintNftInstruction.keys.push(...parsedMintSettings.accountMetas);\n  } else {\n    mintNftSigners = [payer, mint, mintAuthority];\n    mintNftInstruction = createMintInstruction$1({ ...sharedMintAccounts,\n      authorityPda,\n      mintAuthority: mintAuthority.publicKey\n    }, candyMachineProgram.address);\n  }\n\n  return TransactionBuilder.make().setFeePayer(payer).setContext({\n    tokenAddress,\n    mintSigner: mint\n  }) // Create token and mint accounts.\n  .add(tokenWithMintBuilder) // Mint the new NFT.\n  .add({\n    instruction: mintNftInstruction,\n    signers: mintNftSigners,\n    key: params.mintFromCandyMachineInstructionKey ?? 'mintNft'\n  });\n};\n\nexport { mintFromCandyMachineBuilder, mintFromCandyMachineOperation, mintFromCandyMachineOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/candyMachineModule/operations/mintFromCandyMachine.ts"],"names":["Key","mintFromCandyMachineOperation","_mintFromCandyMachineOperation","input","key","mintFromCandyMachineOperationHandler","handle","operation","metaplex","scope","builder","mintFromCandyMachineBuilder","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","nft","nfts","findByMint","mintAddress","mintSigner","publicKey","tokenAddress","error","candyGuard","candyMachine","activeGuards","candyMachines","guards","resolveGroupSettings","groups","group","CandyMachineBotTaxError","rpc","getSolanaExporerUrl","response","signature","params","options","programs","payer","getDefaultFeePayer","collectionUpdateAuthority","mintAuthority","identity","mint","Keypair","generate","owner","token","candyMachineProgram","getCandyMachine","candyGuardProgram","getCandyGuard","tokenMetadataProgram","getTokenMetadata","tokenProgram","getToken","systemProgram","getSystem","authorityPda","pdas","authority","address","nftMetadata","metadata","nftMasterEdition","masterEdition","collectionMetadata","collectionMintAddress","collectionMasterEdition","collectionAuthorityRecord","collectionAuthority","tokenWithMintBuilder","tokens","builders","createTokenWithMint","decimals","initialSupply","tokenAmount","freezeAuthority","createMintAccountInstructionKey","initializeMintInstructionKey","createAssociatedTokenAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","mintTokensInstructionKey","getContext","sharedMintAccounts","nftMint","nftMintAuthority","collectionMint","recentSlothashes","SYSVAR_SLOT_HASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","mintNftInstruction","mintNftSigners","guardClient","parsedMintSettings","parseMintSettings","signers","createMintFromGuardInstruction","candyMachineAuthorityPda","mintArgs","arguments","label","keys","push","accountMetas","createMintFromMachineInstruction","TransactionBuilder","make","setFeePayer","setContext","add","instruction","mintFromCandyMachineInstructionKey"],"mappings":"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","sourcesContent":["import { createMintInstruction as createMintFromGuardInstruction } from '@metaplex-foundation/mpl-candy-guard';\nimport { createMintInstruction as createMintFromMachineInstruction } from '@metaplex-foundation/mpl-candy-machine-core';\nimport {\n  Keypair,\n  SYSVAR_INSTRUCTIONS_PUBKEY,\n  SYSVAR_SLOT_HASHES_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { CandyMachineBotTaxError } from '../errors';\nimport {\n  CandyGuardsMintSettings,\n  CandyGuardsSettings,\n  DefaultCandyGuardMintSettings,\n  DefaultCandyGuardSettings,\n} from '../guards';\nimport { CandyMachine } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n  Signer,\n  token as tokenAmount,\n} from '@/types';\nimport { NftWithToken } from '@/plugins/nftModule';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'MintFromCandyMachineOperation' as const;\n\n/**\n * Mints the next NFT from a given candy machine.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .candyMachines()\n *   .mint({\n *     candyMachine,\n *     collectionUpdateAuthority,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const mintFromCandyMachineOperation = _mintFromCandyMachineOperation;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _mintFromCandyMachineOperation<\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n>(\n  input: MintFromCandyMachineInput<Settings, MintSettings>\n): MintFromCandyMachineOperation<Settings, MintSettings> {\n  return { key: Key, input };\n}\n_mintFromCandyMachineOperation.key = Key;\n\n/**\n * @group Operations\n * @category Types\n */\nexport type MintFromCandyMachineOperation<\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n> = Operation<\n  typeof Key,\n  MintFromCandyMachineInput<Settings, MintSettings>,\n  MintFromCandyMachineOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type MintFromCandyMachineInput<\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n> = {\n  /**\n   * The Candy Machine to mint from.\n   * We only need a subset of the `CandyMachine` model but we\n   * need enough information regarding its settings to know how\n   * to mint from it.\n   *\n   * This includes its address, the address of its Collection NFT and,\n   * optionally, the Candy Guard account associated with it.\n   */\n  candyMachine: Pick<\n    CandyMachine<Settings>,\n    'address' | 'collectionMintAddress' | 'candyGuard'\n  >;\n\n  /**\n   * The address of the update authority of the Collection NFT\n   * that is being assigned to each minted NFT.\n   */\n  collectionUpdateAuthority: PublicKey;\n\n  /**\n   * The authority that is allowed to mint NFTs from the Candy Machine.\n   *\n   * @defaultValue\n   * `metaplex.identity()` if the Candy Machine has no associated Candy Guard.\n   * Otherwise, this parameter will be ignored.\n   */\n  mintAuthority?: Signer;\n\n  /**\n   * The mint account to create as a Signer.\n   * This expects a brand new Keypair with no associated account.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  mint?: Signer;\n\n  /**\n   * The owner of the minted NFT.\n   *\n   * Defaults to the wallet that is paying for it, i.e. `payer`.\n   *\n   * @defaultValue `payer.publicKey`\n   */\n  owner?: PublicKey;\n\n  /**\n   * The new token account to create as a Signer.\n   *\n   * This property would typically be ignored as, by default, it will create a\n   * associated token account from the `owner` and `mint` properties.\n   *\n   * When provided, the `owner` property will be ignored.\n   *\n   * @defaultValue associated token address of `owner` and `mint`.\n   */\n  token?: Signer;\n\n  /**\n   * The label of the group to mint from.\n   *\n   * If groups are configured on the Candy Machine,\n   * you must specify a group label to mint from.\n   *\n   * When set to `null` it will mint using the default\n   * guards, provided no groups are configured.\n   *\n   * @defaultValue `null`\n   */\n  group?: Option<string>;\n\n  /**\n   * Guard-specific data required to mint from the Candy Machine.\n   *\n   * Some guards require additional data to be provided at mint time.\n   * For instance, the `allowList` guard will require a Merkle proof\n   * ensuring the minting address is allowed to mint.\n   *\n   * You only need to provide configuration data for the guards\n   * that are set up within the group your are minting from.\n   *\n   * @defaultValue `{}`\n   */\n  guards?: Partial<MintSettings>;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type MintFromCandyMachineOutput = {\n  /** The minted NFT. */\n  nft: NftWithToken;\n\n  /** The mint account of the minted NFT as a Signer. */\n  mintSigner: Signer;\n\n  /** The address of the minted NFT's token account. */\n  tokenAddress: PublicKey;\n\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const mintFromCandyMachineOperationHandler: OperationHandler<MintFromCandyMachineOperation> =\n  {\n    async handle<\n      Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n      MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n    >(\n      operation: MintFromCandyMachineOperation<Settings, MintSettings>,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<MintFromCandyMachineOutput> {\n      const builder = await mintFromCandyMachineBuilder<Settings, MintSettings>(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      let nft: NftWithToken;\n      try {\n        nft = (await metaplex.nfts().findByMint(\n          {\n            mintAddress: output.mintSigner.publicKey,\n            tokenAddress: output.tokenAddress,\n          },\n          scope\n        )) as NftWithToken;\n      } catch (error) {\n        const { candyGuard } = operation.input.candyMachine;\n        if (!candyGuard) {\n          throw error;\n        }\n\n        const activeGuards = metaplex\n          .candyMachines()\n          .guards()\n          .resolveGroupSettings(\n            candyGuard.guards,\n            candyGuard.groups,\n            operation.input.group ?? null\n          );\n\n        if (!('botTax' in activeGuards)) {\n          throw error;\n        }\n\n        throw new CandyMachineBotTaxError(\n          metaplex.rpc().getSolanaExporerUrl(output.response.signature),\n          error as Error\n        );\n      }\n\n      return { nft, ...output };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type MintFromCandyMachineBuilderParams<\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n> = Omit<\n  MintFromCandyMachineInput<Settings, MintSettings>,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the mint account of the NFT. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account of the NFT. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account of the NFT. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account of the NFT. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account of the NFT. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints the one token. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints from the Candy Machine. */\n  mintFromCandyMachineInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type MintFromCandyMachineBuilderContext = Omit<\n  MintFromCandyMachineOutput,\n  'response' | 'nft'\n>;\n\n/**\n * Mints the next NFT from a given candy machine.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .candyMachines()\n *   .builders()\n *   .mint({\n *     candyMachine,\n *     collectionUpdateAuthority,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const mintFromCandyMachineBuilder = async <\n  Settings extends CandyGuardsSettings = DefaultCandyGuardSettings,\n  MintSettings extends CandyGuardsMintSettings = DefaultCandyGuardMintSettings\n>(\n  metaplex: Metaplex,\n  params: MintFromCandyMachineBuilderParams<Settings, MintSettings>,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<MintFromCandyMachineBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    candyMachine,\n    collectionUpdateAuthority,\n    mintAuthority = metaplex.identity(),\n    mint = Keypair.generate(),\n    owner = payer.publicKey,\n    group = null,\n    guards = {},\n    token,\n  } = params;\n\n  // Programs.\n  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);\n  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  // PDAs.\n  const authorityPda = metaplex.candyMachines().pdas().authority({\n    candyMachine: candyMachine.address,\n    programs,\n  });\n  const nftMetadata = metaplex.nfts().pdas().metadata({\n    mint: mint.publicKey,\n    programs,\n  });\n  const nftMasterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: mint.publicKey,\n    programs,\n  });\n  const collectionMetadata = metaplex.nfts().pdas().metadata({\n    mint: candyMachine.collectionMintAddress,\n    programs,\n  });\n  const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: candyMachine.collectionMintAddress,\n    programs,\n  });\n  const collectionAuthorityRecord = metaplex\n    .nfts()\n    .pdas()\n    .collectionAuthorityRecord({\n      mint: candyMachine.collectionMintAddress,\n      collectionAuthority: authorityPda,\n      programs,\n    });\n\n  // Transaction Builder that prepares the mint and token accounts.\n  const tokenWithMintBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createTokenWithMint(\n      {\n        decimals: 0,\n        initialSupply: tokenAmount(1),\n        mint,\n        mintAuthority: payer,\n        freezeAuthority: payer.publicKey,\n        owner,\n        token,\n        createMintAccountInstructionKey: params.createMintAccountInstructionKey,\n        initializeMintInstructionKey: params.initializeMintInstructionKey,\n        createAssociatedTokenAccountInstructionKey:\n          params.createAssociatedTokenAccountInstructionKey,\n        createTokenAccountInstructionKey:\n          params.createTokenAccountInstructionKey,\n        initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n        mintTokensInstructionKey: params.mintTokensInstructionKey,\n      },\n      { payer, programs }\n    );\n  const { tokenAddress } = tokenWithMintBuilder.getContext();\n\n  // Shared mint accounts\n  const sharedMintAccounts = {\n    candyMachine: candyMachine.address,\n    payer: payer.publicKey,\n    nftMetadata,\n    nftMint: mint.publicKey,\n    nftMintAuthority: payer.publicKey,\n    nftMasterEdition,\n    collectionAuthorityRecord,\n    collectionMint: candyMachine.collectionMintAddress,\n    collectionMetadata,\n    collectionMasterEdition,\n    collectionUpdateAuthority,\n    candyMachineProgram: candyMachineProgram.address,\n    tokenMetadataProgram: tokenMetadataProgram.address,\n    tokenProgram: tokenProgram.address,\n    systemProgram: systemProgram.address,\n    recentSlothashes: SYSVAR_SLOT_HASHES_PUBKEY,\n    instructionSysvarAccount: SYSVAR_INSTRUCTIONS_PUBKEY,\n  };\n\n  // Mint instruction.\n  let mintNftInstruction: TransactionInstruction;\n  let mintNftSigners: Signer[];\n  if (!!candyMachine.candyGuard) {\n    const { candyGuard } = candyMachine;\n    const guardClient = metaplex.candyMachines().guards();\n    const parsedMintSettings = guardClient.parseMintSettings(\n      candyMachine.address,\n      candyGuard,\n      owner,\n      payer,\n      mint,\n      guards,\n      group,\n      programs\n    );\n\n    mintNftSigners = [payer, mint, ...parsedMintSettings.signers];\n    mintNftInstruction = createMintFromGuardInstruction(\n      {\n        ...sharedMintAccounts,\n        candyGuard: candyMachine.candyGuard.address,\n        candyMachineAuthorityPda: authorityPda,\n      },\n      {\n        mintArgs: parsedMintSettings.arguments,\n        label: group,\n      },\n      candyGuardProgram.address\n    );\n    mintNftInstruction.keys.push(...parsedMintSettings.accountMetas);\n  } else {\n    mintNftSigners = [payer, mint, mintAuthority];\n    mintNftInstruction = createMintFromMachineInstruction(\n      {\n        ...sharedMintAccounts,\n        authorityPda,\n        mintAuthority: mintAuthority.publicKey,\n      },\n      candyMachineProgram.address\n    );\n  }\n\n  return (\n    TransactionBuilder.make<MintFromCandyMachineBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({ tokenAddress, mintSigner: mint })\n\n      // Create token and mint accounts.\n      .add(tokenWithMintBuilder)\n\n      // Mint the new NFT.\n      .add({\n        instruction: mintNftInstruction,\n        signers: mintNftSigners,\n        key: params.mintFromCandyMachineInstructionKey ?? 'mintNft',\n      })\n  );\n};\n"]},"metadata":{},"sourceType":"module"}