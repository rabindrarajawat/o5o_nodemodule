{"ast":null,"code":"import mime from 'mime'; // eslint-disable-next-line no-control-regex\n\nconst removeEmptyChars = value => value.replace(/\\u0000/g, '');\n\nconst padEmptyChars = (value, chars) => value.padEnd(chars, '\\u0000');\n\nconst tryOr = (callback, defaultValue) => {\n  try {\n    return callback();\n  } catch (error) {\n    return defaultValue;\n  }\n};\n\nconst tryOrNull = cb => tryOr(cb, null);\n\nconst chunk = (array, chunkSize) => array.reduce((accumulator, item, index) => {\n  const chunkIndex = Math.floor(index / chunkSize);\n\n  if (!accumulator[chunkIndex]) {\n    accumulator[chunkIndex] = [];\n  }\n\n  accumulator[chunkIndex].push(item);\n  return accumulator;\n}, []);\n\nconst zipMap = (left, right, fn) => left.map((t, index) => fn(t, right?.[index] ?? null, index));\n\nconst randomStr = function () {\n  let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;\n  let alphabet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let result = '';\n  const alphabetLength = alphabet.length;\n\n  for (var i = 0; i < length; i++) {\n    result += alphabet.charAt(Math.floor(Math.random() * alphabetLength));\n  }\n\n  return result;\n};\n\nconst getContentType = fileName => mime.getType(fileName);\n\nconst getExtension = fileName => {\n  const lastDotIndex = fileName.lastIndexOf('.');\n  return lastDotIndex < 0 ? null : fileName.slice(lastDotIndex + 1);\n};\n\nconst walk = (parent, cb, options) => {\n  const recursiveWalk = child => walk(child, cb, options);\n\n  if (parent && Array.isArray(parent)) {\n    parent.forEach((child, index) => {\n      cb(recursiveWalk, child, index, parent);\n    });\n  } else if (parent && typeof parent === 'object') {\n    const keys = Object.keys(parent);\n\n    if (options?.sortObjectKeys ?? true) {\n      keys.sort();\n    }\n\n    keys.forEach(key => {\n      const child = parent[key];\n      cb(recursiveWalk, child, key, parent);\n    });\n  }\n};\n\nconst removeUndefinedAttributes = object => Object.keys(object).reduce((acc, key) => {\n  if (object[key] !== undefined) {\n    acc[key] = object[key];\n  }\n\n  return acc;\n}, {});\n\nexport { chunk, getContentType, getExtension, padEmptyChars, randomStr, removeEmptyChars, removeUndefinedAttributes, tryOr, tryOrNull, walk, zipMap };","map":{"version":3,"sources":["../../../src/utils/common.ts"],"names":["removeEmptyChars","value","replace","padEmptyChars","chars","padEnd","tryOr","callback","defaultValue","error","tryOrNull","cb","chunk","array","chunkSize","reduce","accumulator","item","index","chunkIndex","Math","floor","push","zipMap","left","right","fn","map","t","randomStr","length","alphabet","result","alphabetLength","i","charAt","random","getContentType","fileName","mime","getType","getExtension","lastDotIndex","lastIndexOf","slice","walk","parent","options","recursiveWalk","child","Array","isArray","forEach","keys","Object","sortObjectKeys","sort","key","removeUndefinedAttributes","object","acc","undefined"],"mappings":"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","sourcesContent":["import mime from 'mime';\n\n// eslint-disable-next-line no-control-regex\nexport const removeEmptyChars = (value: string) => value.replace(/\\u0000/g, '');\n\nexport const padEmptyChars = (value: string, chars: number) =>\n  value.padEnd(chars, '\\u0000');\n\nexport const tryOr = <T, U>(callback: () => T, defaultValue: U): T | U => {\n  try {\n    return callback();\n  } catch (error) {\n    return defaultValue;\n  }\n};\n\nexport const tryOrNull = <T>(cb: () => T) => tryOr(cb, null);\n\nexport const chunk = <T>(array: T[], chunkSize: number): T[][] =>\n  array.reduce((accumulator, item, index) => {\n    const chunkIndex = Math.floor(index / chunkSize);\n\n    if (!accumulator[chunkIndex]) {\n      accumulator[chunkIndex] = [];\n    }\n\n    accumulator[chunkIndex].push(item);\n\n    return accumulator;\n  }, [] as T[][]);\n\nexport const zipMap = <T, U, V>(\n  left: T[],\n  right: U[],\n  fn: (t: T, u: U | null, i: number) => V\n): V[] => left.map((t: T, index) => fn(t, right?.[index] ?? null, index));\n\nexport const randomStr = (\n  length = 20,\n  alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n) => {\n  let result = '';\n  const alphabetLength = alphabet.length;\n  for (var i = 0; i < length; i++) {\n    result += alphabet.charAt(Math.floor(Math.random() * alphabetLength));\n  }\n\n  return result;\n};\n\nexport const getContentType = (fileName: string): string | null =>\n  mime.getType(fileName);\n\nexport const getExtension = (fileName: string): string | null => {\n  const lastDotIndex = fileName.lastIndexOf('.');\n\n  return lastDotIndex < 0 ? null : fileName.slice(lastDotIndex + 1);\n};\n\nexport type WalkOptions = {\n  sortObjectKeys?: boolean;\n};\n\nexport const walk = (\n  parent: any,\n  cb: (\n    next: (child: any) => void,\n    value: any,\n    key: any,\n    parent: any\n  ) => unknown,\n  options?: WalkOptions\n): void => {\n  const recursiveWalk = (child: any) => walk(child, cb, options);\n\n  if (parent && Array.isArray(parent)) {\n    parent.forEach((child, index) => {\n      cb(recursiveWalk, child, index, parent);\n    });\n  } else if (parent && typeof parent === 'object') {\n    const keys = Object.keys(parent);\n\n    if (options?.sortObjectKeys ?? true) {\n      keys.sort();\n    }\n\n    keys.forEach((key) => {\n      const child = parent[key];\n      cb(recursiveWalk, child, key, parent);\n    });\n  }\n};\n\nexport const removeUndefinedAttributes = <\n  T extends {\n    [key: string]: any;\n  }\n>(\n  object: T\n): { [key in keyof T]-?: T[key] } =>\n  Object.keys(object).reduce((acc, key: keyof T) => {\n    if (object[key] !== undefined) {\n      acc[key] = object[key];\n    }\n    return acc;\n  }, {} as { [key in keyof T]-?: T[key] });\n"]},"metadata":{},"sourceType":"module"}