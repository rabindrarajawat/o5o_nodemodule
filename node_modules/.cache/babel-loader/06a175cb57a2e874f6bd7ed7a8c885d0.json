{"ast":null,"code":"import { createMintNewEditionFromMasterEditionViaTokenInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair } from '@solana/web3.js';\nimport { toOriginalEditionAccount } from '../accounts.mjs';\nimport { toNftOriginalEdition } from '../models/NftEdition.mjs';\nimport { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { assertNftWithToken } from '../models/Nft.mjs';\nimport { toBigNumber } from '../../../types/BigNumber.mjs';\nimport { token } from '../../../types/Amount.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'PrintNewEditionOperation';\n/**\n * Prints a new edition from an original NFT.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .nfts()\n *   .printNewEdition({ originalMint };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst printNewEditionOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst printNewEditionOperationHandler = {\n  handle: async (operation, metaplex, scope) => {\n    const originalEditionAccount = await metaplex.rpc().getAccount(metaplex.nfts().pdas().masterEdition({\n      mint: operation.input.originalMint,\n      programs: scope.programs\n    }));\n    scope.throwIfCanceled();\n    const originalEdition = toNftOriginalEdition(toOriginalEditionAccount(originalEditionAccount));\n    const builder = await printNewEditionBuilder(metaplex, { ...operation.input,\n      originalSupply: originalEdition.supply\n    }, scope);\n    scope.throwIfCanceled();\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n    const nft = await metaplex.nfts().findByMint({\n      mintAddress: output.mintSigner.publicKey,\n      tokenAddress: output.tokenAddress\n    }, scope);\n    scope.throwIfCanceled();\n    assertNftWithToken(nft);\n    return { ...output,\n      nft\n    };\n  }\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Prints a new edition from an original NFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .printNewEdition({ originalMint });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst printNewEditionBuilder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    originalMint,\n    newMint = Keypair.generate(),\n    newUpdateAuthority = metaplex.identity().publicKey,\n    newOwner = metaplex.identity().publicKey,\n    newTokenAccount,\n    printNewEditionInstructionKey = 'printNewEdition'\n  } = params; // Programs.\n\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs); // Original NFT.\n\n  const originalMetadataAddress = metaplex.nfts().pdas().metadata({\n    mint: originalMint,\n    programs\n  });\n  const originalEditionAddress = metaplex.nfts().pdas().masterEdition({\n    mint: originalMint,\n    programs\n  });\n  const edition = toBigNumber(params.originalSupply.addn(1));\n  const originalEditionMarkPda = metaplex.nfts().pdas().editionMarker({\n    mint: originalMint,\n    edition,\n    programs\n  }); // New NFT.\n\n  const newMintAuthority = Keypair.generate(); // Will be overwritten by edition PDA.\n\n  const newMetadataAddress = metaplex.nfts().pdas().metadata({\n    mint: newMint.publicKey,\n    programs\n  });\n  const newEditionAddress = metaplex.nfts().pdas().edition({\n    mint: newMint.publicKey,\n    programs\n  });\n  const sharedAccounts = {\n    newMetadata: newMetadataAddress,\n    newEdition: newEditionAddress,\n    masterEdition: originalEditionAddress,\n    newMint: newMint.publicKey,\n    editionMarkPda: originalEditionMarkPda,\n    newMintAuthority: newMintAuthority.publicKey,\n    payer: payer.publicKey,\n    newMetadataUpdateAuthority: newUpdateAuthority,\n    metadata: originalMetadataAddress\n  };\n  const tokenWithMintBuilder = await metaplex.tokens().builders().createTokenWithMint({\n    decimals: 0,\n    initialSupply: token(1),\n    mint: newMint,\n    mintAuthority: newMintAuthority,\n    freezeAuthority: newMintAuthority.publicKey,\n    owner: newOwner,\n    token: newTokenAccount,\n    createMintAccountInstructionKey: params.createMintAccountInstructionKey,\n    initializeMintInstructionKey: params.initializeMintInstructionKey,\n    createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey,\n    createTokenAccountInstructionKey: params.createTokenAccountInstructionKey,\n    initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n    mintTokensInstructionKey: params.mintTokensInstructionKey\n  }, {\n    payer,\n    programs\n  });\n  const {\n    tokenAddress\n  } = tokenWithMintBuilder.getContext();\n  const originalTokenAccountOwner = params.originalTokenAccountOwner ?? metaplex.identity();\n  const originalTokenAccount = params.originalTokenAccount ?? metaplex.tokens().pdas().associatedTokenAccount({\n    mint: originalMint,\n    owner: originalTokenAccountOwner.publicKey,\n    programs\n  });\n  return TransactionBuilder.make().setFeePayer(payer).setContext({\n    mintSigner: newMint,\n    metadataAddress: newMetadataAddress,\n    editionAddress: newEditionAddress,\n    tokenAddress,\n    updatedSupply: edition\n  }) // Create the mint and token accounts before minting 1 token to the owner.\n  .add(tokenWithMintBuilder) // Mint new edition.\n  .add({\n    instruction: createMintNewEditionFromMasterEditionViaTokenInstruction({ ...sharedAccounts,\n      tokenAccountOwner: originalTokenAccountOwner.publicKey,\n      tokenAccount: originalTokenAccount\n    }, {\n      mintNewEditionFromMasterEditionViaTokenArgs: {\n        edition\n      }\n    }, tokenMetadataProgram.address),\n    signers: [newMint, newMintAuthority, payer, originalTokenAccountOwner],\n    key: printNewEditionInstructionKey\n  });\n};\n\nexport { printNewEditionBuilder, printNewEditionOperation, printNewEditionOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/nftModule/operations/printNewEdition.ts"],"names":["Key","printNewEditionOperation","useOperation","printNewEditionOperationHandler","handle","operation","metaplex","scope","originalEditionAccount","rpc","getAccount","nfts","pdas","masterEdition","mint","input","originalMint","programs","throwIfCanceled","originalEdition","toNftOriginalEdition","toOriginalEditionAccount","builder","printNewEditionBuilder","originalSupply","supply","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","nft","findByMint","mintAddress","mintSigner","publicKey","tokenAddress","assertNftWithToken","params","options","payer","getDefaultFeePayer","newMint","Keypair","generate","newUpdateAuthority","identity","newOwner","newTokenAccount","printNewEditionInstructionKey","tokenMetadataProgram","getTokenMetadata","originalMetadataAddress","metadata","originalEditionAddress","edition","toBigNumber","addn","originalEditionMarkPda","editionMarker","newMintAuthority","newMetadataAddress","newEditionAddress","sharedAccounts","newMetadata","newEdition","editionMarkPda","newMetadataUpdateAuthority","tokenWithMintBuilder","tokens","builders","createTokenWithMint","decimals","initialSupply","token","mintAuthority","freezeAuthority","owner","createMintAccountInstructionKey","initializeMintInstructionKey","createAssociatedTokenAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","mintTokensInstructionKey","getContext","originalTokenAccountOwner","originalTokenAccount","associatedTokenAccount","TransactionBuilder","make","setFeePayer","setContext","metadataAddress","editionAddress","updatedSupply","add","instruction","createMintNewEditionFromMasterEditionViaTokenInstruction","tokenAccountOwner","tokenAccount","mintNewEditionFromMasterEditionViaTokenArgs","address","signers","key"],"mappings":"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","sourcesContent":["import { createMintNewEditionFromMasterEditionViaTokenInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { toOriginalEditionAccount } from '../accounts';\nimport {\n  assertNftWithToken,\n  NftWithToken,\n  toNftOriginalEdition,\n} from '../models';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  BigNumber,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  toBigNumber,\n  token,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'PrintNewEditionOperation' as const;\n\n/**\n * Prints a new edition from an original NFT.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .nfts()\n *   .printNewEdition({ originalMint };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const printNewEditionOperation =\n  useOperation<PrintNewEditionOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type PrintNewEditionOperation = Operation<\n  typeof Key,\n  PrintNewEditionInput,\n  PrintNewEditionOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type PrintNewEditionInput = {\n  /** The address of the original NFT. */\n  originalMint: PublicKey;\n\n  /**\n   * The owner of the original NFT as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  originalTokenAccountOwner?: Signer;\n\n  /**\n   * The address of the original NFT's token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `originalMint` and `originalTokenAccountOwner` parameters.\n   */\n  originalTokenAccount?: PublicKey;\n\n  /**\n   * The address of the new mint account as a Signer.\n   * This is useful if you already have a generated Keypair\n   * for the mint account of the Print NFT to create.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  newMint?: Signer;\n\n  /**\n   * The update authority of the new printed NFT.\n   *\n   * Depending on your use-case, you might want to change that to\n   * the `updateAuthority` of the original NFT.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  newUpdateAuthority?: PublicKey;\n\n  /**\n   * The owner of the new printed NFT.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  newOwner?: PublicKey;\n\n  /**\n   * The address of the new printed NFT's token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `originalMint` and `newOwner` parameters.\n   */\n  newTokenAccount?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type PrintNewEditionOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created NFT and its associated token. */\n  nft: NftWithToken;\n\n  /** The created mint account as a Signer. */\n  mintSigner: Signer;\n\n  /** The address of the metadata account. */\n  metadataAddress: PublicKey;\n\n  /** The address of the edition account. */\n  editionAddress: PublicKey;\n\n  /** The address of the token account. */\n  tokenAddress: PublicKey;\n\n  /** The new supply of the original NFT. */\n  updatedSupply: BigNumber;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const printNewEditionOperationHandler: OperationHandler<PrintNewEditionOperation> =\n  {\n    handle: async (\n      operation: PrintNewEditionOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) => {\n      const originalEditionAccount = await metaplex.rpc().getAccount(\n        metaplex.nfts().pdas().masterEdition({\n          mint: operation.input.originalMint,\n          programs: scope.programs,\n        })\n      );\n      scope.throwIfCanceled();\n\n      const originalEdition = toNftOriginalEdition(\n        toOriginalEditionAccount(originalEditionAccount)\n      );\n      const builder = await printNewEditionBuilder(\n        metaplex,\n        { ...operation.input, originalSupply: originalEdition.supply },\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const nft = await metaplex.nfts().findByMint(\n        {\n          mintAddress: output.mintSigner.publicKey,\n          tokenAddress: output.tokenAddress,\n        },\n        scope\n      );\n      scope.throwIfCanceled();\n\n      assertNftWithToken(nft);\n      return { ...output, nft };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type PrintNewEditionBuilderParams = Omit<\n  PrintNewEditionInput,\n  'confirmOptions'\n> & {\n  /** The current supply of the original edition. */\n  originalSupply: BigNumber;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that prints the new edition. */\n  printNewEditionInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type PrintNewEditionBuilderContext = Omit<\n  PrintNewEditionOutput,\n  'response' | 'nft'\n>;\n\n/**\n * Prints a new edition from an original NFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .printNewEdition({ originalMint });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const printNewEditionBuilder = async (\n  metaplex: Metaplex,\n  params: PrintNewEditionBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<PrintNewEditionBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    originalMint,\n    newMint = Keypair.generate(),\n    newUpdateAuthority = metaplex.identity().publicKey,\n    newOwner = metaplex.identity().publicKey,\n    newTokenAccount,\n    printNewEditionInstructionKey = 'printNewEdition',\n  } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  // Original NFT.\n  const originalMetadataAddress = metaplex.nfts().pdas().metadata({\n    mint: originalMint,\n    programs,\n  });\n  const originalEditionAddress = metaplex.nfts().pdas().masterEdition({\n    mint: originalMint,\n    programs,\n  });\n  const edition = toBigNumber(params.originalSupply.addn(1));\n  const originalEditionMarkPda = metaplex.nfts().pdas().editionMarker({\n    mint: originalMint,\n    edition,\n    programs,\n  });\n\n  // New NFT.\n  const newMintAuthority = Keypair.generate(); // Will be overwritten by edition PDA.\n  const newMetadataAddress = metaplex.nfts().pdas().metadata({\n    mint: newMint.publicKey,\n    programs,\n  });\n  const newEditionAddress = metaplex.nfts().pdas().edition({\n    mint: newMint.publicKey,\n    programs,\n  });\n  const sharedAccounts = {\n    newMetadata: newMetadataAddress,\n    newEdition: newEditionAddress,\n    masterEdition: originalEditionAddress,\n    newMint: newMint.publicKey,\n    editionMarkPda: originalEditionMarkPda,\n    newMintAuthority: newMintAuthority.publicKey,\n    payer: payer.publicKey,\n    newMetadataUpdateAuthority: newUpdateAuthority,\n    metadata: originalMetadataAddress,\n  };\n\n  const tokenWithMintBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createTokenWithMint(\n      {\n        decimals: 0,\n        initialSupply: token(1),\n        mint: newMint,\n        mintAuthority: newMintAuthority,\n        freezeAuthority: newMintAuthority.publicKey,\n        owner: newOwner,\n        token: newTokenAccount,\n        createMintAccountInstructionKey: params.createMintAccountInstructionKey,\n        initializeMintInstructionKey: params.initializeMintInstructionKey,\n        createAssociatedTokenAccountInstructionKey:\n          params.createAssociatedTokenAccountInstructionKey,\n        createTokenAccountInstructionKey:\n          params.createTokenAccountInstructionKey,\n        initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n        mintTokensInstructionKey: params.mintTokensInstructionKey,\n      },\n      { payer, programs }\n    );\n\n  const { tokenAddress } = tokenWithMintBuilder.getContext();\n  const originalTokenAccountOwner =\n    params.originalTokenAccountOwner ?? metaplex.identity();\n  const originalTokenAccount =\n    params.originalTokenAccount ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: originalMint,\n      owner: originalTokenAccountOwner.publicKey,\n      programs,\n    });\n\n  return (\n    TransactionBuilder.make<PrintNewEditionBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintSigner: newMint,\n        metadataAddress: newMetadataAddress,\n        editionAddress: newEditionAddress,\n        tokenAddress,\n        updatedSupply: edition,\n      })\n\n      // Create the mint and token accounts before minting 1 token to the owner.\n      .add(tokenWithMintBuilder)\n\n      // Mint new edition.\n      .add({\n        instruction: createMintNewEditionFromMasterEditionViaTokenInstruction(\n          {\n            ...sharedAccounts,\n            tokenAccountOwner: originalTokenAccountOwner.publicKey,\n            tokenAccount: originalTokenAccount,\n          },\n          { mintNewEditionFromMasterEditionViaTokenArgs: { edition } },\n          tokenMetadataProgram.address\n        ),\n        signers: [newMint, newMintAuthority, payer, originalTokenAccountOwner],\n        key: printNewEditionInstructionKey,\n      })\n  );\n};\n"]},"metadata":{},"sourceType":"module"}