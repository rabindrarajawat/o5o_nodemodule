{"ast":null,"code":"import { toMintAccount, toTokenAccount } from '../accounts.mjs';\nimport { TokenAndMintDoNotMatchError } from '../errors.mjs';\nimport { toMint } from '../models/Mint.mjs';\nimport { toTokenWithMint } from '../models/Token.mjs';\nimport { useOperation } from '../../../types/Operation.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindTokenWithMintByMintOperation';\n/**\n * Finds a token account and its associated mint account\n * by providing the mint address and either:\n * - the token address or\n * - the address of the token's owner.\n *\n * ```ts\n * const tokenWithMint = await metaplex\n *   .tokens()\n *   .findTokenWithMintByMint({ mint, address: tokenAddress, type: \"token\" };\n *\n * const tokenWithMint = await metaplex\n *   .tokens()\n *   .findTokenWithMintByMint({ mint, address: ownerAddress, type: \"owner\" };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst findTokenWithMintByMintOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst findTokenWithMintByMintOperationHandler = {\n  handle: async (operation, metaplex, scope) => {\n    const {\n      commitment,\n      programs\n    } = scope;\n    const {\n      mint,\n      address,\n      addressType\n    } = operation.input;\n    const tokenAddress = addressType === 'owner' ? metaplex.tokens().pdas().associatedTokenAccount({\n      mint,\n      owner: address,\n      programs\n    }) : address;\n    const accounts = await metaplex.rpc().getMultipleAccounts([mint, tokenAddress], commitment);\n    const mintAccount = toMintAccount(accounts[0]);\n    const tokenAccount = toTokenAccount(accounts[1]);\n\n    if (!tokenAccount.data.mint.equals(mint)) {\n      throw new TokenAndMintDoNotMatchError(tokenAddress, tokenAccount.data.mint, mint);\n    }\n\n    return toTokenWithMint(tokenAccount, toMint(mintAccount));\n  }\n};\nexport { findTokenWithMintByMintOperation, findTokenWithMintByMintOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/tokenModule/operations/findTokenWithMintByMint.ts"],"names":["Key","findTokenWithMintByMintOperation","useOperation","findTokenWithMintByMintOperationHandler","handle","operation","metaplex","scope","commitment","programs","mint","address","addressType","input","tokenAddress","tokens","pdas","associatedTokenAccount","owner","accounts","rpc","getMultipleAccounts","mintAccount","toMintAccount","tokenAccount","toTokenAccount","data","equals","TokenAndMintDoNotMatchError","toTokenWithMint","toMint"],"mappings":";;;;6DAaA;AACA;AACA;;AAEA,MAAMA,GAAG,GAAG,kCAAZ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;MACaC,gCAAgC,GAC3CC,YAAY,CAAmCF,GAAnC,C;AAEd;AACA;AACA;AACA;;AA4BA;AACA;AACA;AACA;;AACO,MAAMG,uCAA2F,GACtG;EACEC,MAAM,EAAE,OACNC,SADM,EAENC,QAFM,EAGNC,KAHM,KAIqB;IAC3B,MAAM;MAAEC,UAAF;MAAcC;IAAd,IAA2BF,KAAjC;IACA,MAAM;MAAEG,IAAF;MAAQC,OAAR;MAAiBC;IAAjB,IAAiCP,SAAS,CAACQ,KAAjD;IACA,MAAMC,YAAY,GAChBF,WAAW,KAAK,OAAhBA,GACIN,QAAQ,CAACS,MAATT,GAAkBU,IAAlBV,GAAyBW,sBAAzBX,CAAgD;MAC9CI,IAD8C;MAE9CQ,KAAK,EAAEP,OAFuC;MAG9CF;IAH8C,CAAhDH,CADJM,GAMID,OAPN;IASA,MAAMQ,QAAQ,GAAG,MAAMb,QAAQ,CAC5Bc,GADoBd,GAEpBe,mBAFoBf,CAEA,CAACI,IAAD,EAAOI,YAAP,CAFAR,EAEsBE,UAFtBF,CAAvB;IAIA,MAAMgB,WAAW,GAAGC,aAAa,CAACJ,QAAQ,CAAC,CAAD,CAAT,CAAjC;IACA,MAAMK,YAAY,GAAGC,cAAc,CAACN,QAAQ,CAAC,CAAD,CAAT,CAAnC;;IAEA,IAAI,CAACK,YAAY,CAACE,IAAbF,CAAkBd,IAAlBc,CAAuBG,MAAvBH,CAA8Bd,IAA9Bc,CAAL,EAA0C;MACxC,MAAM,IAAII,2BAAJ,CACJd,YADI,EAEJU,YAAY,CAACE,IAAbF,CAAkBd,IAFd,EAGJA,IAHI,CAAN;IAKF;;IAEA,OAAOmB,eAAe,CAACL,YAAD,EAAeM,MAAM,CAACR,WAAD,CAArB,CAAtB;EACF;AAjCF,CADK","sourcesContent":["import type { PublicKey } from '@solana/web3.js';\nimport { toMintAccount, toTokenAccount } from '../accounts';\nimport { TokenAndMintDoNotMatchError } from '../errors';\nimport { toMint } from '../models/Mint';\nimport { TokenWithMint, toTokenWithMint } from '../models/Token';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindTokenWithMintByMintOperation' as const;\n\n/**\n * Finds a token account and its associated mint account\n * by providing the mint address and either:\n * - the token address or\n * - the address of the token's owner.\n *\n * ```ts\n * const tokenWithMint = await metaplex\n *   .tokens()\n *   .findTokenWithMintByMint({ mint, address: tokenAddress, type: \"token\" };\n *\n * const tokenWithMint = await metaplex\n *   .tokens()\n *   .findTokenWithMintByMint({ mint, address: ownerAddress, type: \"owner\" };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findTokenWithMintByMintOperation =\n  useOperation<FindTokenWithMintByMintOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindTokenWithMintByMintOperation = Operation<\n  typeof Key,\n  FindTokenWithMintByMintInput,\n  TokenWithMint\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindTokenWithMintByMintInput = {\n  /** The address of the mint account. */\n  mint: PublicKey;\n\n  /**\n   * The address of the token account or its owner,\n   * distinguished by the `addressType`` parameter.\n   */\n  address: PublicKey;\n\n  /**\n   * Determines whether the `address` parameter is the token address\n   * or the address of its owner.\n   */\n  addressType: 'owner' | 'token';\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findTokenWithMintByMintOperationHandler: OperationHandler<FindTokenWithMintByMintOperation> =\n  {\n    handle: async (\n      operation: FindTokenWithMintByMintOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<TokenWithMint> => {\n      const { commitment, programs } = scope;\n      const { mint, address, addressType } = operation.input;\n      const tokenAddress =\n        addressType === 'owner'\n          ? metaplex.tokens().pdas().associatedTokenAccount({\n              mint,\n              owner: address,\n              programs,\n            })\n          : address;\n\n      const accounts = await metaplex\n        .rpc()\n        .getMultipleAccounts([mint, tokenAddress], commitment);\n\n      const mintAccount = toMintAccount(accounts[0]);\n      const tokenAccount = toTokenAccount(accounts[1]);\n\n      if (!tokenAccount.data.mint.equals(mint)) {\n        throw new TokenAndMintDoNotMatchError(\n          tokenAddress,\n          tokenAccount.data.mint,\n          mint\n        );\n      }\n\n      return toTokenWithMint(tokenAccount, toMint(mintAccount));\n    },\n  };\n"]},"metadata":{},"sourceType":"module"}