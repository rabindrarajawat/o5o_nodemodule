{"ast":null,"code":"import { createBuyInstruction, createPublicBuyInstruction, createAuctioneerBuyInstruction, createAuctioneerPublicBuyInstruction, createPrintBidReceiptInstruction } from '@metaplex-foundation/mpl-auction-house';\nimport { SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { AuctioneerAuthorityRequiredError } from '../errors.mjs';\nimport { now } from '../../../types/DateTime.mjs';\nimport { token, lamports, amount } from '../../../types/Amount.mjs';\nimport { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { toPublicKey } from '../../../types/PublicKey.mjs';\nimport { isSigner } from '../../../types/Signer.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateBidOperation';\n/**\n * Creates a bid on a given asset.\n *\n * You can post a public bid on a non-listed NFT by skipping seller and tokenAccount properties.\n * Public bids are specific to the token itself and not to any specific auction.\n * This means that a bid can stay active beyond the end of an auction\n * and be resolved if it meets the criteria for subsequent auctions of that token.\n *\n *\n * ```ts\n * await metaplex\n *   .auctionHouse()\n *   .createBid({ auctionHouse, mintAccount, seller };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst createBidOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst createBidOperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const {\n      auctionHouse\n    } = operation.input;\n    const builder = await createBidBuilder(metaplex, operation.input, scope);\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    if (output.receipt) {\n      const bid = await metaplex.auctionHouse().findBidByReceipt({\n        auctionHouse,\n        receiptAddress: output.receipt\n      }, scope);\n      return {\n        bid,\n        ...output\n      };\n    }\n\n    scope.throwIfCanceled();\n    const lazyBid = {\n      model: 'bid',\n      lazy: true,\n      auctionHouse,\n      tradeStateAddress: output.buyerTradeState,\n      bookkeeperAddress: output.bookkeeper,\n      tokenAddress: output.tokenAccount,\n      buyerAddress: output.buyer,\n      metadataAddress: output.metadata,\n      receiptAddress: output.receipt,\n      purchaseReceiptAddress: null,\n      isPublic: Boolean(output.tokenAccount),\n      price: output.price,\n      tokens: output.tokens.basisPoints,\n      createdAt: now(),\n      canceledAt: null\n    };\n    return {\n      bid: await metaplex.auctionHouse().loadBid({\n        lazyBid\n      }, scope),\n      ...output\n    };\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Creates a bid on a given asset.\n *\n * You can post a public bid on a non-listed NFT by skipping seller and tokenAccount properties.\n * Public bids are specific to the token itself and not to any specific auction.\n * This means that a bid can stay active beyond the end of an auction\n * and be resolved if it meets the criteria for subsequent auctions of that token.\n *\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .auctionHouse()\n *   .builders()\n *   .createBid({ auctionHouse, mintAccount, seller })\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst createBidBuilder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Data.\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    auctionHouse\n  } = params;\n  const tokens = params.tokens ?? token(1);\n  const priceBasisPoint = params.price?.basisPoints ?? 0;\n  const price = auctionHouse.isNative ? lamports(priceBasisPoint) : amount(priceBasisPoint, auctionHouse.treasuryMint.currency);\n\n  if (auctionHouse.hasAuctioneer && !params.auctioneerAuthority) {\n    throw new AuctioneerAuthorityRequiredError();\n  } // Accounts.\n\n\n  const buyer = params.buyer ?? metaplex.identity();\n  const authority = params.authority ?? auctionHouse.authorityAddress;\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: params.mintAccount,\n    programs\n  });\n  const paymentAccount = auctionHouse.isNative ? toPublicKey(buyer) : metaplex.tokens().pdas().associatedTokenAccount({\n    mint: auctionHouse.treasuryMint.address,\n    owner: toPublicKey(buyer),\n    programs\n  });\n  const escrowPayment = metaplex.auctionHouse().pdas().buyerEscrow({\n    auctionHouse: auctionHouse.address,\n    buyer: toPublicKey(buyer),\n    programs\n  });\n  const tokenAccount = params.tokenAccount ?? (params.seller ? metaplex.tokens().pdas().associatedTokenAccount({\n    mint: params.mintAccount,\n    owner: params.seller,\n    programs\n  }) : null);\n  const buyerTokenAccount = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: params.mintAccount,\n    owner: toPublicKey(buyer),\n    programs\n  });\n  const buyerTradeState = metaplex.auctionHouse().pdas().tradeState({\n    auctionHouse: auctionHouse.address,\n    wallet: toPublicKey(buyer),\n    treasuryMint: auctionHouse.treasuryMint.address,\n    tokenMint: params.mintAccount,\n    price: price.basisPoints,\n    tokenSize: tokens.basisPoints,\n    tokenAccount,\n    programs\n  });\n  const accounts = {\n    wallet: toPublicKey(buyer),\n    paymentAccount,\n    transferAuthority: toPublicKey(buyer),\n    treasuryMint: auctionHouse.treasuryMint.address,\n    metadata,\n    escrowPaymentAccount: escrowPayment,\n    authority: toPublicKey(authority),\n    auctionHouse: auctionHouse.address,\n    auctionHouseFeeAccount: auctionHouse.feeAccountAddress,\n    buyerTradeState\n  }; // Args.\n\n  const args = {\n    tradeStateBump: buyerTradeState.bump,\n    escrowPaymentBump: escrowPayment.bump,\n    buyerPrice: price.basisPoints,\n    tokenSize: tokens.basisPoints\n  }; // Sell Instruction.\n\n  let buyInstruction = tokenAccount ? createBuyInstruction({ ...accounts,\n    tokenAccount\n  }, args) : createPublicBuyInstruction({ ...accounts,\n    tokenAccount: buyerTokenAccount\n  }, args);\n\n  if (params.auctioneerAuthority) {\n    const ahAuctioneerPda = metaplex.auctionHouse().pdas().auctioneer({\n      auctionHouse: auctionHouse.address,\n      auctioneerAuthority: params.auctioneerAuthority.publicKey,\n      programs\n    });\n    const accountsWithAuctioneer = { ...accounts,\n      auctioneerAuthority: params.auctioneerAuthority.publicKey,\n      ahAuctioneerPda\n    };\n    buyInstruction = tokenAccount ? createAuctioneerBuyInstruction({ ...accountsWithAuctioneer,\n      tokenAccount\n    }, args) : createAuctioneerPublicBuyInstruction({ ...accountsWithAuctioneer,\n      tokenAccount: buyerTokenAccount\n    }, args);\n  } // Signers.\n\n\n  const buySigners = [buyer, authority, params.auctioneerAuthority].filter(isSigner); // Update the accounts to be signers since it's not covered properly by MPL due to its dynamic nature.\n\n  buySigners.forEach(signer => {\n    const signerKeyIndex = buyInstruction.keys.findIndex(_ref => {\n      let {\n        pubkey\n      } = _ref;\n      return pubkey.equals(signer.publicKey);\n    });\n    buyInstruction.keys[signerKeyIndex].isSigner = true;\n  }); // Receipt.\n  // Since createPrintBidReceiptInstruction can't deserialize createAuctioneerBuyInstruction due to a bug\n  // Don't print Auctioneer Bid receipt for the time being.\n\n  const shouldPrintReceipt = (params.printReceipt ?? true) && !params.auctioneerAuthority;\n  const bookkeeper = params.bookkeeper ?? metaplex.identity();\n  const receipt = metaplex.auctionHouse().pdas().bidReceipt({\n    tradeState: buyerTradeState,\n    programs\n  });\n  const builder = TransactionBuilder.make().setFeePayer(payer).setContext({\n    buyerTradeState,\n    tokenAccount,\n    metadata,\n    buyer: toPublicKey(buyer),\n    receipt: shouldPrintReceipt ? receipt : null,\n    bookkeeper: shouldPrintReceipt ? bookkeeper.publicKey : null,\n    price,\n    tokens\n  }); // Create a TA for public bid if it doesn't exist\n\n  if (!tokenAccount) {\n    const account = await metaplex.rpc().getAccount(buyerTokenAccount);\n\n    if (!account.exists) {\n      builder.add(await metaplex.tokens().builders().createToken({\n        mint: params.mintAccount,\n        owner: toPublicKey(buyer)\n      }));\n    }\n  }\n\n  return builder // Create bid.\n  .add({\n    instruction: buyInstruction,\n    signers: buySigners,\n    key: 'buy'\n  }) // Print the Bid Receipt.\n  .when(shouldPrintReceipt, builder => builder.add({\n    instruction: createPrintBidReceiptInstruction({\n      receipt,\n      bookkeeper: bookkeeper.publicKey,\n      instruction: SYSVAR_INSTRUCTIONS_PUBKEY\n    }, {\n      receiptBump: receipt.bump\n    }),\n    signers: [bookkeeper],\n    key: 'printBidReceipt'\n  }));\n};\n\nexport { createBidBuilder, createBidOperation, createBidOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/auctionHouseModule/operations/createBid.ts"],"names":["Key","createBidOperation","useOperation","createBidOperationHandler","handle","operation","metaplex","scope","auctionHouse","input","builder","createBidBuilder","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","throwIfCanceled","receipt","bid","findBidByReceipt","receiptAddress","lazyBid","model","lazy","tradeStateAddress","buyerTradeState","bookkeeperAddress","bookkeeper","tokenAddress","tokenAccount","buyerAddress","buyer","metadataAddress","metadata","purchaseReceiptAddress","isPublic","Boolean","price","tokens","basisPoints","createdAt","now","canceledAt","loadBid","params","options","programs","payer","rpc","getDefaultFeePayer","token","priceBasisPoint","isNative","lamports","amount","treasuryMint","currency","hasAuctioneer","auctioneerAuthority","AuctioneerAuthorityRequiredError","identity","authority","authorityAddress","nfts","pdas","mint","mintAccount","paymentAccount","toPublicKey","associatedTokenAccount","address","owner","escrowPayment","buyerEscrow","seller","buyerTokenAccount","tradeState","wallet","tokenMint","tokenSize","accounts","transferAuthority","escrowPaymentAccount","auctionHouseFeeAccount","feeAccountAddress","args","tradeStateBump","bump","escrowPaymentBump","buyerPrice","buyInstruction","createBuyInstruction","createPublicBuyInstruction","ahAuctioneerPda","auctioneer","publicKey","accountsWithAuctioneer","createAuctioneerBuyInstruction","createAuctioneerPublicBuyInstruction","buySigners","filter","isSigner","forEach","signer","signerKeyIndex","keys","findIndex","pubkey","equals","shouldPrintReceipt","printReceipt","bidReceipt","TransactionBuilder","make","setFeePayer","setContext","account","getAccount","exists","add","builders","createToken","instruction","signers","key","when","createPrintBidReceiptInstruction","SYSVAR_INSTRUCTIONS_PUBKEY","receiptBump"],"mappings":"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","sourcesContent":["import {\n  BuyInstructionAccounts,\n  createAuctioneerBuyInstruction,\n  createAuctioneerPublicBuyInstruction,\n  createBuyInstruction,\n  createPrintBidReceiptInstruction,\n  createPublicBuyInstruction,\n} from '@metaplex-foundation/mpl-auction-house';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { AuctioneerAuthorityRequiredError } from '../errors';\nimport { AuctionHouse, Bid, LazyBid } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  amount,\n  isSigner,\n  lamports,\n  makeConfirmOptionsFinalizedOnMainnet,\n  now,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Pda,\n  Signer,\n  SolAmount,\n  SplTokenAmount,\n  token,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateBidOperation' as const;\n\n/**\n * Creates a bid on a given asset.\n *\n * You can post a public bid on a non-listed NFT by skipping seller and tokenAccount properties.\n * Public bids are specific to the token itself and not to any specific auction.\n * This means that a bid can stay active beyond the end of an auction\n * and be resolved if it meets the criteria for subsequent auctions of that token.\n *\n *\n * ```ts\n * await metaplex\n *   .auctionHouse()\n *   .createBid({ auctionHouse, mintAccount, seller };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createBidOperation = useOperation<CreateBidOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateBidOperation = Operation<\n  typeof Key,\n  CreateBidInput,\n  CreateBidOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateBidInput = {\n  /** The Auction House in which to create a Bid. */\n  auctionHouse: AuctionHouse;\n\n  /**\n   * Creator of a bid.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  buyer?: Signer;\n\n  /**\n   * The Auction House authority.\n   * If this is Signer the transaction fee\n   * will be paid from the Auction House Fee Account\n   *\n   * @defaultValue `auctionHouse.authority`\n   */\n  authority?: PublicKey | Signer;\n\n  /**\n   * The Auctioneer authority key.\n   * It is required when Auction House has Auctioneer enabled.\n   *\n   * @defaultValue No default value.\n   */\n  auctioneerAuthority?: Signer;\n\n  /**\n   * The mint account to create a bid for.\n   * This is used to find the metadata.\n   */\n  mintAccount: PublicKey;\n\n  /**\n   * The account address that holds the asset a bid created is for.\n   * If this or tokenAccount isn't provided, then the bid will be public.\n   *\n   * @defaultValue No default value.\n   */\n  seller?: Option<PublicKey>;\n\n  /**\n   * The token account address that's associated to the asset a bid created is for.\n   * If this or seller isn't provided, then the bid will be public.\n   *\n   * @defaultValue No default value.\n   */\n  tokenAccount?: Option<PublicKey>;\n\n  /**\n   * The buyer's price.\n   *\n   * @defaultValue 0 SOLs or tokens.\n   */\n  price?: SolAmount | SplTokenAmount;\n\n  /**\n   * The number of tokens to bid for.\n   * For an NFT bid it must be 1 token.\n   *\n   * When a Fungible Asset is put on sale.\n   * The buyer can then create a buy order of said assets that is\n   * less than the token_size of the sell order.\n   *\n   * @defaultValue 1 token.\n   */\n  tokens?: SplTokenAmount;\n\n  /**\n   * Prints the bid receipt.\n   * The receipt holds information about the bid,\n   * So it's important to print it if you want to use the `Bid` model\n   *\n   * The receipt printing is skipped for the Auctioneer Auction House\n   * Since it currently doesn't support it.\n   *\n   * @defaultValue `true`\n   */\n  printReceipt?: boolean;\n\n  /**\n   * The address of the bookkeeper wallet responsible for the receipt.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  bookkeeper?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateBidOutput = {\n  /** Buyer trade state account PDA encoding the bid order. */\n  buyerTradeState: Pda;\n\n  /** The asset's token account address in case the bid is private. */\n  tokenAccount: Option<PublicKey>;\n\n  /** The asset's metadata PDA. */\n  metadata: Pda;\n\n  /** The potential buyer of the asset. */\n  buyer: PublicKey;\n\n  /** The PDA of the receipt account in case it was printed. */\n  receipt: Option<Pda>;\n\n  /** The address of the bookkeeper wallet responsible for the receipt. */\n  bookkeeper: Option<PublicKey>;\n\n  /** The buyer's price. */\n  price: SolAmount | SplTokenAmount;\n\n  /** The number of tokens to bid for. */\n  tokens: SplTokenAmount;\n\n  /** A model that keeps information about the Bid. */\n  bid: Bid;\n\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createBidOperationHandler: OperationHandler<CreateBidOperation> = {\n  async handle(\n    operation: CreateBidOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<CreateBidOutput> {\n    const { auctionHouse } = operation.input;\n\n    const builder = await createBidBuilder(metaplex, operation.input, scope);\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n      metaplex,\n      scope.confirmOptions\n    );\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    if (output.receipt) {\n      const bid = await metaplex\n        .auctionHouse()\n        .findBidByReceipt(\n          { auctionHouse, receiptAddress: output.receipt },\n          scope\n        );\n\n      return { bid, ...output };\n    }\n\n    scope.throwIfCanceled();\n    const lazyBid: LazyBid = {\n      model: 'bid',\n      lazy: true,\n      auctionHouse,\n      tradeStateAddress: output.buyerTradeState,\n      bookkeeperAddress: output.bookkeeper,\n      tokenAddress: output.tokenAccount,\n      buyerAddress: output.buyer,\n      metadataAddress: output.metadata,\n      receiptAddress: output.receipt,\n      purchaseReceiptAddress: null,\n      isPublic: Boolean(output.tokenAccount),\n      price: output.price,\n      tokens: output.tokens.basisPoints,\n      createdAt: now(),\n      canceledAt: null,\n    };\n\n    return {\n      bid: await metaplex.auctionHouse().loadBid({ lazyBid }, scope),\n      ...output,\n    };\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateBidBuilderParams = Omit<CreateBidInput, 'confirmOptions'> & {\n  instructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateBidBuilderContext = Omit<CreateBidOutput, 'response' | 'bid'>;\n\n/**\n * Creates a bid on a given asset.\n *\n * You can post a public bid on a non-listed NFT by skipping seller and tokenAccount properties.\n * Public bids are specific to the token itself and not to any specific auction.\n * This means that a bid can stay active beyond the end of an auction\n * and be resolved if it meets the criteria for subsequent auctions of that token.\n *\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .auctionHouse()\n *   .builders()\n *   .createBid({ auctionHouse, mintAccount, seller })\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createBidBuilder = async (\n  metaplex: Metaplex,\n  params: CreateBidBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateBidBuilderContext>> => {\n  // Data.\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { auctionHouse } = params;\n  const tokens = params.tokens ?? token(1);\n  const priceBasisPoint = params.price?.basisPoints ?? 0;\n  const price = auctionHouse.isNative\n    ? lamports(priceBasisPoint)\n    : amount(priceBasisPoint, auctionHouse.treasuryMint.currency);\n\n  if (auctionHouse.hasAuctioneer && !params.auctioneerAuthority) {\n    throw new AuctioneerAuthorityRequiredError();\n  }\n\n  // Accounts.\n  const buyer = params.buyer ?? (metaplex.identity() as Signer);\n  const authority = params.authority ?? auctionHouse.authorityAddress;\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: params.mintAccount,\n    programs,\n  });\n  const paymentAccount = auctionHouse.isNative\n    ? toPublicKey(buyer)\n    : metaplex\n        .tokens()\n        .pdas()\n        .associatedTokenAccount({\n          mint: auctionHouse.treasuryMint.address,\n          owner: toPublicKey(buyer),\n          programs,\n        });\n  const escrowPayment = metaplex\n    .auctionHouse()\n    .pdas()\n    .buyerEscrow({\n      auctionHouse: auctionHouse.address,\n      buyer: toPublicKey(buyer),\n      programs,\n    });\n  const tokenAccount =\n    params.tokenAccount ??\n    (params.seller\n      ? metaplex.tokens().pdas().associatedTokenAccount({\n          mint: params.mintAccount,\n          owner: params.seller,\n          programs,\n        })\n      : null);\n  const buyerTokenAccount = metaplex\n    .tokens()\n    .pdas()\n    .associatedTokenAccount({\n      mint: params.mintAccount,\n      owner: toPublicKey(buyer),\n      programs,\n    });\n\n  const buyerTradeState = metaplex\n    .auctionHouse()\n    .pdas()\n    .tradeState({\n      auctionHouse: auctionHouse.address,\n      wallet: toPublicKey(buyer),\n      treasuryMint: auctionHouse.treasuryMint.address,\n      tokenMint: params.mintAccount,\n      price: price.basisPoints,\n      tokenSize: tokens.basisPoints,\n      tokenAccount,\n      programs,\n    });\n\n  const accounts: Omit<BuyInstructionAccounts, 'tokenAccount'> = {\n    wallet: toPublicKey(buyer),\n    paymentAccount,\n    transferAuthority: toPublicKey(buyer),\n    treasuryMint: auctionHouse.treasuryMint.address,\n    metadata,\n    escrowPaymentAccount: escrowPayment,\n    authority: toPublicKey(authority),\n    auctionHouse: auctionHouse.address,\n    auctionHouseFeeAccount: auctionHouse.feeAccountAddress,\n    buyerTradeState,\n  };\n\n  // Args.\n  const args = {\n    tradeStateBump: buyerTradeState.bump,\n    escrowPaymentBump: escrowPayment.bump,\n    buyerPrice: price.basisPoints,\n    tokenSize: tokens.basisPoints,\n  };\n\n  // Sell Instruction.\n  let buyInstruction = tokenAccount\n    ? createBuyInstruction({ ...accounts, tokenAccount }, args)\n    : createPublicBuyInstruction(\n        { ...accounts, tokenAccount: buyerTokenAccount },\n        args\n      );\n\n  if (params.auctioneerAuthority) {\n    const ahAuctioneerPda = metaplex.auctionHouse().pdas().auctioneer({\n      auctionHouse: auctionHouse.address,\n      auctioneerAuthority: params.auctioneerAuthority.publicKey,\n      programs,\n    });\n\n    const accountsWithAuctioneer = {\n      ...accounts,\n      auctioneerAuthority: params.auctioneerAuthority.publicKey,\n      ahAuctioneerPda,\n    };\n\n    buyInstruction = tokenAccount\n      ? createAuctioneerBuyInstruction(\n          { ...accountsWithAuctioneer, tokenAccount },\n          args\n        )\n      : createAuctioneerPublicBuyInstruction(\n          {\n            ...accountsWithAuctioneer,\n            tokenAccount: buyerTokenAccount,\n          },\n          args\n        );\n  }\n\n  // Signers.\n  const buySigners = [buyer, authority, params.auctioneerAuthority].filter(\n    isSigner\n  );\n\n  // Update the accounts to be signers since it's not covered properly by MPL due to its dynamic nature.\n  buySigners.forEach((signer) => {\n    const signerKeyIndex = buyInstruction.keys.findIndex(({ pubkey }) =>\n      pubkey.equals(signer.publicKey)\n    );\n\n    buyInstruction.keys[signerKeyIndex].isSigner = true;\n  });\n\n  // Receipt.\n  // Since createPrintBidReceiptInstruction can't deserialize createAuctioneerBuyInstruction due to a bug\n  // Don't print Auctioneer Bid receipt for the time being.\n  const shouldPrintReceipt =\n    (params.printReceipt ?? true) && !params.auctioneerAuthority;\n  const bookkeeper = params.bookkeeper ?? metaplex.identity();\n  const receipt = metaplex.auctionHouse().pdas().bidReceipt({\n    tradeState: buyerTradeState,\n    programs,\n  });\n\n  const builder = TransactionBuilder.make<CreateBidBuilderContext>()\n    .setFeePayer(payer)\n    .setContext({\n      buyerTradeState,\n      tokenAccount,\n      metadata,\n      buyer: toPublicKey(buyer),\n      receipt: shouldPrintReceipt ? receipt : null,\n      bookkeeper: shouldPrintReceipt ? bookkeeper.publicKey : null,\n      price,\n      tokens,\n    });\n\n  // Create a TA for public bid if it doesn't exist\n  if (!tokenAccount) {\n    const account = await metaplex.rpc().getAccount(buyerTokenAccount);\n    if (!account.exists) {\n      builder.add(\n        await metaplex\n          .tokens()\n          .builders()\n          .createToken({\n            mint: params.mintAccount,\n            owner: toPublicKey(buyer),\n          })\n      );\n    }\n  }\n\n  return (\n    builder\n      // Create bid.\n      .add({\n        instruction: buyInstruction,\n        signers: buySigners,\n        key: 'buy',\n      })\n\n      // Print the Bid Receipt.\n      .when(shouldPrintReceipt, (builder) =>\n        builder.add({\n          instruction: createPrintBidReceiptInstruction(\n            {\n              receipt,\n              bookkeeper: bookkeeper.publicKey,\n              instruction: SYSVAR_INSTRUCTIONS_PUBKEY,\n            },\n            { receiptBump: receipt.bump }\n          ),\n          signers: [bookkeeper],\n          key: 'printBidReceipt',\n        })\n      )\n  );\n};\n"]},"metadata":{},"sourceType":"module"}