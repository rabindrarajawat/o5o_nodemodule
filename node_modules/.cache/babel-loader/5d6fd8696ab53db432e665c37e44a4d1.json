{"ast":null,"code":"import { defineProperty as _defineProperty } from '../_virtual/_rollupPluginBabelHelpers.mjs';\nimport EventEmitterPackage from 'eventemitter3';\n\nclass Disposable {\n  constructor(signal) {\n    _defineProperty(this, \"cancelationError\", null);\n\n    this.signal = signal;\n    this.eventEmitter = new EventEmitterPackage.EventEmitter();\n\n    this.abortListener = error => {\n      this.cancelationError = error;\n      this.eventEmitter.emit('cancel', error);\n      this.close();\n    };\n\n    this.signal.addEventListener('abort', this.abortListener);\n  }\n\n  async run(callback) {\n    let thenCloseDisposable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    try {\n      return await Promise.resolve(callback(this.getScope()));\n    } finally {\n      if (thenCloseDisposable) {\n        this.close();\n      }\n    }\n  }\n\n  getScope() {\n    return {\n      signal: this.signal,\n      isCanceled: () => this.isCanceled(),\n      getCancelationError: () => this.cancelationError,\n      throwIfCanceled: () => {\n        if (this.isCanceled()) {\n          throw this.getCancelationError();\n        }\n      }\n    };\n  }\n\n  isCanceled() {\n    return this.signal.aborted;\n  }\n\n  getCancelationError() {\n    return this.cancelationError;\n  }\n\n  onCancel(callback) {\n    this.eventEmitter.on('cancel', callback);\n    return this;\n  }\n\n  close() {\n    this.signal.removeEventListener('abort', this.abortListener);\n    this.eventEmitter.removeAllListeners();\n  }\n\n}\n\nexport { Disposable };","map":{"version":3,"sources":["../../../src/utils/Disposable.ts"],"names":["Disposable","constructor","signal","eventEmitter","EventEmitterPackage","EventEmitter","abortListener","error","cancelationError","emit","close","addEventListener","run","callback","thenCloseDisposable","Promise","resolve","getScope","isCanceled","getCancelationError","throwIfCanceled","aborted","onCancel","on","removeEventListener","removeAllListeners"],"mappings":";;;AAUO,MAAMA,UAAN,CAAiB;EAMtBC,WAAW,CAACC,MAAD,EAAsB;IAAA,eAAA,CAAA,IAAA,EAAA,kBAAA,EAHK,IAGL,CAAA;;IAC/B,KAAKA,MAAL,GAAcA,MAAd;IACA,KAAKC,YAAL,GAAoB,IAAIC,mBAAmB,CAACC,YAAxB,EAApB;;IACA,KAAKC,aAAL,GAAsBC,KAAc,IAAK;MACvC,KAAKC,gBAAL,GAAwBD,KAAxB;MACA,KAAKJ,YAAL,CAAkBM,IAAlB,CAAuB,QAAvB,EAAiCF,KAAjC;MACA,KAAKG,KAAL;IACD,CAJD;;IAKA,KAAKR,MAAL,CAAYS,gBAAZ,CAA6B,OAA7B,EAAsC,KAAKL,aAA3C;EACF;;EAES,MAAHM,GAAG,CACPC,QADO,EAGP;IAAA,IADAC,mBACA,uEADsB,IACtB;;IACA,IAAI;MACF,OAAO,MAAMC,OAAO,CAACC,OAARD,CAAgBF,QAAQ,CAAC,KAAKI,QAAL,EAAD,CAAxBF,CAAb;IACD,CAFD,SAEU;MACR,IAAID,mBAAJ,EAAyB;QACvB,KAAKJ,KAAL;MACF;IACF;EACF;;EAEAO,QAAQ,GAAoB;IAC1B,OAAO;MACLf,MAAM,EAAE,KAAKA,MADR;MAELgB,UAAU,EAAE,MAAM,KAAKA,UAAL,EAFb;MAGLC,mBAAmB,EAAE,MAAM,KAAKX,gBAH3B;MAILY,eAAe,EAAE,MAAM;QACrB,IAAI,KAAKF,UAAL,EAAJ,EAAuB;UACrB,MAAM,KAAKC,mBAAL,EAAN;QACF;MACF;IARK,CAAP;EAUF;;EAEAD,UAAU,GAAG;IACX,OAAO,KAAKhB,MAAL,CAAYmB,OAAnB;EACF;;EAEAF,mBAAmB,GAAG;IACpB,OAAO,KAAKX,gBAAZ;EACF;;EAEAc,QAAQ,CAACT,QAAD,EAAqD;IAC3D,KAAKV,YAAL,CAAkBoB,EAAlB,CAAqB,QAArB,EAA+BV,QAA/B;IAEA,OAAO,IAAP;EACF;;EAEAH,KAAK,GAAG;IACN,KAAKR,MAAL,CAAYsB,mBAAZ,CAAgC,OAAhC,EAAyC,KAAKlB,aAA9C;IACA,KAAKH,YAAL,CAAkBsB,kBAAlB;EACF;;AA5DsB","sourcesContent":["import EventEmitterPackage from 'eventemitter3';\nimport type EventEmitter from 'eventemitter3';\n\nexport type DisposableScope = {\n  signal: AbortSignal | undefined;\n  isCanceled: () => boolean;\n  getCancelationError: () => unknown;\n  throwIfCanceled: () => void;\n};\n\nexport class Disposable {\n  protected eventEmitter: EventEmitter;\n  protected signal: AbortSignal;\n  protected cancelationError: unknown = null;\n  protected abortListener: (error: unknown) => void;\n\n  constructor(signal: AbortSignal) {\n    this.signal = signal;\n    this.eventEmitter = new EventEmitterPackage.EventEmitter();\n    this.abortListener = (error: unknown) => {\n      this.cancelationError = error;\n      this.eventEmitter.emit('cancel', error);\n      this.close();\n    };\n    this.signal.addEventListener('abort', this.abortListener);\n  }\n\n  async run<T>(\n    callback: (scope: DisposableScope) => T,\n    thenCloseDisposable = true\n  ) {\n    try {\n      return await Promise.resolve(callback(this.getScope()));\n    } finally {\n      if (thenCloseDisposable) {\n        this.close();\n      }\n    }\n  }\n\n  getScope(): DisposableScope {\n    return {\n      signal: this.signal,\n      isCanceled: () => this.isCanceled(),\n      getCancelationError: () => this.cancelationError,\n      throwIfCanceled: () => {\n        if (this.isCanceled()) {\n          throw this.getCancelationError();\n        }\n      },\n    };\n  }\n\n  isCanceled() {\n    return this.signal.aborted;\n  }\n\n  getCancelationError() {\n    return this.cancelationError;\n  }\n\n  onCancel(callback: (reason: unknown) => unknown): Disposable {\n    this.eventEmitter.on('cancel', callback);\n\n    return this;\n  }\n\n  close() {\n    this.signal.removeEventListener('abort', this.abortListener);\n    this.eventEmitter.removeAllListeners();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}