{"ast":null,"code":"import { BEET_PACKAGE, BEET_TYPE_ARG_INNER, isFixedSizeBeet } from '../types';\nimport { u8 } from './numbers';\nimport { strict as assert } from 'assert';\nimport { isBeetStruct } from '../struct';\nimport { isFixableBeetStruct } from '../struct.fixable';\nimport { unit } from './unit'; // -----------------\n// Fixed Scalar Enum\n// -----------------\n\nfunction resolveEnumVariant(value, isNumVariant) {\n  return isNumVariant ? `${value}` : value;\n}\n/**\n * De/serializer for enums with up to 255 less variants which have no data.\n *\n * @param enumType type of enum to process, i.e. Color or Direction\n *\n * @category beet/enum\n */\n\n\nexport function fixedScalarEnum(enumType) {\n  const keys = Object.keys(enumType);\n  return {\n    write(buf, offset, value) {\n      const isNumVariant = typeof value === 'number';\n      const variantKey = resolveEnumVariant(value, isNumVariant);\n\n      if (!keys.includes(variantKey)) {\n        assert.fail(`${value} should be a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);\n      }\n\n      if (isNumVariant) {\n        u8.write(buf, offset, value);\n      } else {\n        const enumValue = enumType[variantKey];\n        u8.write(buf, offset, enumValue);\n      }\n    },\n\n    read(buf, offset) {\n      const value = u8.read(buf, offset);\n      const isNumVariant = typeof value === 'number';\n      const variantKey = resolveEnumVariant(value, isNumVariant);\n\n      if (!keys.includes(variantKey)) {\n        assert.fail(`${value} should be a of a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);\n      }\n\n      return isNumVariant ? value : enumType[variantKey];\n    },\n\n    byteSize: u8.byteSize,\n    description: 'Enum'\n  };\n}\n/**\n * De/Serializes an {@link Enum} that contains a type of data, i.e. a {@link Struct}.\n * The main difference to a Rust enum is that the type of data has to be the\n * same for all enum variants.\n *\n * @template T inner enum data type\n *\n * @param inner the De/Serializer for the data type\n *\n * @category beet/enum\n */\n\nexport function uniformDataEnum(inner) {\n  return {\n    write: function (buf, offset, value) {\n      u8.write(buf, offset, value.kind);\n      inner.write(buf, offset + 1, value.data);\n    },\n    read: function (buf, offset) {\n      const kind = u8.read(buf, offset);\n      const data = inner.read(buf, offset + 1);\n      return {\n        kind,\n        data\n      };\n    },\n    byteSize: 1 + inner.byteSize,\n    description: `UniformDataEnum<${inner.description}>`\n  };\n}\n\nfunction enumDataVariantBeet(inner, discriminant, kind) {\n  return {\n    write(buf, offset, value) {\n      u8.write(buf, offset, discriminant);\n      inner.write(buf, offset + u8.byteSize, value);\n    },\n\n    read(buf, offset) {\n      const val = inner.read(buf, offset + u8.byteSize);\n      return {\n        __kind: kind,\n        ...val\n      };\n    },\n\n    byteSize: inner.byteSize + u8.byteSize,\n    description: `EnumData<${inner.description}>`\n  };\n}\n/**\n * De/serializes Data Enums.\n * They are represented as a discriminated unions in TypeScript.\n *\n * NOTE: only structs, i.e. {@link BeetArgsStruct} and\n * {@link FixableBeetArgsStruct} are supported as the data of each enum variant.\n *\n * ## Example\n *\n * ```ts\n * type Simple = {\n *   First: { n1: number }\n *   Second: { n2: number }\n * }\n *\n * const beet = dataEnum<Simple>([\n *   ['First', new BeetArgsStruct<Simple['First']>([['n1', u32]])],\n *   ['Second', new BeetArgsStruct<Simple['Second']>([['n2', u32]])],\n * ])\n * ```\n *\n * @category beet/enum\n * @param variants an array of {@link DataEnumBeet}s each a tuple of `[ kind, data ]`\n */\n\n\nexport function dataEnum(variants) {\n  for (const [_, beet] of variants) {\n    assert(isBeetStruct(beet) || isFixableBeetStruct(beet) || // scalar variant\n    beet === unit, 'dataEnum: variants must be a data beet struct or a scalar unit');\n  }\n\n  return {\n    toFixedFromData(buf, offset) {\n      const discriminant = u8.read(buf, offset);\n      const variant = variants[discriminant];\n      assert(variant != null, `Discriminant ${discriminant} out of range for ${variants.length} variants`);\n      const [__kind, dataBeet] = variant;\n      const fixed = isFixedSizeBeet(dataBeet) ? dataBeet : dataBeet.toFixedFromData(buf, offset + 1);\n      return enumDataVariantBeet(fixed, discriminant, __kind);\n    },\n\n    toFixedFromValue(val) {\n      if (val.__kind == null) {\n        const keys = Object.keys(val).join(', ');\n        const validKinds = variants.map(_ref => {\n          let [__kind] = _ref;\n          return __kind;\n        }).join(', ');\n        assert.fail(`Value with fields [ ${keys} ] is missing __kind, ` + `which needs to be set to one of [ ${validKinds} ]`);\n      }\n\n      const discriminant = variants.findIndex(_ref2 => {\n        let [__kind] = _ref2;\n        return __kind === val.__kind;\n      });\n\n      if (discriminant < 0) {\n        const validKinds = variants.map(_ref3 => {\n          let [__kind] = _ref3;\n          return __kind;\n        }).join(', ');\n        assert.fail(`${val.__kind} is not a valid kind, needs to be one of [ ${validKinds} ]`);\n      }\n\n      const variant = variants[discriminant];\n      const {\n        __kind,\n        ...dataValue\n      } = val;\n      const [__variantKind, dataBeet] = variant;\n      const fixed = isFixedSizeBeet(dataBeet) ? dataBeet : dataBeet.toFixedFromValue(dataValue);\n      return enumDataVariantBeet(fixed, discriminant, __variantKind);\n    },\n\n    description: `DataEnum<${variants.length} variants>`\n  };\n}\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexport const enumsTypeMap = {\n  fixedScalarEnum: {\n    beet: 'fixedScalarEnum',\n    isFixable: false,\n    sourcePack: BEET_PACKAGE,\n    ts: '<TypeName>',\n    arg: BEET_TYPE_ARG_INNER,\n    pack: BEET_PACKAGE\n  },\n  dataEnum: {\n    beet: 'dataEnum',\n    isFixable: false,\n    sourcePack: BEET_PACKAGE,\n    ts: 'DataEnum<Kind, Inner>',\n    arg: BEET_TYPE_ARG_INNER,\n    pack: BEET_PACKAGE\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/enums.ts"],"names":[],"mappings":"AAAA,SACE,YADF,EAEE,mBAFF,EAME,eANF,QAQO,UARP;AASA,SAAS,EAAT,QAAmB,WAAnB;AACA,SAAS,MAAM,IAAI,MAAnB,QAAiC,QAAjC;AACA,SAAS,YAAT,QAA6B,WAA7B;AACA,SAAS,mBAAT,QAAoC,mBAApC;AACA,SAAS,IAAT,QAAqB,QAArB,C,CAEA;AACA;AACA;;AAEA,SAAS,kBAAT,CAA+B,KAA/B,EAAyC,YAAzC,EAA8D;EAC5D,OAAQ,YAAY,GAAG,GAAG,KAAK,EAAX,GAAgB,KAApC;AACD;AAED;;;;;;AAMG;;;AACH,OAAM,SAAU,eAAV,CACJ,QADI,EACkB;EAEtB,MAAM,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,QAAZ,CAAb;EACA,OAAO;IACL,KAAK,CAAC,GAAD,EAAc,MAAd,EAA8B,KAA9B,EAAsC;MACzC,MAAM,YAAY,GAAG,OAAO,KAAP,KAAiB,QAAtC;MACA,MAAM,UAAU,GAAG,kBAAkB,CAAC,KAAD,EAAQ,YAAR,CAArC;;MAEA,IAAI,CAAC,IAAI,CAAC,QAAL,CAAc,UAAd,CAAL,EAAgC;QAC9B,MAAM,CAAC,IAAP,CACE,GAAG,KAAK,0DAA0D,MAAM,CAAC,MAAP,CAChE,QADgE,EAEhE,IAFgE,CAE3D,IAF2D,CAEtD,eAHd;MAKD;;MAED,IAAI,YAAJ,EAAkB;QAChB,EAAE,CAAC,KAAH,CAAS,GAAT,EAAc,MAAd,EAAsB,KAAtB;MACD,CAFD,MAEO;QACL,MAAM,SAAS,GAAG,QAAQ,CACxB,UADwB,CAA1B;QAGA,EAAE,CAAC,KAAH,CAAS,GAAT,EAAc,MAAd,EAAsB,SAAtB;MACD;IACF,CArBI;;IAuBL,IAAI,CAAC,GAAD,EAAc,MAAd,EAA4B;MAC9B,MAAM,KAAK,GAAG,EAAE,CAAC,IAAH,CAAQ,GAAR,EAAa,MAAb,CAAd;MACA,MAAM,YAAY,GAAG,OAAO,KAAP,KAAiB,QAAtC;MACA,MAAM,UAAU,GAAG,kBAAkB,CAAC,KAAD,EAAQ,YAAR,CAArC;;MAEA,IAAI,CAAC,IAAI,CAAC,QAAL,CAAc,UAAd,CAAL,EAAgC;QAC9B,MAAM,CAAC,IAAP,CACE,GAAG,KAAK,+DAA+D,MAAM,CAAC,MAAP,CACrE,QADqE,EAErE,IAFqE,CAEhE,IAFgE,CAE3D,eAHd;MAKD;;MACD,OAAQ,YAAY,GAAG,KAAH,GAAW,QAAQ,CAAC,UAAD,CAAvC;IACD,CApCI;;IAsCL,QAAQ,EAAE,EAAE,CAAC,QAtCR;IAuCL,WAAW,EAAE;EAvCR,CAAP;AAyCD;AAgBD;;;;;;;;;;AAUG;;AACH,OAAM,SAAU,eAAV,CACJ,KADI,EACsB;EAE1B,OAAO;IACL,KAAK,EAAE,UACL,GADK,EAEL,MAFK,EAGL,KAHK,EAG6B;MAElC,EAAE,CAAC,KAAH,CAAS,GAAT,EAAc,MAAd,EAAsB,KAAK,CAAC,IAA5B;MACA,KAAK,CAAC,KAAN,CAAY,GAAZ,EAAiB,MAAM,GAAG,CAA1B,EAA6B,KAAK,CAAC,IAAnC;IACD,CARI;IAUL,IAAI,EAAE,UAAU,GAAV,EAAuB,MAAvB,EAAqC;MACzC,MAAM,IAAI,GAAG,EAAE,CAAC,IAAH,CAAQ,GAAR,EAAa,MAAb,CAAb;MACA,MAAM,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,GAAX,EAAgB,MAAM,GAAG,CAAzB,CAAb;MACA,OAAO;QAAE,IAAF;QAAQ;MAAR,CAAP;IACD,CAdI;IAeL,QAAQ,EAAE,IAAI,KAAK,CAAC,QAff;IAgBL,WAAW,EAAE,mBAAmB,KAAK,CAAC,WAAW;EAhB5C,CAAP;AAkBD;;AASD,SAAS,mBAAT,CACE,KADF,EAEE,YAFF,EAGE,IAHF,EAGY;EAEV,OAAO;IACL,KAAK,CAAC,GAAD,EAAc,MAAd,EAA8B,KAA9B,EAAsC;MACzC,EAAE,CAAC,KAAH,CAAS,GAAT,EAAc,MAAd,EAAsB,YAAtB;MACA,KAAK,CAAC,KAAN,CAAY,GAAZ,EAAiB,MAAM,GAAG,EAAE,CAAC,QAA7B,EAAuC,KAAvC;IACD,CAJI;;IAML,IAAI,CAAC,GAAD,EAAc,MAAd,EAA4B;MAC9B,MAAM,GAAG,GAAM,KAAK,CAAC,IAAN,CAAW,GAAX,EAAgB,MAAM,GAAG,EAAE,CAAC,QAA5B,CAAf;MACA,OAAO;QAAE,MAAM,EAAE,IAAV;QAAgB,GAAG;MAAnB,CAAP;IACD,CATI;;IAWL,QAAQ,EAAE,KAAK,CAAC,QAAN,GAAiB,EAAE,CAAC,QAXzB;IAYL,WAAW,EAAE,YAAY,KAAK,CAAC,WAAW;EAZrC,CAAP;AAcD;AAED;;;;;;;;;;;;;;;;;;;;;;;AAuBG;;;AACH,OAAM,SAAU,QAAV,CACJ,QADI,EAC4B;EAEhC,KAAK,MAAM,CAAC,CAAD,EAAI,IAAJ,CAAX,IAAwB,QAAxB,EAAkC;IAChC,MAAM,CACJ,YAAY,CAAC,IAAD,CAAZ,IACE,mBAAmB,CAAC,IAAD,CADrB,IAEE;IACA,IAAI,KAAK,IAJP,EAKJ,gEALI,CAAN;EAOD;;EAED,OAAO;IACL,eAAe,CAAC,GAAD,EAAc,MAAd,EAA4B;MACzC,MAAM,YAAY,GAAG,EAAE,CAAC,IAAH,CAAQ,GAAR,EAAa,MAAb,CAArB;MACA,MAAM,OAAO,GAAG,QAAQ,CAAC,YAAD,CAAxB;MACA,MAAM,CACJ,OAAO,IAAI,IADP,EAEJ,gBAAgB,YAAY,qBAAqB,QAAQ,CAAC,MAAM,WAF5D,CAAN;MAIA,MAAM,CAAC,MAAD,EAAS,QAAT,IAAqB,OAA3B;MACA,MAAM,KAAK,GAAG,eAAe,CAAC,QAAD,CAAf,GACV,QADU,GAEV,QAAQ,CAAC,eAAT,CAAyB,GAAzB,EAA8B,MAAM,GAAG,CAAvC,CAFJ;MAIA,OAAO,mBAAmB,CAAC,KAAD,EAAQ,YAAR,EAAsB,MAAtB,CAA1B;IACD,CAdI;;IAgBL,gBAAgB,CAAC,GAAD,EAAS;MACvB,IAAI,GAAG,CAAC,MAAJ,IAAc,IAAlB,EAAwB;QACtB,MAAM,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,IAAjB,CAAsB,IAAtB,CAAb;QACA,MAAM,UAAU,GAAG,QAAQ,CAAC,GAAT,CAAa;UAAA,IAAC,CAAC,MAAD,CAAD;UAAA,OAAc,MAAd;QAAA,CAAb,EAAmC,IAAnC,CAAwC,IAAxC,CAAnB;QACA,MAAM,CAAC,IAAP,CACE,uBAAuB,IAAI,wBAA3B,GACE,qCAAqC,UAAU,IAFnD;MAID;;MAED,MAAM,YAAY,GAAG,QAAQ,CAAC,SAAT,CACnB;QAAA,IAAC,CAAC,MAAD,CAAD;QAAA,OAAc,MAAM,KAAK,GAAG,CAAC,MAA7B;MAAA,CADmB,CAArB;;MAGA,IAAI,YAAY,GAAG,CAAnB,EAAsB;QACpB,MAAM,UAAU,GAAG,QAAQ,CAAC,GAAT,CAAa;UAAA,IAAC,CAAC,MAAD,CAAD;UAAA,OAAc,MAAd;QAAA,CAAb,EAAmC,IAAnC,CAAwC,IAAxC,CAAnB;QACA,MAAM,CAAC,IAAP,CACE,GAAG,GAAG,CAAC,MAAM,8CAA8C,UAAU,IADvE;MAGD;;MACD,MAAM,OAAO,GAAG,QAAQ,CAAC,YAAD,CAAxB;MAEA,MAAM;QAAE,MAAF;QAAU,GAAG;MAAb,IAA2B,GAAjC;MACA,MAAM,CAAC,aAAD,EAAgB,QAAhB,IAA4B,OAAlC;MACA,MAAM,KAAK,GAAG,eAAe,CAAC,QAAD,CAAf,GACV,QADU,GAEV,QAAQ,CAAC,gBAAT,CAA0B,SAA1B,CAFJ;MAGA,OAAO,mBAAmB,CAAC,KAAD,EAAQ,YAAR,EAAsB,aAAtB,CAA1B;IACD,CA3CI;;IA6CL,WAAW,EAAE,YAAY,QAAQ,CAAC,MAAM;EA7CnC,CAAP;AA+CD;AAkBD;;;;;;AAMG;;AACH,OAAO,MAAM,YAAY,GAAiB;EACxC,eAAe,EAAE;IACf,IAAI,EAAE,iBADS;IAEf,SAAS,EAAE,KAFI;IAGf,UAAU,EAAE,YAHG;IAIf,EAAE,EAAE,YAJW;IAKf,GAAG,EAAE,mBALU;IAMf,IAAI,EAAE;EANS,CADuB;EASxC,QAAQ,EAAE;IACR,IAAI,EAAE,UADE;IAER,SAAS,EAAE,KAFH;IAGR,UAAU,EAAE,YAHJ;IAIR,EAAE,EAAE,uBAJI;IAKR,GAAG,EAAE,mBALG;IAMR,IAAI,EAAE;EANE;AAT8B,CAAnC","sourceRoot":"","sourcesContent":["import { BEET_PACKAGE, BEET_TYPE_ARG_INNER, isFixedSizeBeet, } from '../types';\nimport { u8 } from './numbers';\nimport { strict as assert } from 'assert';\nimport { isBeetStruct } from '../struct';\nimport { isFixableBeetStruct } from '../struct.fixable';\nimport { unit } from './unit';\n// -----------------\n// Fixed Scalar Enum\n// -----------------\nfunction resolveEnumVariant(value, isNumVariant) {\n    return (isNumVariant ? `${value}` : value);\n}\n/**\n * De/serializer for enums with up to 255 less variants which have no data.\n *\n * @param enumType type of enum to process, i.e. Color or Direction\n *\n * @category beet/enum\n */\nexport function fixedScalarEnum(enumType) {\n    const keys = Object.keys(enumType);\n    return {\n        write(buf, offset, value) {\n            const isNumVariant = typeof value === 'number';\n            const variantKey = resolveEnumVariant(value, isNumVariant);\n            if (!keys.includes(variantKey)) {\n                assert.fail(`${value} should be a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);\n            }\n            if (isNumVariant) {\n                u8.write(buf, offset, value);\n            }\n            else {\n                const enumValue = enumType[variantKey];\n                u8.write(buf, offset, enumValue);\n            }\n        },\n        read(buf, offset) {\n            const value = u8.read(buf, offset);\n            const isNumVariant = typeof value === 'number';\n            const variantKey = resolveEnumVariant(value, isNumVariant);\n            if (!keys.includes(variantKey)) {\n                assert.fail(`${value} should be a of a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(', ')} ], but isn't`);\n            }\n            return (isNumVariant ? value : enumType[variantKey]);\n        },\n        byteSize: u8.byteSize,\n        description: 'Enum',\n    };\n}\n/**\n * De/Serializes an {@link Enum} that contains a type of data, i.e. a {@link Struct}.\n * The main difference to a Rust enum is that the type of data has to be the\n * same for all enum variants.\n *\n * @template T inner enum data type\n *\n * @param inner the De/Serializer for the data type\n *\n * @category beet/enum\n */\nexport function uniformDataEnum(inner) {\n    return {\n        write: function (buf, offset, value) {\n            u8.write(buf, offset, value.kind);\n            inner.write(buf, offset + 1, value.data);\n        },\n        read: function (buf, offset) {\n            const kind = u8.read(buf, offset);\n            const data = inner.read(buf, offset + 1);\n            return { kind, data };\n        },\n        byteSize: 1 + inner.byteSize,\n        description: `UniformDataEnum<${inner.description}>`,\n    };\n}\nfunction enumDataVariantBeet(inner, discriminant, kind) {\n    return {\n        write(buf, offset, value) {\n            u8.write(buf, offset, discriminant);\n            inner.write(buf, offset + u8.byteSize, value);\n        },\n        read(buf, offset) {\n            const val = inner.read(buf, offset + u8.byteSize);\n            return { __kind: kind, ...val };\n        },\n        byteSize: inner.byteSize + u8.byteSize,\n        description: `EnumData<${inner.description}>`,\n    };\n}\n/**\n * De/serializes Data Enums.\n * They are represented as a discriminated unions in TypeScript.\n *\n * NOTE: only structs, i.e. {@link BeetArgsStruct} and\n * {@link FixableBeetArgsStruct} are supported as the data of each enum variant.\n *\n * ## Example\n *\n * ```ts\n * type Simple = {\n *   First: { n1: number }\n *   Second: { n2: number }\n * }\n *\n * const beet = dataEnum<Simple>([\n *   ['First', new BeetArgsStruct<Simple['First']>([['n1', u32]])],\n *   ['Second', new BeetArgsStruct<Simple['Second']>([['n2', u32]])],\n * ])\n * ```\n *\n * @category beet/enum\n * @param variants an array of {@link DataEnumBeet}s each a tuple of `[ kind, data ]`\n */\nexport function dataEnum(variants) {\n    for (const [_, beet] of variants) {\n        assert(isBeetStruct(beet) ||\n            isFixableBeetStruct(beet) ||\n            // scalar variant\n            beet === unit, 'dataEnum: variants must be a data beet struct or a scalar unit');\n    }\n    return {\n        toFixedFromData(buf, offset) {\n            const discriminant = u8.read(buf, offset);\n            const variant = variants[discriminant];\n            assert(variant != null, `Discriminant ${discriminant} out of range for ${variants.length} variants`);\n            const [__kind, dataBeet] = variant;\n            const fixed = isFixedSizeBeet(dataBeet)\n                ? dataBeet\n                : dataBeet.toFixedFromData(buf, offset + 1);\n            return enumDataVariantBeet(fixed, discriminant, __kind);\n        },\n        toFixedFromValue(val) {\n            if (val.__kind == null) {\n                const keys = Object.keys(val).join(', ');\n                const validKinds = variants.map(([__kind]) => __kind).join(', ');\n                assert.fail(`Value with fields [ ${keys} ] is missing __kind, ` +\n                    `which needs to be set to one of [ ${validKinds} ]`);\n            }\n            const discriminant = variants.findIndex(([__kind]) => __kind === val.__kind);\n            if (discriminant < 0) {\n                const validKinds = variants.map(([__kind]) => __kind).join(', ');\n                assert.fail(`${val.__kind} is not a valid kind, needs to be one of [ ${validKinds} ]`);\n            }\n            const variant = variants[discriminant];\n            const { __kind, ...dataValue } = val;\n            const [__variantKind, dataBeet] = variant;\n            const fixed = isFixedSizeBeet(dataBeet)\n                ? dataBeet\n                : dataBeet.toFixedFromValue(dataValue);\n            return enumDataVariantBeet(fixed, discriminant, __variantKind);\n        },\n        description: `DataEnum<${variants.length} variants>`,\n    };\n}\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexport const enumsTypeMap = {\n    fixedScalarEnum: {\n        beet: 'fixedScalarEnum',\n        isFixable: false,\n        sourcePack: BEET_PACKAGE,\n        ts: '<TypeName>',\n        arg: BEET_TYPE_ARG_INNER,\n        pack: BEET_PACKAGE,\n    },\n    dataEnum: {\n        beet: 'dataEnum',\n        isFixable: false,\n        sourcePack: BEET_PACKAGE,\n        ts: 'DataEnum<Kind, Inner>',\n        arg: BEET_TYPE_ARG_INNER,\n        pack: BEET_PACKAGE,\n    },\n};\n//# sourceMappingURL=enums.js.map"]},"metadata":{},"sourceType":"module"}