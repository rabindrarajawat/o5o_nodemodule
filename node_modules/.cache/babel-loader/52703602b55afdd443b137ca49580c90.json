{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FixableBeetArgsStruct = exports.isFixableBeetStruct = exports.FixableBeetStruct = void 0;\n\nconst beet_fixable_1 = require(\"./beet.fixable\");\n\nconst struct_1 = require(\"./struct\");\n\nconst types_1 = require(\"./types\");\n\nconst assert_1 = require(\"assert\");\n\nconst utils_1 = require(\"./utils\");\n\nconst ansicolors_1 = __importDefault(require(\"ansicolors\"));\n\nconst {\n  brightBlack\n} = ansicolors_1.default;\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. Not all fields of that class have to be of fixed size.\n * If none of the fields requires a {@link FixableBeet} use the {@link BeetStruct} instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */\n\nclass FixableBeetStruct {\n  /**\n   * Creates an instance of the {@link FixableBeetStruct}.\n   *\n   * @param fields fixed or fixable de/serializers for each field of the {@link Class}\n   * @param construct the function that creates an instance of {@link Class}\n   * from the args\n   * @param description identifies this struct for diagnostics/debugging\n   * purposes\n   */\n  constructor(fields, construct) {\n    let description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : FixableBeetStruct.description;\n    this.fields = fields;\n    this.construct = construct;\n    this.description = description;\n    let minByteSize = 0;\n\n    if (utils_1.logDebug.enabled) {\n      const flds = fields.map(_ref => {\n        let [key, val] = _ref;\n\n        if ((0, types_1.isFixedSizeBeet)(val)) {\n          minByteSize += val.byteSize;\n        }\n\n        return `${key}: ${val.description} ${(0, utils_1.beetBytes)(val)}`;\n      }).join('\\n  ');\n      const bytes = `> ${minByteSize} B`;\n      (0, utils_1.logDebug)(`struct ${description} {\\n  ${flds}\\n} ${brightBlack(bytes)}`);\n    }\n  }\n  /**\n   * Deserializes an instance of the Class from the provided buffer starting to\n   * read at the provided offset.\n   *\n   * @returns `[instance of Class, offset into buffer after deserialization completed]`\n   */\n\n\n  deserialize(buffer) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return this.toFixedFromData(buffer, offset).deserialize(buffer, offset);\n  }\n  /**\n   * Serializes the provided instance into a new {@link Buffer}\n   *\n   * **NOTE:** that the `instance` is traversed and each of its fields accessed\n   * twice, once to derive a _fixed size_ {@link BeetStruct} and then use it to\n   * serialize the `instance`.\n   * Therefore ensure that none of the properties that are part of the struct\n   * have side effects, i.e. via `Getter`s.\n   *\n   * @param instance of the struct to serialize\n   * @param byteSize allows to override the size fo the created Buffer and\n   * defaults to the size of the struct to serialize\n   */\n\n\n  serialize(instance, byteSize) {\n    return this.toFixedFromValue(instance).serialize(instance, byteSize);\n  }\n\n  toFixedFromData(buf, offset) {\n    let cursor = offset;\n    const fixedFields = new Array(this.fields.length);\n\n    for (let i = 0; i < this.fields.length; i++) {\n      const [key, beet] = this.fields[i];\n      const fixedBeet = (0, beet_fixable_1.fixBeetFromData)(beet, buf, cursor);\n      fixedFields[i] = [key, fixedBeet];\n      cursor += fixedBeet.byteSize;\n    }\n\n    return this.description !== FixableBeetStruct.description ? new struct_1.BeetStruct(fixedFields, this.construct, this.description) : new struct_1.BeetStruct(fixedFields, this.construct);\n  }\n\n  toFixedFromValue(args) {\n    const argsKeys = Object.keys(args);\n    const fixedFields = new Array(this.fields.length);\n\n    for (let i = 0; i < this.fields.length; i++) {\n      const [key, beet] = this.fields[i];\n      (0, assert_1.strict)(argsKeys.includes(key), `Value with keys [ ${argsKeys} ] should include struct key '${key}' but doesn't.`);\n      const val = args[key];\n      const fixedBeet = (0, beet_fixable_1.fixBeetFromValue)(beet, val);\n      fixedFields[i] = [key, fixedBeet];\n    }\n\n    return this.description !== FixableBeetStruct.description ? new struct_1.BeetStruct(fixedFields, this.construct, this.description) : new struct_1.BeetStruct(fixedFields, this.construct);\n  }\n\n  get type() {\n    return FixableBeetStruct.TYPE;\n  }\n\n}\n\nexports.FixableBeetStruct = FixableBeetStruct;\nFixableBeetStruct.description = 'FixableBeetStruct';\nFixableBeetStruct.TYPE = 'FixableBeetStruct';\n\nfunction isFixableBeetStruct(beet) {\n  return beet.type === FixableBeetStruct.TYPE;\n}\n\nexports.isFixableBeetStruct = isFixableBeetStruct;\n/**\n * Convenience wrapper around {@link FixableBeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */\n\nclass FixableBeetArgsStruct extends FixableBeetStruct {\n  constructor(fields) {\n    let description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FixableBeetArgsStruct.description;\n    super(fields, args => args, description);\n  }\n\n}\n\nexports.FixableBeetArgsStruct = FixableBeetArgsStruct;\nFixableBeetArgsStruct.description = 'FixableBeetArgsStruct';","map":{"version":3,"sources":["../../../src/struct.fixable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FixableBeetArgsStruct = exports.isFixableBeetStruct = exports.FixableBeetStruct = void 0;\nconst beet_fixable_1 = require(\"./beet.fixable\");\nconst struct_1 = require(\"./struct\");\nconst types_1 = require(\"./types\");\nconst assert_1 = require(\"assert\");\nconst utils_1 = require(\"./utils\");\nconst ansicolors_1 = __importDefault(require(\"ansicolors\"));\nconst { brightBlack } = ansicolors_1.default;\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. Not all fields of that class have to be of fixed size.\n * If none of the fields requires a {@link FixableBeet} use the {@link BeetStruct} instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */\nclass FixableBeetStruct {\n    /**\n     * Creates an instance of the {@link FixableBeetStruct}.\n     *\n     * @param fields fixed or fixable de/serializers for each field of the {@link Class}\n     * @param construct the function that creates an instance of {@link Class}\n     * from the args\n     * @param description identifies this struct for diagnostics/debugging\n     * purposes\n     */\n    constructor(fields, construct, description = FixableBeetStruct.description) {\n        this.fields = fields;\n        this.construct = construct;\n        this.description = description;\n        let minByteSize = 0;\n        if (utils_1.logDebug.enabled) {\n            const flds = fields\n                .map(([key, val]) => {\n                if ((0, types_1.isFixedSizeBeet)(val)) {\n                    minByteSize += val.byteSize;\n                }\n                return `${key}: ${val.description} ${(0, utils_1.beetBytes)(val)}`;\n            })\n                .join('\\n  ');\n            const bytes = `> ${minByteSize} B`;\n            (0, utils_1.logDebug)(`struct ${description} {\\n  ${flds}\\n} ${brightBlack(bytes)}`);\n        }\n    }\n    /**\n     * Deserializes an instance of the Class from the provided buffer starting to\n     * read at the provided offset.\n     *\n     * @returns `[instance of Class, offset into buffer after deserialization completed]`\n     */\n    deserialize(buffer, offset = 0) {\n        return this.toFixedFromData(buffer, offset).deserialize(buffer, offset);\n    }\n    /**\n     * Serializes the provided instance into a new {@link Buffer}\n     *\n     * **NOTE:** that the `instance` is traversed and each of its fields accessed\n     * twice, once to derive a _fixed size_ {@link BeetStruct} and then use it to\n     * serialize the `instance`.\n     * Therefore ensure that none of the properties that are part of the struct\n     * have side effects, i.e. via `Getter`s.\n     *\n     * @param instance of the struct to serialize\n     * @param byteSize allows to override the size fo the created Buffer and\n     * defaults to the size of the struct to serialize\n     */\n    serialize(instance, byteSize) {\n        return this.toFixedFromValue(instance).serialize(instance, byteSize);\n    }\n    toFixedFromData(buf, offset) {\n        let cursor = offset;\n        const fixedFields = new Array(this.fields.length);\n        for (let i = 0; i < this.fields.length; i++) {\n            const [key, beet] = this.fields[i];\n            const fixedBeet = (0, beet_fixable_1.fixBeetFromData)(beet, buf, cursor);\n            fixedFields[i] = [key, fixedBeet];\n            cursor += fixedBeet.byteSize;\n        }\n        return this.description !== FixableBeetStruct.description\n            ? new struct_1.BeetStruct(fixedFields, this.construct, this.description)\n            : new struct_1.BeetStruct(fixedFields, this.construct);\n    }\n    toFixedFromValue(args) {\n        const argsKeys = Object.keys(args);\n        const fixedFields = new Array(this.fields.length);\n        for (let i = 0; i < this.fields.length; i++) {\n            const [key, beet] = this.fields[i];\n            (0, assert_1.strict)(argsKeys.includes(key), `Value with keys [ ${argsKeys} ] should include struct key '${key}' but doesn't.`);\n            const val = args[key];\n            const fixedBeet = (0, beet_fixable_1.fixBeetFromValue)(beet, val);\n            fixedFields[i] = [key, fixedBeet];\n        }\n        return this.description !== FixableBeetStruct.description\n            ? new struct_1.BeetStruct(fixedFields, this.construct, this.description)\n            : new struct_1.BeetStruct(fixedFields, this.construct);\n    }\n    get type() {\n        return FixableBeetStruct.TYPE;\n    }\n}\nexports.FixableBeetStruct = FixableBeetStruct;\nFixableBeetStruct.description = 'FixableBeetStruct';\nFixableBeetStruct.TYPE = 'FixableBeetStruct';\nfunction isFixableBeetStruct(beet) {\n    return beet.type === FixableBeetStruct.TYPE;\n}\nexports.isFixableBeetStruct = isFixableBeetStruct;\n/**\n * Convenience wrapper around {@link FixableBeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */\nclass FixableBeetArgsStruct extends FixableBeetStruct {\n    constructor(fields, description = FixableBeetArgsStruct.description) {\n        super(fields, (args) => args, description);\n    }\n}\nexports.FixableBeetArgsStruct = FixableBeetArgsStruct;\nFixableBeetArgsStruct.description = 'FixableBeetArgsStruct';\n//# sourceMappingURL=struct.fixable.js.map"]},"metadata":{},"sourceType":"script"}