{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BeetArgsStruct = exports.isBeetStruct = exports.BeetStruct = void 0;\n\nconst read_write_1 = require(\"./read-write\");\n\nconst utils_1 = require(\"./utils\");\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. All fields of that class have to be of fixed size.\n * If a field requires a {@link FixableBeet} use the {@link FixableBeetStruct}\n * instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */\n\n\nclass BeetStruct {\n  /**\n   * Creates an instance of the BeetStruct.\n   *\n   * @param fields de/serializers for each field of the {@link Class}\n   * @param construct the function that creates an instance of {@link Class}\n   * from the args\n   * @param description identifies this struct for diagnostics/debugging\n   * purposes\n   */\n  constructor(fields, construct) {\n    let description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BeetStruct.description;\n    this.fields = fields;\n    this.construct = construct;\n    this.description = description;\n    this.byteSize = this.getByteSize();\n\n    if (utils_1.logDebug.enabled) {\n      const flds = fields.map(_ref => {\n        let [key, val] = _ref;\n        return `${String(key)}: ${val.description} ${(0, utils_1.beetBytes)(val)}`;\n      }).join('\\n  ');\n      (0, utils_1.logDebug)(`struct ${description} {\\n  ${flds}\\n} ${(0, utils_1.beetBytes)(this)}`);\n    }\n  }\n  /**\n   * Along with `write` this allows structs to be treated as {@link Beet}s and\n   * thus supports composing/nesting them the same way.\n   * @private\n   */\n\n\n  read(buf, offset) {\n    const [value] = this.deserialize(buf, offset);\n    return value;\n  }\n  /**\n   * Along with `read` this allows structs to be treated as {@link Beet}s and\n   * thus supports composing/nesting them the same way.\n   * @private\n   */\n\n\n  write(buf, offset, value) {\n    const [innerBuf, innerOffset] = this.serialize(value);\n    innerBuf.copy(buf, offset, 0, innerOffset);\n  }\n  /**\n   * Deserializes an instance of the Class from the provided buffer starting to\n   * read at the provided offset.\n   *\n   * @returns `[instance of Class, offset into buffer after deserialization completed]`\n   */\n\n\n  deserialize(buffer) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (utils_1.logTrace.enabled) {\n      (0, utils_1.logTrace)('deserializing [%s] from %d bytes buffer', this.description, buffer.byteLength);\n      (0, utils_1.logTrace)(buffer);\n      (0, utils_1.logTrace)(buffer.toJSON().data);\n    }\n\n    const reader = new read_write_1.BeetReader(buffer, offset);\n    const args = reader.readStruct(this.fields);\n    return [this.construct(args), reader.offset];\n  }\n  /**\n   * Serializes the provided instance into a new {@link Buffer}\n   *\n   * @param instance of the struct to serialize\n   * @param byteSize allows to override the size fo the created Buffer and\n   * defaults to the size of the struct to serialize\n   */\n\n\n  serialize(instance) {\n    let byteSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.byteSize;\n    (0, utils_1.logTrace)('serializing [%s] %o to %d bytes buffer', this.description, instance, byteSize);\n    const writer = new read_write_1.BeetWriter(byteSize);\n    writer.writeStruct(instance, this.fields);\n    return [writer.buffer, writer.offset];\n  }\n\n  getByteSize() {\n    return this.fields.reduce((acc, _ref2) => {\n      let [_, beet] = _ref2;\n      return acc + beet.byteSize;\n    }, 0);\n  }\n\n  get type() {\n    return BeetStruct.TYPE;\n  }\n\n}\n\nexports.BeetStruct = BeetStruct;\nBeetStruct.description = 'BeetStruct';\nBeetStruct.TYPE = 'BeetStruct';\n\nfunction isBeetStruct(beet) {\n  return beet.type === BeetStruct.TYPE;\n}\n\nexports.isBeetStruct = isBeetStruct;\n/**\n * Convenience wrapper around {@link BeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */\n\nclass BeetArgsStruct extends BeetStruct {\n  constructor(fields) {\n    let description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BeetArgsStruct.description;\n    super(fields, args => args, description);\n  }\n\n}\n\nexports.BeetArgsStruct = BeetArgsStruct;\nBeetArgsStruct.description = 'BeetArgsStruct';","map":{"version":3,"sources":["../../../src/struct.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BeetArgsStruct = exports.isBeetStruct = exports.BeetStruct = void 0;\nconst read_write_1 = require(\"./read-write\");\nconst utils_1 = require(\"./utils\");\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. All fields of that class have to be of fixed size.\n * If a field requires a {@link FixableBeet} use the {@link FixableBeetStruct}\n * instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */\nclass BeetStruct {\n    /**\n     * Creates an instance of the BeetStruct.\n     *\n     * @param fields de/serializers for each field of the {@link Class}\n     * @param construct the function that creates an instance of {@link Class}\n     * from the args\n     * @param description identifies this struct for diagnostics/debugging\n     * purposes\n     */\n    constructor(fields, construct, description = BeetStruct.description) {\n        this.fields = fields;\n        this.construct = construct;\n        this.description = description;\n        this.byteSize = this.getByteSize();\n        if (utils_1.logDebug.enabled) {\n            const flds = fields\n                .map(([key, val]) => `${String(key)}: ${val.description} ${(0, utils_1.beetBytes)(val)}`)\n                .join('\\n  ');\n            (0, utils_1.logDebug)(`struct ${description} {\\n  ${flds}\\n} ${(0, utils_1.beetBytes)(this)}`);\n        }\n    }\n    /**\n     * Along with `write` this allows structs to be treated as {@link Beet}s and\n     * thus supports composing/nesting them the same way.\n     * @private\n     */\n    read(buf, offset) {\n        const [value] = this.deserialize(buf, offset);\n        return value;\n    }\n    /**\n     * Along with `read` this allows structs to be treated as {@link Beet}s and\n     * thus supports composing/nesting them the same way.\n     * @private\n     */\n    write(buf, offset, value) {\n        const [innerBuf, innerOffset] = this.serialize(value);\n        innerBuf.copy(buf, offset, 0, innerOffset);\n    }\n    /**\n     * Deserializes an instance of the Class from the provided buffer starting to\n     * read at the provided offset.\n     *\n     * @returns `[instance of Class, offset into buffer after deserialization completed]`\n     */\n    deserialize(buffer, offset = 0) {\n        if (utils_1.logTrace.enabled) {\n            (0, utils_1.logTrace)('deserializing [%s] from %d bytes buffer', this.description, buffer.byteLength);\n            (0, utils_1.logTrace)(buffer);\n            (0, utils_1.logTrace)(buffer.toJSON().data);\n        }\n        const reader = new read_write_1.BeetReader(buffer, offset);\n        const args = reader.readStruct(this.fields);\n        return [this.construct(args), reader.offset];\n    }\n    /**\n     * Serializes the provided instance into a new {@link Buffer}\n     *\n     * @param instance of the struct to serialize\n     * @param byteSize allows to override the size fo the created Buffer and\n     * defaults to the size of the struct to serialize\n     */\n    serialize(instance, byteSize = this.byteSize) {\n        (0, utils_1.logTrace)('serializing [%s] %o to %d bytes buffer', this.description, instance, byteSize);\n        const writer = new read_write_1.BeetWriter(byteSize);\n        writer.writeStruct(instance, this.fields);\n        return [writer.buffer, writer.offset];\n    }\n    getByteSize() {\n        return this.fields.reduce((acc, [_, beet]) => acc + beet.byteSize, 0);\n    }\n    get type() {\n        return BeetStruct.TYPE;\n    }\n}\nexports.BeetStruct = BeetStruct;\nBeetStruct.description = 'BeetStruct';\nBeetStruct.TYPE = 'BeetStruct';\nfunction isBeetStruct(beet) {\n    return beet.type === BeetStruct.TYPE;\n}\nexports.isBeetStruct = isBeetStruct;\n/**\n * Convenience wrapper around {@link BeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */\nclass BeetArgsStruct extends BeetStruct {\n    constructor(fields, description = BeetArgsStruct.description) {\n        super(fields, (args) => args, description);\n    }\n}\nexports.BeetArgsStruct = BeetArgsStruct;\nBeetArgsStruct.description = 'BeetArgsStruct';\n//# sourceMappingURL=struct.js.map"]},"metadata":{},"sourceType":"script"}