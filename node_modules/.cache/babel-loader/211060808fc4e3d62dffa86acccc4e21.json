{"ast":null,"code":"import { createExecutePartialSaleInstruction, createExecuteSaleInstruction, createAuctioneerExecuteSaleInstruction, createPrintPurchaseReceiptInstruction } from '@metaplex-foundation/mpl-auction-house';\nimport { SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { BidAndListingHaveDifferentAuctionHousesError, BidAndListingHaveDifferentMintsError, CanceledBidIsNotAllowedError, CanceledListingIsNotAllowedError, AuctioneerAuthorityRequiredError, AuctioneerPartialSaleNotSupportedError, PartialPriceMismatchError } from '../errors.mjs';\nimport { useOperation } from '../../../types/Operation.mjs';\nimport { now } from '../../../types/DateTime.mjs';\nimport { lamports, amount } from '../../../types/Amount.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs';\nimport { isSigner } from '../../../types/Signer.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'ExecuteSaleOperation';\n/**\n * Executes a sale on a given bid and listing.\n *\n * ```ts\n * await metaplex\n *   .auctionHouse()\n *   .executeSale({ auctionHouse, bid, listing };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst executeSaleOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * Executes a sale on a given bid and listing.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .auctionHouse()\n *   .builders()\n *   .executeSale({ auctionHouse, listing, bid });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst executeSaleOperationHandler = {\n  async handle(operation, metaplex, scope) {\n    const {\n      auctionHouse\n    } = operation.input;\n    const output = await executeSaleBuilder(metaplex, operation.input, scope).sendAndConfirm(metaplex, scope.confirmOptions);\n    scope.throwIfCanceled();\n\n    if (output.receipt) {\n      const purchase = await metaplex.auctionHouse().findPurchaseByReceipt({\n        auctionHouse,\n        receiptAddress: output.receipt\n      }, scope);\n      return {\n        purchase,\n        ...output\n      };\n    }\n\n    const lazyPurchase = {\n      model: 'purchase',\n      lazy: true,\n      auctionHouse: operation.input.auctionHouse,\n      buyerAddress: output.buyer,\n      sellerAddress: output.seller,\n      metadataAddress: output.metadata,\n      bookkeeperAddress: output.bookkeeper,\n      receiptAddress: output.receipt,\n      price: output.price,\n      tokens: output.tokens.basisPoints,\n      createdAt: now()\n    };\n    return {\n      purchase: await metaplex.auctionHouse().loadPurchase({\n        lazyPurchase\n      }, scope),\n      ...output\n    };\n  }\n\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst executeSaleBuilder = function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    auctionHouse,\n    listing,\n    bid,\n    auctioneerAuthority\n  } = params;\n  const {\n    sellerAddress,\n    asset\n  } = listing;\n  const {\n    buyerAddress\n  } = bid;\n  const {\n    hasAuctioneer,\n    isNative,\n    treasuryMint,\n    address: auctionHouseAddress,\n    authorityAddress,\n    feeAccountAddress,\n    treasuryAccountAddress\n  } = auctionHouse;\n  const isPartialSale = bid.tokens.basisPoints < listing.tokens.basisPoints; // Use full size of listing & price when finding trade state PDA for the partial sale.\n\n  const {\n    tokens,\n    price\n  } = isPartialSale ? listing : bid;\n  const {\n    price: buyerPrice,\n    tokens: buyerTokensSize\n  } = bid;\n\n  if (!listing.auctionHouse.address.equals(bid.auctionHouse.address)) {\n    throw new BidAndListingHaveDifferentAuctionHousesError();\n  }\n\n  if (!listing.asset.address.equals(bid.asset.address)) {\n    throw new BidAndListingHaveDifferentMintsError();\n  }\n\n  if (bid.canceledAt) {\n    throw new CanceledBidIsNotAllowedError();\n  }\n\n  if (listing.canceledAt) {\n    throw new CanceledListingIsNotAllowedError();\n  }\n\n  if (hasAuctioneer && !auctioneerAuthority) {\n    throw new AuctioneerAuthorityRequiredError();\n  }\n\n  if (isPartialSale && hasAuctioneer) {\n    throw new AuctioneerPartialSaleNotSupportedError();\n  }\n\n  if (isPartialSale) {\n    const listingPricePerToken = price.basisPoints.div(tokens.basisPoints);\n    const buyerPricePerToken = buyerPrice.basisPoints.div(buyerTokensSize.basisPoints);\n\n    if (!listingPricePerToken.eq(buyerPricePerToken)) {\n      throw new PartialPriceMismatchError(auctionHouse.isNative ? lamports(listingPricePerToken) : amount(listingPricePerToken, auctionHouse.treasuryMint.currency), auctionHouse.isNative ? lamports(buyerPricePerToken) : amount(buyerPricePerToken, auctionHouse.treasuryMint.currency));\n    }\n  } // Accounts.\n\n\n  const sellerPaymentReceiptAccount = isNative ? sellerAddress : metaplex.tokens().pdas().associatedTokenAccount({\n    mint: treasuryMint.address,\n    owner: sellerAddress,\n    programs\n  });\n  const buyerReceiptTokenAccount = metaplex.tokens().pdas().associatedTokenAccount({\n    mint: asset.address,\n    owner: buyerAddress,\n    programs\n  });\n  const escrowPayment = metaplex.auctionHouse().pdas().buyerEscrow({\n    auctionHouse: auctionHouseAddress,\n    buyer: buyerAddress,\n    programs\n  });\n  const freeTradeState = metaplex.auctionHouse().pdas().tradeState({\n    auctionHouse: auctionHouseAddress,\n    wallet: sellerAddress,\n    treasuryMint: treasuryMint.address,\n    tokenMint: asset.address,\n    price: lamports(0).basisPoints,\n    tokenSize: tokens.basisPoints,\n    tokenAccount: asset.token.address,\n    programs\n  });\n  const programAsSigner = metaplex.auctionHouse().pdas().programAsSigner();\n  const accounts = {\n    buyer: buyerAddress,\n    seller: sellerAddress,\n    tokenAccount: asset.token.address,\n    tokenMint: asset.address,\n    metadata: asset.metadataAddress,\n    treasuryMint: treasuryMint.address,\n    escrowPaymentAccount: escrowPayment,\n    sellerPaymentReceiptAccount,\n    buyerReceiptTokenAccount,\n    authority: authorityAddress,\n    auctionHouse: auctionHouseAddress,\n    auctionHouseFeeAccount: feeAccountAddress,\n    auctionHouseTreasury: treasuryAccountAddress,\n    buyerTradeState: bid.tradeStateAddress,\n    sellerTradeState: listing.tradeStateAddress,\n    freeTradeState,\n    programAsSigner\n  }; // Args.\n\n  const args = {\n    freeTradeStateBump: freeTradeState.bump,\n    escrowPaymentBump: escrowPayment.bump,\n    programAsSignerBump: programAsSigner.bump,\n    buyerPrice: price.basisPoints,\n    tokenSize: tokens.basisPoints\n  }; // Execute Sale Instruction\n\n  const partialSaleArgs = { ...args,\n    partialOrderSize: bid.tokens.basisPoints,\n    partialOrderPrice: bid.price.basisPoints\n  };\n  let executeSaleInstruction = isPartialSale ? createExecutePartialSaleInstruction(accounts, partialSaleArgs) : createExecuteSaleInstruction(accounts, args);\n\n  if (auctioneerAuthority) {\n    const auctioneerAccounts = { ...accounts,\n      auctioneerAuthority: auctioneerAuthority.publicKey,\n      ahAuctioneerPda: metaplex.auctionHouse().pdas().auctioneer({\n        auctionHouse: auctionHouse.address,\n        auctioneerAuthority: auctioneerAuthority.publicKey,\n        programs\n      })\n    };\n    executeSaleInstruction = createAuctioneerExecuteSaleInstruction(auctioneerAccounts, args);\n  } // Provide additional keys to pay royalties.\n\n\n  asset.creators.forEach(_ref => {\n    let {\n      address\n    } = _ref;\n    executeSaleInstruction.keys.push({\n      pubkey: address,\n      isWritable: true,\n      isSigner: false\n    }); // Provide ATA to receive SPL token royalty if is not native SOL sale.\n\n    if (!isNative) {\n      executeSaleInstruction.keys.push({\n        pubkey: metaplex.tokens().pdas().associatedTokenAccount({\n          mint: treasuryMint.address,\n          owner: address,\n          programs\n        }),\n        isWritable: true,\n        isSigner: false\n      });\n    }\n  }); // Signers.\n\n  const executeSaleSigners = [auctioneerAuthority].filter(isSigner); // Receipt.\n\n  const shouldPrintReceipt = (params.printReceipt ?? true) && Boolean(listing.receiptAddress && bid.receiptAddress && !isPartialSale);\n  const bookkeeper = params.bookkeeper ?? metaplex.identity();\n  const purchaseReceipt = metaplex.auctionHouse().pdas().purchaseReceipt({\n    listingTradeState: listing.tradeStateAddress,\n    bidTradeState: bid.tradeStateAddress,\n    programs\n  });\n  return TransactionBuilder.make().setFeePayer(payer).setContext({\n    sellerTradeState: listing.tradeStateAddress,\n    buyerTradeState: bid.tradeStateAddress,\n    buyer: buyerAddress,\n    seller: sellerAddress,\n    metadata: asset.metadataAddress,\n    bookkeeper: shouldPrintReceipt ? bookkeeper.publicKey : null,\n    receipt: shouldPrintReceipt ? purchaseReceipt : null,\n    price,\n    tokens\n  }) // Execute Sale.\n  .add({\n    instruction: executeSaleInstruction,\n    signers: executeSaleSigners,\n    key: params.instructionKey ?? 'executeSale'\n  }) // Print the Purchase Receipt.\n  .when(shouldPrintReceipt, builder => builder.add({\n    instruction: createPrintPurchaseReceiptInstruction({\n      purchaseReceipt,\n      listingReceipt: listing.receiptAddress,\n      bidReceipt: bid.receiptAddress,\n      bookkeeper: bookkeeper.publicKey,\n      instruction: SYSVAR_INSTRUCTIONS_PUBKEY\n    }, {\n      purchaseReceiptBump: purchaseReceipt.bump\n    }),\n    signers: [bookkeeper],\n    key: 'printPurchaseReceipt'\n  }));\n};\n\nexport { executeSaleBuilder, executeSaleOperation, executeSaleOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/auctionHouseModule/operations/executeSale.ts"],"names":["Key","executeSaleOperation","useOperation","executeSaleOperationHandler","handle","operation","metaplex","scope","auctionHouse","input","output","executeSaleBuilder","sendAndConfirm","confirmOptions","throwIfCanceled","receipt","purchase","findPurchaseByReceipt","receiptAddress","lazyPurchase","model","lazy","buyerAddress","buyer","sellerAddress","seller","metadataAddress","metadata","bookkeeperAddress","bookkeeper","price","tokens","basisPoints","createdAt","now","loadPurchase","params","options","programs","payer","rpc","getDefaultFeePayer","listing","bid","auctioneerAuthority","asset","hasAuctioneer","isNative","treasuryMint","address","auctionHouseAddress","authorityAddress","feeAccountAddress","treasuryAccountAddress","isPartialSale","buyerPrice","buyerTokensSize","equals","BidAndListingHaveDifferentAuctionHousesError","BidAndListingHaveDifferentMintsError","canceledAt","CanceledBidIsNotAllowedError","CanceledListingIsNotAllowedError","AuctioneerAuthorityRequiredError","AuctioneerPartialSaleNotSupportedError","listingPricePerToken","div","buyerPricePerToken","eq","PartialPriceMismatchError","lamports","amount","currency","sellerPaymentReceiptAccount","pdas","associatedTokenAccount","mint","owner","buyerReceiptTokenAccount","escrowPayment","buyerEscrow","freeTradeState","tradeState","wallet","tokenMint","tokenSize","tokenAccount","token","programAsSigner","accounts","escrowPaymentAccount","authority","auctionHouseFeeAccount","auctionHouseTreasury","buyerTradeState","tradeStateAddress","sellerTradeState","args","freeTradeStateBump","bump","escrowPaymentBump","programAsSignerBump","partialSaleArgs","partialOrderSize","partialOrderPrice","executeSaleInstruction","createExecutePartialSaleInstruction","createExecuteSaleInstruction","auctioneerAccounts","publicKey","ahAuctioneerPda","auctioneer","createAuctioneerExecuteSaleInstruction","creators","forEach","keys","push","pubkey","isWritable","isSigner","executeSaleSigners","filter","shouldPrintReceipt","printReceipt","Boolean","identity","purchaseReceipt","listingTradeState","bidTradeState","TransactionBuilder","make","setFeePayer","setContext","add","instruction","signers","key","instructionKey","when","builder","createPrintPurchaseReceiptInstruction","listingReceipt","bidReceipt","SYSVAR_INSTRUCTIONS_PUBKEY","purchaseReceiptBump"],"mappings":"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","sourcesContent":["import {\n  AuctioneerExecuteSaleInstructionAccounts,\n  createAuctioneerExecuteSaleInstruction,\n  createExecutePartialSaleInstruction,\n  createExecuteSaleInstruction,\n  createPrintPurchaseReceiptInstruction,\n  ExecutePartialSaleInstructionArgs,\n} from '@metaplex-foundation/mpl-auction-house';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  AuctioneerAuthorityRequiredError,\n  AuctioneerPartialSaleNotSupportedError,\n  BidAndListingHaveDifferentAuctionHousesError,\n  BidAndListingHaveDifferentMintsError,\n  CanceledBidIsNotAllowedError,\n  CanceledListingIsNotAllowedError,\n  PartialPriceMismatchError,\n} from '../errors';\nimport { AuctionHouse, Bid, LazyPurchase, Listing, Purchase } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  amount,\n  isSigner,\n  lamports,\n  now,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Pda,\n  Signer,\n  SolAmount,\n  SplTokenAmount,\n  useOperation,\n} from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'ExecuteSaleOperation' as const;\n\n/**\n * Executes a sale on a given bid and listing.\n *\n * ```ts\n * await metaplex\n *   .auctionHouse()\n *   .executeSale({ auctionHouse, bid, listing };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const executeSaleOperation = useOperation<ExecuteSaleOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type ExecuteSaleOperation = Operation<\n  typeof Key,\n  ExecuteSaleInput,\n  ExecuteSaleOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type ExecuteSaleInput = {\n  /**\n   * The Bid that is used in the sale.\n   * We only need a subset of the `Bid` model but we\n   * need enough information regarding its settings to know how\n   * to execute the sale.\n   *\n   * This includes, its asset, auction house address, buyer, receipt address etc.\n   */\n  bid: Pick<\n    Bid,\n    | 'asset'\n    | 'auctionHouse'\n    | 'buyerAddress'\n    | 'canceledAt'\n    | 'price'\n    | 'receiptAddress'\n    | 'tokens'\n    | 'tradeStateAddress'\n  >;\n\n  /**\n   * The Listing that is used in the sale.\n   * We only need a subset of the `Listing` model but we\n   * need enough information regarding its settings to know how\n   * to execute the sale.\n   *\n   * This includes, its asset, auction house address, seller, receipt address etc.\n   */\n  listing: Pick<\n    Listing,\n    | 'asset'\n    | 'auctionHouse'\n    | 'canceledAt'\n    | 'price'\n    | 'receiptAddress'\n    | 'sellerAddress'\n    | 'tokens'\n    | 'tradeStateAddress'\n  >;\n\n  /** The Auction House in which to execute a sale. */\n  auctionHouse: AuctionHouse;\n\n  /**\n   * The Auctioneer authority key.\n   * It is required when Auction House has Auctioneer enabled.\n   *\n   * @defaultValue No default value.\n   */\n  auctioneerAuthority?: Signer; // Use Auctioneer ix when provided\n\n  /**\n   * The address of the bookkeeper wallet responsible for the receipt.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  bookkeeper?: Signer;\n\n  /**\n   * Prints the purchase receipt.\n   * The receipt holds information about the purchase,\n   * So it's important to print it if you want to use the `Purchase` model\n   *\n   * @defaultValue `true`\n   */\n  printReceipt?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type ExecuteSaleOutput = {\n  /** Seller trade state account address encoding the listing order. */\n  sellerTradeState: PublicKey;\n\n  /** Biyer trade state account address encoding the bid order. */\n  buyerTradeState: PublicKey;\n\n  /** The buyer address. */\n  buyer: PublicKey;\n\n  /** The seller address. */\n  seller: PublicKey;\n\n  /** The asset's metadata address. */\n  metadata: PublicKey;\n\n  /** The address of the bookkeeper account responsible for the receipt. */\n  bookkeeper: Option<PublicKey>;\n\n  /** The PDA of the receipt account in case it was printed. */\n  receipt: Option<Pda>;\n\n  /** The sale price. */\n  price: SolAmount | SplTokenAmount;\n\n  /** The number of tokens bought. */\n  tokens: SplTokenAmount;\n\n  /** A model that keeps information about the Purchase. */\n  purchase: Purchase;\n\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * Executes a sale on a given bid and listing.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .auctionHouse()\n *   .builders()\n *   .executeSale({ auctionHouse, listing, bid });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const executeSaleOperationHandler: OperationHandler<ExecuteSaleOperation> =\n  {\n    async handle(\n      operation: ExecuteSaleOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<ExecuteSaleOutput> {\n      const { auctionHouse } = operation.input;\n\n      const output = await executeSaleBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n      scope.throwIfCanceled();\n\n      if (output.receipt) {\n        const purchase = await metaplex\n          .auctionHouse()\n          .findPurchaseByReceipt(\n            { auctionHouse, receiptAddress: output.receipt },\n            scope\n          );\n\n        return { purchase, ...output };\n      }\n\n      const lazyPurchase: LazyPurchase = {\n        model: 'purchase',\n        lazy: true,\n        auctionHouse: operation.input.auctionHouse,\n        buyerAddress: output.buyer,\n        sellerAddress: output.seller,\n        metadataAddress: output.metadata,\n        bookkeeperAddress: output.bookkeeper,\n        receiptAddress: output.receipt,\n        price: output.price,\n        tokens: output.tokens.basisPoints,\n        createdAt: now(),\n      };\n\n      return {\n        purchase: await metaplex\n          .auctionHouse()\n          .loadPurchase({ lazyPurchase }, scope),\n        ...output,\n      };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type ExecuteSaleBuilderParams = Omit<\n  ExecuteSaleInput,\n  'confirmOptions'\n> & {\n  instructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type ExecuteSaleBuilderContext = Omit<\n  ExecuteSaleOutput,\n  'response' | 'purchase'\n>;\n\n/**\n * @group Transaction Builders\n * @category Constructors\n */\nexport const executeSaleBuilder = (\n  metaplex: Metaplex,\n  params: ExecuteSaleBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder<ExecuteSaleBuilderContext> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { auctionHouse, listing, bid, auctioneerAuthority } = params;\n  const { sellerAddress, asset } = listing;\n  const { buyerAddress } = bid;\n  const {\n    hasAuctioneer,\n    isNative,\n    treasuryMint,\n    address: auctionHouseAddress,\n    authorityAddress,\n    feeAccountAddress,\n    treasuryAccountAddress,\n  } = auctionHouse;\n\n  const isPartialSale = bid.tokens.basisPoints < listing.tokens.basisPoints;\n\n  // Use full size of listing & price when finding trade state PDA for the partial sale.\n  const { tokens, price } = isPartialSale ? listing : bid;\n  const { price: buyerPrice, tokens: buyerTokensSize } = bid;\n\n  if (!listing.auctionHouse.address.equals(bid.auctionHouse.address)) {\n    throw new BidAndListingHaveDifferentAuctionHousesError();\n  }\n  if (!listing.asset.address.equals(bid.asset.address)) {\n    throw new BidAndListingHaveDifferentMintsError();\n  }\n  if (bid.canceledAt) {\n    throw new CanceledBidIsNotAllowedError();\n  }\n  if (listing.canceledAt) {\n    throw new CanceledListingIsNotAllowedError();\n  }\n  if (hasAuctioneer && !auctioneerAuthority) {\n    throw new AuctioneerAuthorityRequiredError();\n  }\n  if (isPartialSale && hasAuctioneer) {\n    throw new AuctioneerPartialSaleNotSupportedError();\n  }\n  if (isPartialSale) {\n    const listingPricePerToken = price.basisPoints.div(tokens.basisPoints);\n    const buyerPricePerToken = buyerPrice.basisPoints.div(\n      buyerTokensSize.basisPoints\n    );\n\n    if (!listingPricePerToken.eq(buyerPricePerToken)) {\n      throw new PartialPriceMismatchError(\n        auctionHouse.isNative\n          ? lamports(listingPricePerToken)\n          : amount(listingPricePerToken, auctionHouse.treasuryMint.currency),\n        auctionHouse.isNative\n          ? lamports(buyerPricePerToken)\n          : amount(buyerPricePerToken, auctionHouse.treasuryMint.currency)\n      );\n    }\n  }\n\n  // Accounts.\n  const sellerPaymentReceiptAccount = isNative\n    ? sellerAddress\n    : metaplex.tokens().pdas().associatedTokenAccount({\n        mint: treasuryMint.address,\n        owner: sellerAddress,\n        programs,\n      });\n  const buyerReceiptTokenAccount = metaplex\n    .tokens()\n    .pdas()\n    .associatedTokenAccount({\n      mint: asset.address,\n      owner: buyerAddress,\n      programs,\n    });\n  const escrowPayment = metaplex.auctionHouse().pdas().buyerEscrow({\n    auctionHouse: auctionHouseAddress,\n    buyer: buyerAddress,\n    programs,\n  });\n  const freeTradeState = metaplex\n    .auctionHouse()\n    .pdas()\n    .tradeState({\n      auctionHouse: auctionHouseAddress,\n      wallet: sellerAddress,\n      treasuryMint: treasuryMint.address,\n      tokenMint: asset.address,\n      price: lamports(0).basisPoints,\n      tokenSize: tokens.basisPoints,\n      tokenAccount: asset.token.address,\n      programs,\n    });\n  const programAsSigner = metaplex.auctionHouse().pdas().programAsSigner();\n\n  const accounts = {\n    buyer: buyerAddress,\n    seller: sellerAddress,\n    tokenAccount: asset.token.address,\n    tokenMint: asset.address,\n    metadata: asset.metadataAddress,\n    treasuryMint: treasuryMint.address,\n    escrowPaymentAccount: escrowPayment,\n    sellerPaymentReceiptAccount,\n    buyerReceiptTokenAccount,\n    authority: authorityAddress,\n    auctionHouse: auctionHouseAddress,\n    auctionHouseFeeAccount: feeAccountAddress,\n    auctionHouseTreasury: treasuryAccountAddress,\n    buyerTradeState: bid.tradeStateAddress,\n    sellerTradeState: listing.tradeStateAddress,\n    freeTradeState,\n    programAsSigner,\n  };\n\n  // Args.\n  const args = {\n    freeTradeStateBump: freeTradeState.bump,\n    escrowPaymentBump: escrowPayment.bump,\n    programAsSignerBump: programAsSigner.bump,\n    buyerPrice: price.basisPoints,\n    tokenSize: tokens.basisPoints,\n  };\n\n  // Execute Sale Instruction\n  const partialSaleArgs: ExecutePartialSaleInstructionArgs = {\n    ...args,\n    partialOrderSize: bid.tokens.basisPoints,\n    partialOrderPrice: bid.price.basisPoints,\n  };\n\n  let executeSaleInstruction = isPartialSale\n    ? createExecutePartialSaleInstruction(accounts, partialSaleArgs)\n    : createExecuteSaleInstruction(accounts, args);\n\n  if (auctioneerAuthority) {\n    const auctioneerAccounts: AuctioneerExecuteSaleInstructionAccounts = {\n      ...accounts,\n      auctioneerAuthority: auctioneerAuthority.publicKey,\n      ahAuctioneerPda: metaplex.auctionHouse().pdas().auctioneer({\n        auctionHouse: auctionHouse.address,\n        auctioneerAuthority: auctioneerAuthority.publicKey,\n        programs,\n      }),\n    };\n\n    executeSaleInstruction = createAuctioneerExecuteSaleInstruction(\n      auctioneerAccounts,\n      args\n    );\n  }\n\n  // Provide additional keys to pay royalties.\n  asset.creators.forEach(({ address }) => {\n    executeSaleInstruction.keys.push({\n      pubkey: address,\n      isWritable: true,\n      isSigner: false,\n    });\n\n    // Provide ATA to receive SPL token royalty if is not native SOL sale.\n    if (!isNative) {\n      executeSaleInstruction.keys.push({\n        pubkey: metaplex.tokens().pdas().associatedTokenAccount({\n          mint: treasuryMint.address,\n          owner: address,\n          programs,\n        }),\n        isWritable: true,\n        isSigner: false,\n      });\n    }\n  });\n\n  // Signers.\n  const executeSaleSigners = [auctioneerAuthority].filter(isSigner);\n\n  // Receipt.\n  const shouldPrintReceipt =\n    (params.printReceipt ?? true) &&\n    Boolean(listing.receiptAddress && bid.receiptAddress && !isPartialSale);\n  const bookkeeper = params.bookkeeper ?? metaplex.identity();\n  const purchaseReceipt = metaplex.auctionHouse().pdas().purchaseReceipt({\n    listingTradeState: listing.tradeStateAddress,\n    bidTradeState: bid.tradeStateAddress,\n    programs,\n  });\n\n  return (\n    TransactionBuilder.make<ExecuteSaleBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        sellerTradeState: listing.tradeStateAddress,\n        buyerTradeState: bid.tradeStateAddress,\n        buyer: buyerAddress,\n        seller: sellerAddress,\n        metadata: asset.metadataAddress,\n        bookkeeper: shouldPrintReceipt ? bookkeeper.publicKey : null,\n        receipt: shouldPrintReceipt ? purchaseReceipt : null,\n        price,\n        tokens,\n      })\n\n      // Execute Sale.\n      .add({\n        instruction: executeSaleInstruction,\n        signers: executeSaleSigners,\n        key: params.instructionKey ?? 'executeSale',\n      })\n\n      // Print the Purchase Receipt.\n      .when(shouldPrintReceipt, (builder) =>\n        builder.add({\n          instruction: createPrintPurchaseReceiptInstruction(\n            {\n              purchaseReceipt,\n              listingReceipt: listing.receiptAddress as Pda,\n              bidReceipt: bid.receiptAddress as Pda,\n              bookkeeper: bookkeeper.publicKey,\n              instruction: SYSVAR_INSTRUCTIONS_PUBKEY,\n            },\n            { purchaseReceiptBump: purchaseReceipt.bump }\n          ),\n          signers: [bookkeeper],\n          key: 'printPurchaseReceipt',\n        })\n      )\n  );\n};\n"]},"metadata":{},"sourceType":"module"}