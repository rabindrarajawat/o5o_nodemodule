{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BeetReader = exports.BeetWriter = void 0;\n\nconst assert_1 = require(\"assert\");\n/**\n * Underlying writer used to serialize structs.\n *\n * @private\n * @category beet/struct\n */\n\n\nclass BeetWriter {\n  constructor(byteSize) {\n    this.buf = Buffer.alloc(byteSize);\n    this._offset = 0;\n  }\n\n  get buffer() {\n    return this.buf;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  maybeResize(bytesNeeded) {\n    if (this._offset + bytesNeeded > this.buf.length) {\n      assert_1.strict.fail(`We shouldn't ever need to resize, but ${this._offset + bytesNeeded} > ${this.buf.length}`); // this.buf = Buffer.concat([this.buf, Buffer.alloc(this.allocateBytes)])\n    }\n  }\n\n  write(beet, value) {\n    this.maybeResize(beet.byteSize);\n    beet.write(this.buf, this._offset, value);\n    this._offset += beet.byteSize;\n  }\n\n  writeStruct(instance, fields) {\n    for (const [key, beet] of fields) {\n      const value = instance[key];\n      this.write(beet, value);\n    }\n  }\n\n}\n\nexports.BeetWriter = BeetWriter;\n/**\n * Underlying reader used to deserialize structs.\n *\n * @private\n * @category beet/struct\n */\n\nclass BeetReader {\n  constructor(buffer) {\n    let _offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    this.buffer = buffer;\n    this._offset = _offset;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  read(beet) {\n    const value = beet.read(this.buffer, this._offset);\n    this._offset += beet.byteSize;\n    return value;\n  }\n\n  readStruct(fields) {\n    const acc = {};\n\n    for (const [key, beet] of fields) {\n      acc[key] = this.read(beet);\n    }\n\n    return acc;\n  }\n\n}\n\nexports.BeetReader = BeetReader;","map":{"version":3,"sources":["../../../src/read-write.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAGA;;;;;AAKG;;;AACH,MAAa,UAAb,CAAuB;EAGrB,WAAA,CAAY,QAAZ,EAA4B;IAC1B,KAAK,GAAL,GAAW,MAAM,CAAC,KAAP,CAAa,QAAb,CAAX;IACA,KAAK,OAAL,GAAe,CAAf;EACD;;EAES,IAAN,MAAM,GAAA;IACR,OAAO,KAAK,GAAZ;EACD;;EAES,IAAN,MAAM,GAAA;IACR,OAAO,KAAK,OAAZ;EACD;;EAEO,WAAW,CAAC,WAAD,EAAoB;IACrC,IAAI,KAAK,OAAL,GAAe,WAAf,GAA6B,KAAK,GAAL,CAAS,MAA1C,EAAkD;MAChD,QAAA,CAAA,MAAA,CAAO,IAAP,CACE,yCACE,KAAK,OAAL,GAAe,WACjB,MAAM,KAAK,GAAL,CAAS,MAAM,EAHvB,EADgD,CAMhD;IACD;EACF;;EAED,KAAK,CAAI,IAAJ,EAA4B,KAA5B,EAAoC;IACvC,KAAK,WAAL,CAAiB,IAAI,CAAC,QAAtB;IACA,IAAI,CAAC,KAAL,CAAW,KAAK,GAAhB,EAAqB,KAAK,OAA1B,EAAmC,KAAnC;IACA,KAAK,OAAL,IAAgB,IAAI,CAAC,QAArB;EACD;;EAED,WAAW,CAAI,QAAJ,EAAiB,MAAjB,EAA4C;IACrD,KAAK,MAAM,CAAC,GAAD,EAAM,IAAN,CAAX,IAA0B,MAA1B,EAAkC;MAChC,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAD,CAAtB;MACA,KAAK,KAAL,CAAW,IAAX,EAAiB,KAAjB;IACD;EACF;;AAtCoB;;AAAvB,OAAA,CAAA,UAAA,GAAA,UAAA;AAyCA;;;;;AAKG;;AACH,MAAa,UAAb,CAAuB;EACrB,WAAA,CAA6B,MAA7B,EAAwE;IAAA,IAAnB,OAAmB,uEAAD,CAAC;;IAA3C,KAAA,MAAA,GAAA,MAAA;IAAwB,KAAA,OAAA,GAAA,OAAA;EAAuB;;EAElE,IAAN,MAAM,GAAA;IACR,OAAO,KAAK,OAAZ;EACD;;EAED,IAAI,CAAI,IAAJ,EAA0B;IAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,IAAL,CAAU,KAAK,MAAf,EAAuB,KAAK,OAA5B,CAAd;IACA,KAAK,OAAL,IAAgB,IAAI,CAAC,QAArB;IACA,OAAO,KAAP;EACD;;EAED,UAAU,CAAI,MAAJ,EAA+B;IACvC,MAAM,GAAG,GAAS,EAAlB;;IACA,KAAK,MAAM,CAAC,GAAD,EAAM,IAAN,CAAX,IAA0B,MAA1B,EAAkC;MAChC,GAAG,CAAC,GAAD,CAAH,GAAW,KAAK,IAAL,CAAU,IAAV,CAAX;IACD;;IACD,OAAO,GAAP;EACD;;AAnBoB;;AAAvB,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BeetReader = exports.BeetWriter = void 0;\nconst assert_1 = require(\"assert\");\n/**\n * Underlying writer used to serialize structs.\n *\n * @private\n * @category beet/struct\n */\nclass BeetWriter {\n    constructor(byteSize) {\n        this.buf = Buffer.alloc(byteSize);\n        this._offset = 0;\n    }\n    get buffer() {\n        return this.buf;\n    }\n    get offset() {\n        return this._offset;\n    }\n    maybeResize(bytesNeeded) {\n        if (this._offset + bytesNeeded > this.buf.length) {\n            assert_1.strict.fail(`We shouldn't ever need to resize, but ${this._offset + bytesNeeded} > ${this.buf.length}`);\n            // this.buf = Buffer.concat([this.buf, Buffer.alloc(this.allocateBytes)])\n        }\n    }\n    write(beet, value) {\n        this.maybeResize(beet.byteSize);\n        beet.write(this.buf, this._offset, value);\n        this._offset += beet.byteSize;\n    }\n    writeStruct(instance, fields) {\n        for (const [key, beet] of fields) {\n            const value = instance[key];\n            this.write(beet, value);\n        }\n    }\n}\nexports.BeetWriter = BeetWriter;\n/**\n * Underlying reader used to deserialize structs.\n *\n * @private\n * @category beet/struct\n */\nclass BeetReader {\n    constructor(buffer, _offset = 0) {\n        this.buffer = buffer;\n        this._offset = _offset;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read(beet) {\n        const value = beet.read(this.buffer, this._offset);\n        this._offset += beet.byteSize;\n        return value;\n    }\n    readStruct(fields) {\n        const acc = {};\n        for (const [key, beet] of fields) {\n            acc[key] = this.read(beet);\n        }\n        return acc;\n    }\n}\nexports.BeetReader = BeetReader;\n//# sourceMappingURL=read-write.js.map"]},"metadata":{},"sourceType":"script"}