{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectionsTypeMap = exports.uint8Array = exports.fixedSizeUint8Array = exports.fixedSizeBuffer = exports.array = exports.fixedSizeArray = exports.uniformFixedSizeArray = void 0;\n\nconst types_1 = require(\"../types\");\n\nconst assert_1 = require(\"assert\");\n\nconst numbers_1 = require(\"./numbers\");\n\nconst types_2 = require(\"../types\");\n\nconst utils_1 = require(\"../utils\");\n\nconst beet_fixable_1 = require(\"../beet.fixable\");\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element type\n * @param len the number of elements in the array\n * @param lenPrefix if `true` a 4 byte number indicating the size of the array\n * will be included before serialized array data\n *\n * @category beet/collection\n */\n\n\nfunction uniformFixedSizeArray(element, len) {\n  let lenPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const arraySize = element.byteSize * len;\n  const byteSize = lenPrefix ? 4 + arraySize : arraySize;\n  return {\n    write: function (buf, offset, value) {\n      assert_1.strict.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n\n      if (lenPrefix) {\n        numbers_1.u32.write(buf, offset, len);\n        offset += 4;\n      }\n\n      for (let i = 0; i < len; i++) {\n        element.write(buf, offset + i * element.byteSize, value[i]);\n      }\n    },\n    read: function (buf, offset) {\n      if (lenPrefix) {\n        const size = numbers_1.u32.read(buf, offset);\n        assert_1.strict.equal(size, len, 'invalid byte size');\n        offset += 4;\n      }\n\n      const arr = new Array(len);\n\n      for (let i = 0; i < len; i++) {\n        arr[i] = element.read(buf, offset + i * element.byteSize);\n      }\n\n      return arr;\n    },\n    byteSize,\n    length: len,\n    elementByteSize: element.byteSize,\n    lenPrefixByteSize: 4,\n    description: `Array<${element.description}>(${len})`\n  };\n}\n\nexports.uniformFixedSizeArray = uniformFixedSizeArray;\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which do not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param elements the De/Serializers for the element types\n * @param elementsByteSize size of all elements in the array combined\n *\n * @category beet/collection\n */\n\nfunction fixedSizeArray(elements, elementsByteSize) {\n  const len = elements.length;\n  const firstElement = len === 0 ? '<EMPTY>' : elements[0].description;\n  return {\n    write: function (buf, offset, value) {\n      assert_1.strict.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n      numbers_1.u32.write(buf, offset, len);\n      let cursor = offset + 4;\n\n      for (let i = 0; i < len; i++) {\n        const element = elements[i];\n        element.write(buf, cursor, value[i]);\n        cursor += element.byteSize;\n      }\n    },\n    read: function (buf, offset) {\n      const size = numbers_1.u32.read(buf, offset);\n      assert_1.strict.equal(size, len, 'invalid byte size');\n      let cursor = offset + 4;\n      const arr = new Array(len);\n\n      for (let i = 0; i < len; i++) {\n        const element = elements[i];\n        arr[i] = element.read(buf, cursor);\n        cursor += element.byteSize;\n      }\n\n      return arr;\n    },\n    byteSize: 4 + elementsByteSize,\n    length: len,\n    description: `Array<${firstElement}>(${len})[ 4 + ${elementsByteSize} ]`\n  };\n}\n\nexports.fixedSizeArray = fixedSizeArray;\n/**\n * Wraps an array De/Serializer with with elements of type {@link T} which do\n * not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element types\n *\n * @category beet/collection\n */\n\nfunction array(element) {\n  return {\n    toFixedFromData(buf, offset) {\n      const len = numbers_1.u32.read(buf, offset);\n      (0, utils_1.logTrace)(`${this.description}[${len}]`);\n      const cursorStart = offset + 4;\n      let cursor = cursorStart;\n      const fixedElements = new Array(len);\n\n      for (let i = 0; i < len; i++) {\n        const fixedElement = (0, beet_fixable_1.fixBeetFromData)(element, buf, cursor);\n        fixedElements[i] = fixedElement;\n        cursor += fixedElement.byteSize;\n      }\n\n      return fixedSizeArray(fixedElements, cursor - cursorStart);\n    },\n\n    toFixedFromValue(vals) {\n      (0, assert_1.strict)(Array.isArray(vals), `${vals} should be an array`);\n      let elementsSize = 0;\n      const fixedElements = new Array(vals.length);\n\n      for (let i = 0; i < vals.length; i++) {\n        const fixedElement = (0, beet_fixable_1.fixBeetFromValue)(element, vals[i]);\n        fixedElements[i] = fixedElement;\n        elementsSize += fixedElement.byteSize;\n      }\n\n      return fixedSizeArray(fixedElements, elementsSize);\n    },\n\n    description: `array`\n  };\n}\n\nexports.array = array;\n/**\n * A De/Serializer for raw {@link Buffer}s that just copies/reads the buffer bytes\n * to/from the provided buffer.\n *\n * @param bytes the byte size of the buffer to de/serialize\n * @category beet/collection\n */\n\nfunction fixedSizeBuffer(bytes) {\n  return {\n    write: function (buf, offset, value) {\n      value.copy(buf, offset, 0, bytes);\n    },\n    read: function (buf, offset) {\n      return buf.slice(offset, offset + bytes);\n    },\n    byteSize: bytes,\n    description: `Buffer(${bytes})`\n  };\n}\n\nexports.fixedSizeBuffer = fixedSizeBuffer;\n/**\n * A De/Serializer for {@link Uint8Array}s of known size that just copies/reads\n * the array bytes to/from the provided buffer.\n *\n * @category beet/collection\n */\n\nfunction fixedSizeUint8Array(len) {\n  let lenPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const arrayBufferBeet = fixedSizeBuffer(len);\n  const byteSize = lenPrefix ? len + 4 : len;\n  return {\n    write: function (buf, offset, value) {\n      assert_1.strict.equal(value.byteLength, len, `Uint8Array length ${value.byteLength} should match len ${len}`);\n\n      if (lenPrefix) {\n        numbers_1.u32.write(buf, offset, len);\n        offset += 4;\n      }\n\n      const valueBuf = Buffer.from(value);\n      arrayBufferBeet.write(buf, offset, valueBuf);\n    },\n    read: function (buf, offset) {\n      if (lenPrefix) {\n        const size = numbers_1.u32.read(buf, offset);\n        assert_1.strict.equal(size, len, 'invalid byte size');\n        offset += 4;\n      }\n\n      const arrayBuffer = arrayBufferBeet.read(buf, offset);\n      return Uint8Array.from(arrayBuffer);\n    },\n    byteSize,\n    description: `Uint8Array(${len})`\n  };\n}\n\nexports.fixedSizeUint8Array = fixedSizeUint8Array;\n/**\n * A De/Serializer for {@link Uint8Array}s that just copies/reads the array bytes\n * to/from the provided buffer.\n *\n * @category beet/collection\n */\n\nexports.uint8Array = {\n  toFixedFromData(buf, offset) {\n    const len = numbers_1.u32.read(buf, offset);\n    (0, utils_1.logTrace)(`${this.description}[${len}]`);\n    return fixedSizeUint8Array(len, true);\n  },\n\n  toFixedFromValue(val) {\n    const len = val.byteLength;\n    return fixedSizeUint8Array(len, true);\n  },\n\n  description: `Uint8Array`\n};\n/**\n * Maps collections beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\n\nexports.collectionsTypeMap = {\n  Array: {\n    beet: 'array',\n    isFixable: true,\n    sourcePack: types_2.BEET_PACKAGE,\n    ts: 'Array',\n    arg: types_1.BEET_TYPE_ARG_LEN\n  },\n  FixedSizeArray: {\n    beet: 'fixedSizeArray',\n    isFixable: false,\n    sourcePack: types_2.BEET_PACKAGE,\n    ts: 'Array',\n    arg: types_1.BEET_TYPE_ARG_LEN\n  },\n  UniformFixedSizeArray: {\n    beet: 'uniformFixedSizeArray',\n    isFixable: false,\n    sourcePack: types_2.BEET_PACKAGE,\n    ts: 'Array',\n    arg: types_1.BEET_TYPE_ARG_LEN\n  },\n  Buffer: {\n    beet: 'fixedSizeBuffer',\n    isFixable: false,\n    sourcePack: types_2.BEET_PACKAGE,\n    ts: 'Buffer',\n    arg: types_1.BEET_TYPE_ARG_LEN\n  },\n  FixedSizeUint8Array: {\n    beet: 'fixedSizeUint8Array',\n    isFixable: false,\n    sourcePack: types_2.BEET_PACKAGE,\n    ts: 'Uint8Array',\n    arg: types_1.BEET_TYPE_ARG_LEN\n  },\n  Uint8Array: {\n    beet: 'uint8Array',\n    isFixable: true,\n    sourcePack: types_2.BEET_PACKAGE,\n    ts: 'Uint8Array',\n    arg: types_1.BEET_TYPE_ARG_LEN\n  }\n};","map":{"version":3,"sources":["../../../../src/beets/collections.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collectionsTypeMap = exports.uint8Array = exports.fixedSizeUint8Array = exports.fixedSizeBuffer = exports.array = exports.fixedSizeArray = exports.uniformFixedSizeArray = void 0;\nconst types_1 = require(\"../types\");\nconst assert_1 = require(\"assert\");\nconst numbers_1 = require(\"./numbers\");\nconst types_2 = require(\"../types\");\nconst utils_1 = require(\"../utils\");\nconst beet_fixable_1 = require(\"../beet.fixable\");\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element type\n * @param len the number of elements in the array\n * @param lenPrefix if `true` a 4 byte number indicating the size of the array\n * will be included before serialized array data\n *\n * @category beet/collection\n */\nfunction uniformFixedSizeArray(element, len, lenPrefix = false) {\n    const arraySize = element.byteSize * len;\n    const byteSize = lenPrefix ? 4 + arraySize : arraySize;\n    return {\n        write: function (buf, offset, value) {\n            assert_1.strict.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n            if (lenPrefix) {\n                numbers_1.u32.write(buf, offset, len);\n                offset += 4;\n            }\n            for (let i = 0; i < len; i++) {\n                element.write(buf, offset + i * element.byteSize, value[i]);\n            }\n        },\n        read: function (buf, offset) {\n            if (lenPrefix) {\n                const size = numbers_1.u32.read(buf, offset);\n                assert_1.strict.equal(size, len, 'invalid byte size');\n                offset += 4;\n            }\n            const arr = new Array(len);\n            for (let i = 0; i < len; i++) {\n                arr[i] = element.read(buf, offset + i * element.byteSize);\n            }\n            return arr;\n        },\n        byteSize,\n        length: len,\n        elementByteSize: element.byteSize,\n        lenPrefixByteSize: 4,\n        description: `Array<${element.description}>(${len})`,\n    };\n}\nexports.uniformFixedSizeArray = uniformFixedSizeArray;\n/**\n * De/Serializes an array with a specific number of elements of type {@link T}\n * which do not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param elements the De/Serializers for the element types\n * @param elementsByteSize size of all elements in the array combined\n *\n * @category beet/collection\n */\nfunction fixedSizeArray(elements, elementsByteSize) {\n    const len = elements.length;\n    const firstElement = len === 0 ? '<EMPTY>' : elements[0].description;\n    return {\n        write: function (buf, offset, value) {\n            assert_1.strict.equal(value.length, len, `array length ${value.length} should match len ${len}`);\n            numbers_1.u32.write(buf, offset, len);\n            let cursor = offset + 4;\n            for (let i = 0; i < len; i++) {\n                const element = elements[i];\n                element.write(buf, cursor, value[i]);\n                cursor += element.byteSize;\n            }\n        },\n        read: function (buf, offset) {\n            const size = numbers_1.u32.read(buf, offset);\n            assert_1.strict.equal(size, len, 'invalid byte size');\n            let cursor = offset + 4;\n            const arr = new Array(len);\n            for (let i = 0; i < len; i++) {\n                const element = elements[i];\n                arr[i] = element.read(buf, cursor);\n                cursor += element.byteSize;\n            }\n            return arr;\n        },\n        byteSize: 4 + elementsByteSize,\n        length: len,\n        description: `Array<${firstElement}>(${len})[ 4 + ${elementsByteSize} ]`,\n    };\n}\nexports.fixedSizeArray = fixedSizeArray;\n/**\n * Wraps an array De/Serializer with with elements of type {@link T} which do\n * not all have the same size.\n *\n * @template T type of elements held in the array\n *\n * @param element the De/Serializer for the element types\n *\n * @category beet/collection\n */\nfunction array(element) {\n    return {\n        toFixedFromData(buf, offset) {\n            const len = numbers_1.u32.read(buf, offset);\n            (0, utils_1.logTrace)(`${this.description}[${len}]`);\n            const cursorStart = offset + 4;\n            let cursor = cursorStart;\n            const fixedElements = new Array(len);\n            for (let i = 0; i < len; i++) {\n                const fixedElement = (0, beet_fixable_1.fixBeetFromData)(element, buf, cursor);\n                fixedElements[i] = fixedElement;\n                cursor += fixedElement.byteSize;\n            }\n            return fixedSizeArray(fixedElements, cursor - cursorStart);\n        },\n        toFixedFromValue(vals) {\n            (0, assert_1.strict)(Array.isArray(vals), `${vals} should be an array`);\n            let elementsSize = 0;\n            const fixedElements = new Array(vals.length);\n            for (let i = 0; i < vals.length; i++) {\n                const fixedElement = (0, beet_fixable_1.fixBeetFromValue)(element, vals[i]);\n                fixedElements[i] = fixedElement;\n                elementsSize += fixedElement.byteSize;\n            }\n            return fixedSizeArray(fixedElements, elementsSize);\n        },\n        description: `array`,\n    };\n}\nexports.array = array;\n/**\n * A De/Serializer for raw {@link Buffer}s that just copies/reads the buffer bytes\n * to/from the provided buffer.\n *\n * @param bytes the byte size of the buffer to de/serialize\n * @category beet/collection\n */\nfunction fixedSizeBuffer(bytes) {\n    return {\n        write: function (buf, offset, value) {\n            value.copy(buf, offset, 0, bytes);\n        },\n        read: function (buf, offset) {\n            return buf.slice(offset, offset + bytes);\n        },\n        byteSize: bytes,\n        description: `Buffer(${bytes})`,\n    };\n}\nexports.fixedSizeBuffer = fixedSizeBuffer;\n/**\n * A De/Serializer for {@link Uint8Array}s of known size that just copies/reads\n * the array bytes to/from the provided buffer.\n *\n * @category beet/collection\n */\nfunction fixedSizeUint8Array(len, lenPrefix = false) {\n    const arrayBufferBeet = fixedSizeBuffer(len);\n    const byteSize = lenPrefix ? len + 4 : len;\n    return {\n        write: function (buf, offset, value) {\n            assert_1.strict.equal(value.byteLength, len, `Uint8Array length ${value.byteLength} should match len ${len}`);\n            if (lenPrefix) {\n                numbers_1.u32.write(buf, offset, len);\n                offset += 4;\n            }\n            const valueBuf = Buffer.from(value);\n            arrayBufferBeet.write(buf, offset, valueBuf);\n        },\n        read: function (buf, offset) {\n            if (lenPrefix) {\n                const size = numbers_1.u32.read(buf, offset);\n                assert_1.strict.equal(size, len, 'invalid byte size');\n                offset += 4;\n            }\n            const arrayBuffer = arrayBufferBeet.read(buf, offset);\n            return Uint8Array.from(arrayBuffer);\n        },\n        byteSize,\n        description: `Uint8Array(${len})`,\n    };\n}\nexports.fixedSizeUint8Array = fixedSizeUint8Array;\n/**\n * A De/Serializer for {@link Uint8Array}s that just copies/reads the array bytes\n * to/from the provided buffer.\n *\n * @category beet/collection\n */\nexports.uint8Array = {\n    toFixedFromData(buf, offset) {\n        const len = numbers_1.u32.read(buf, offset);\n        (0, utils_1.logTrace)(`${this.description}[${len}]`);\n        return fixedSizeUint8Array(len, true);\n    },\n    toFixedFromValue(val) {\n        const len = val.byteLength;\n        return fixedSizeUint8Array(len, true);\n    },\n    description: `Uint8Array`,\n};\n/**\n * Maps collections beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.collectionsTypeMap = {\n    Array: {\n        beet: 'array',\n        isFixable: true,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: 'Array',\n        arg: types_1.BEET_TYPE_ARG_LEN,\n    },\n    FixedSizeArray: {\n        beet: 'fixedSizeArray',\n        isFixable: false,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: 'Array',\n        arg: types_1.BEET_TYPE_ARG_LEN,\n    },\n    UniformFixedSizeArray: {\n        beet: 'uniformFixedSizeArray',\n        isFixable: false,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: 'Array',\n        arg: types_1.BEET_TYPE_ARG_LEN,\n    },\n    Buffer: {\n        beet: 'fixedSizeBuffer',\n        isFixable: false,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: 'Buffer',\n        arg: types_1.BEET_TYPE_ARG_LEN,\n    },\n    FixedSizeUint8Array: {\n        beet: 'fixedSizeUint8Array',\n        isFixable: false,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: 'Uint8Array',\n        arg: types_1.BEET_TYPE_ARG_LEN,\n    },\n    Uint8Array: {\n        beet: 'uint8Array',\n        isFixable: true,\n        sourcePack: types_2.BEET_PACKAGE,\n        ts: 'Uint8Array',\n        arg: types_1.BEET_TYPE_ARG_LEN,\n    },\n};\n//# sourceMappingURL=collections.js.map"]},"metadata":{},"sourceType":"script"}