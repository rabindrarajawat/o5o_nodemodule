{"ast":null,"code":"import { createCreateMasterEditionV3Instruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair } from '@solana/web3.js';\nimport { assertNftWithToken } from '../models/Nft.mjs';\nimport { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';\nimport { toPublicKey } from '../../../types/PublicKey.mjs';\nimport { token } from '../../../types/Amount.mjs';\nimport { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs'; // -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateNftOperation';\n/**\n * Creates a new NFT.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .nfts()\n *   .create({\n *     name: 'My NFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\n\nconst createNftOperation = useOperation(Key);\n/**\n * @group Operations\n * @category Types\n */\n\n/**\n * @group Operations\n * @category Handlers\n */\n\nconst createNftOperationHandler = {\n  handle: async (operation, metaplex, scope) => {\n    const {\n      useNewMint = Keypair.generate(),\n      useExistingMint,\n      tokenOwner = metaplex.identity().publicKey,\n      tokenAddress: tokenSigner\n    } = operation.input;\n    const mintAddress = useExistingMint ?? useNewMint.publicKey;\n    const tokenAddress = tokenSigner ? toPublicKey(tokenSigner) : metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: tokenOwner,\n      programs: scope.programs\n    });\n    const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);\n    const tokenExists = tokenAccount.exists;\n    const builder = await createNftBuilder(metaplex, { ...operation.input,\n      useNewMint,\n      tokenOwner,\n      tokenExists\n    }, scope);\n    scope.throwIfCanceled();\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n    const nft = await metaplex.nfts().findByMint({\n      mintAddress: output.mintAddress,\n      tokenAddress: output.tokenAddress\n    }, scope);\n    scope.throwIfCanceled();\n    assertNftWithToken(nft);\n    return { ...output,\n      nft\n    };\n  }\n}; // -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\n\n/**\n * Creates a new NFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .create({\n *     name: 'My NFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\n\nconst createNftBuilder = async function (metaplex, params) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    programs,\n    payer = metaplex.rpc().getDefaultFeePayer()\n  } = options;\n  const {\n    useNewMint = Keypair.generate(),\n    updateAuthority = metaplex.identity(),\n    mintAuthority = metaplex.identity(),\n    tokenOwner = metaplex.identity().publicKey\n  } = params;\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const sftBuilder = await metaplex.nfts().builders().createSft({ ...params,\n    updateAuthority,\n    mintAuthority,\n    freezeAuthority: mintAuthority.publicKey,\n    useNewMint,\n    tokenOwner,\n    tokenAmount: token(1),\n    decimals: 0\n  }, {\n    programs,\n    payer\n  });\n  const {\n    mintAddress,\n    metadataAddress,\n    tokenAddress\n  } = sftBuilder.getContext();\n  const masterEditionAddress = metaplex.nfts().pdas().masterEdition({\n    mint: mintAddress,\n    programs\n  });\n  return TransactionBuilder.make().setFeePayer(payer).setContext({\n    mintAddress,\n    metadataAddress,\n    masterEditionAddress,\n    tokenAddress: tokenAddress\n  }) // Create the mint, the token and the metadata.\n  .add(sftBuilder) // Create master edition account (prevents further minting).\n  .add({\n    instruction: createCreateMasterEditionV3Instruction({\n      edition: masterEditionAddress,\n      mint: mintAddress,\n      updateAuthority: updateAuthority.publicKey,\n      mintAuthority: mintAuthority.publicKey,\n      payer: payer.publicKey,\n      metadata: metadataAddress\n    }, {\n      createMasterEditionArgs: {\n        maxSupply: params.maxSupply === undefined ? 0 : params.maxSupply\n      }\n    }, tokenMetadataProgram.address),\n    signers: [payer, mintAuthority, updateAuthority],\n    key: params.createMasterEditionInstructionKey ?? 'createMasterEdition'\n  });\n};\n\nexport { createNftBuilder, createNftOperation, createNftOperationHandler };","map":{"version":3,"sources":["../../../../../src/plugins/nftModule/operations/createNft.ts"],"names":["Key","createNftOperation","useOperation","createNftOperationHandler","handle","operation","metaplex","scope","useNewMint","Keypair","generate","useExistingMint","tokenOwner","identity","publicKey","tokenAddress","tokenSigner","input","mintAddress","toPublicKey","tokens","pdas","associatedTokenAccount","mint","owner","programs","tokenAccount","rpc","getAccount","tokenExists","exists","builder","createNftBuilder","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","nft","nfts","findByMint","assertNftWithToken","params","options","payer","getDefaultFeePayer","updateAuthority","mintAuthority","tokenMetadataProgram","getTokenMetadata","sftBuilder","builders","createSft","freezeAuthority","tokenAmount","token","decimals","metadataAddress","getContext","masterEditionAddress","masterEdition","TransactionBuilder","make","setFeePayer","setContext","add","instruction","createCreateMasterEditionV3Instruction","edition","metadata","createMasterEditionArgs","maxSupply","undefined","address","signers","key","createMasterEditionInstructionKey"],"mappings":"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","sourcesContent":["import {\n  createCreateMasterEditionV3Instruction,\n  Uses,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertNftWithToken, NftWithToken } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  BigNumber,\n  CreatorInput,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  token,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateNftOperation' as const;\n\n/**\n * Creates a new NFT.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .nfts()\n *   .create({\n *     name: 'My NFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createNftOperation = useOperation<CreateNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateNftOperation = Operation<\n  typeof Key,\n  CreateNftInput,\n  CreateNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateNftInput = {\n  /**\n   * The authority that will be able to make changes\n   * to the created NFT.\n   *\n   * This is required as a Signer because creating the master\n   * edition account requires the update authority to sign\n   * the transaction.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The authority that is currently allowed to mint new tokens\n   * for the provided mint account.\n   *\n   * Note that this is only relevant if the `useExistingMint` parameter\n   * if provided.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: Signer;\n\n  /**\n   * The address of the new mint account as a Signer.\n   * This is useful if you already have a generated Keypair\n   * for the mint account of the NFT to create.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  useNewMint?: Signer;\n\n  /**\n   * The address of the existing mint account that should be converted\n   * into an NFT. The account at this address should have the right\n   * requirements to become an NFT, e.g. its supply should contains\n   * exactly 1 token.\n   *\n   * @defaultValue Defaults to creating a new mint account with the\n   * right requirements.\n   */\n  useExistingMint?: PublicKey;\n\n  /**\n   * The owner of the NFT to create.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * The token account linking the mint account and the token owner\n   * together. By default, the associated token account will be used.\n   *\n   * If the provided token account does not exist, it must be passed as\n   * a Signer as we will need to create it before creating the NFT.\n   *\n   * @defaultValue Defaults to creating a new associated token account\n   * using the `mintAddress` and `tokenOwner` parameters.\n   */\n  tokenAddress?: PublicKey | Signer;\n\n  /** The URI that points to the JSON metadata of the asset. */\n  uri: string;\n\n  /** The on-chain name of the asset, e.g. \"My NFT #123\". */\n  name: string;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYNFT\".\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * {@inheritDoc CreatorInput}\n   * @defaultValue\n   * Defaults to using the provided `updateAuthority` as the only verified creator.\n   * ```ts\n   * [{\n   *   address: updateAuthority.publicKey,\n   *   authority: updateAuthority,\n   *   share: 100,\n   * }]\n   * ```\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the NFT's metadata is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * The maximum supply of printed editions.\n   * When this is `null`, an unlimited amount of editions\n   * can be printed from the original edition.\n   *\n   * @defaultValue `toBigNumber(0)`\n   */\n  maxSupply?: Option<BigNumber>;\n\n  /**\n   * When this field is not `null`, it indicates that the NFT\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue `null`\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * Whether the created NFT is a Collection NFT.\n   * When set to `true`, the NFT will be created as a\n   * Sized Collection NFT with an initial size of 0.\n   *\n   * @defaultValue `false`\n   */\n  isCollection?: boolean;\n\n  /**\n   * The Collection NFT that this new NFT belongs to.\n   * When `null`, the created NFT will not be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the created NFT\n   * to prove that it is part of the provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n\n  /**\n   * Whether or not the provided `collection` is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  collectionIsSized?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created NFT and its associated token. */\n  nft: NftWithToken;\n\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the metadata account. */\n  metadataAddress: PublicKey;\n\n  /** The address of the master edition account. */\n  masterEditionAddress: PublicKey;\n\n  /** The address of the token account. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createNftOperationHandler: OperationHandler<CreateNftOperation> = {\n  handle: async (\n    operation: CreateNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ) => {\n    const {\n      useNewMint = Keypair.generate(),\n      useExistingMint,\n      tokenOwner = metaplex.identity().publicKey,\n      tokenAddress: tokenSigner,\n    } = operation.input;\n\n    const mintAddress = useExistingMint ?? useNewMint.publicKey;\n    const tokenAddress = tokenSigner\n      ? toPublicKey(tokenSigner)\n      : metaplex.tokens().pdas().associatedTokenAccount({\n          mint: mintAddress,\n          owner: tokenOwner,\n          programs: scope.programs,\n        });\n    const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);\n    const tokenExists = tokenAccount.exists;\n\n    const builder = await createNftBuilder(\n      metaplex,\n      {\n        ...operation.input,\n        useNewMint,\n        tokenOwner,\n        tokenExists,\n      },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n      metaplex,\n      scope.confirmOptions\n    );\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    const nft = await metaplex.nfts().findByMint(\n      {\n        mintAddress: output.mintAddress,\n        tokenAddress: output.tokenAddress,\n      },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    assertNftWithToken(nft);\n    return { ...output, nft };\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateNftBuilderParams = Omit<CreateNftInput, 'confirmOptions'> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the metadata account. */\n  createMetadataInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the master edition account. */\n  createMasterEditionInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateNftBuilderContext = Omit<CreateNftOutput, 'response' | 'nft'>;\n\n/**\n * Creates a new NFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .create({\n *     name: 'My NFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createNftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateNftBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    useNewMint = Keypair.generate(),\n    updateAuthority = metaplex.identity(),\n    mintAuthority = metaplex.identity(),\n    tokenOwner = metaplex.identity().publicKey,\n  } = params;\n\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  const sftBuilder = await metaplex\n    .nfts()\n    .builders()\n    .createSft(\n      {\n        ...params,\n        updateAuthority,\n        mintAuthority,\n        freezeAuthority: mintAuthority.publicKey,\n        useNewMint,\n        tokenOwner,\n        tokenAmount: token(1),\n        decimals: 0,\n      },\n      { programs, payer }\n    );\n\n  const { mintAddress, metadataAddress, tokenAddress } =\n    sftBuilder.getContext();\n  const masterEditionAddress = metaplex.nfts().pdas().masterEdition({\n    mint: mintAddress,\n    programs,\n  });\n\n  return (\n    TransactionBuilder.make<CreateNftBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintAddress,\n        metadataAddress,\n        masterEditionAddress,\n        tokenAddress: tokenAddress as PublicKey,\n      })\n\n      // Create the mint, the token and the metadata.\n      .add(sftBuilder)\n\n      // Create master edition account (prevents further minting).\n      .add({\n        instruction: createCreateMasterEditionV3Instruction(\n          {\n            edition: masterEditionAddress,\n            mint: mintAddress,\n            updateAuthority: updateAuthority.publicKey,\n            mintAuthority: mintAuthority.publicKey,\n            payer: payer.publicKey,\n            metadata: metadataAddress,\n          },\n          {\n            createMasterEditionArgs: {\n              maxSupply: params.maxSupply === undefined ? 0 : params.maxSupply,\n            },\n          },\n          tokenMetadataProgram.address\n        ),\n        signers: [payer, mintAuthority, updateAuthority],\n        key: params.createMasterEditionInstructionKey ?? 'createMasterEdition',\n      })\n  );\n};\n"]},"metadata":{},"sourceType":"module"}