{"ast":null,"code":"import { defineProperty as _defineProperty } from '../_virtual/_rollupPluginBabelHelpers.mjs';\nimport { Buffer } from 'buffer';\nimport { PublicKey } from '@solana/web3.js';\nimport base58 from 'bs58';\nimport BN from 'bn.js';\nimport { GmaBuilder } from './GmaBuilder.mjs';\n\nclass GpaBuilder {\n  /** The connection instance to use when fetching accounts. */\n\n  /** The public key of the program we want to retrieve accounts from. */\n\n  /** The configs to use when fetching program accounts. */\n  constructor(metaplex, programId) {\n    _defineProperty(this, \"config\", {});\n\n    this.metaplex = metaplex;\n    this.programId = programId;\n  }\n\n  mergeConfig(config) {\n    this.config = { ...this.config,\n      ...config\n    };\n    return this;\n  }\n\n  slice(offset, length) {\n    this.config.dataSlice = {\n      offset,\n      length\n    };\n    return this;\n  }\n\n  withoutData() {\n    return this.slice(0, 0);\n  }\n\n  addFilter() {\n    if (!this.config.filters) {\n      this.config.filters = [];\n    }\n\n    this.config.filters.push(...arguments);\n    return this;\n  }\n\n  where(offset, bytes) {\n    if (Buffer.isBuffer(bytes)) {\n      bytes = base58.encode(bytes);\n    } else if (typeof bytes === 'object' && 'toBase58' in bytes) {\n      bytes = bytes.toBase58();\n    } else if (BN.isBN(bytes)) {\n      bytes = base58.encode(bytes.toArray());\n    } else if (typeof bytes !== 'string') {\n      bytes = base58.encode(new BN(bytes, 'le').toArray());\n    }\n\n    return this.addFilter({\n      memcmp: {\n        offset,\n        bytes\n      }\n    });\n  }\n\n  whereSize(dataSize) {\n    return this.addFilter({\n      dataSize\n    });\n  }\n\n  sortUsing(callback) {\n    this.sortCallback = callback;\n    return this;\n  }\n\n  async get() {\n    const accounts = await this.metaplex.rpc().getProgramAccounts(this.programId, this.config);\n\n    if (this.sortCallback) {\n      accounts.sort(this.sortCallback);\n    }\n\n    return accounts;\n  }\n\n  async getAndMap(callback) {\n    return (await this.get()).map(callback);\n  }\n\n  async getPublicKeys() {\n    return this.getAndMap(account => account.publicKey);\n  }\n\n  async getDataAsPublicKeys() {\n    // TODO(loris): Throw a custom Metaplex error if the data is not a public key.\n    return this.getAndMap(account => new PublicKey(account.data));\n  }\n\n  async getMultipleAccounts(callback, options) {\n    // TODO(loris): Throw a custom Metaplex error if the data is not a public key.\n    const cb = callback ?? (account => new PublicKey(account.data));\n\n    return new GmaBuilder(this.metaplex, await this.getAndMap(cb), options);\n  }\n\n}\n\nexport { GpaBuilder };","map":{"version":3,"sources":["../../../src/utils/GpaBuilder.ts"],"names":["GpaBuilder","constructor","metaplex","programId","mergeConfig","config","slice","offset","length","dataSlice","withoutData","addFilter","filters","push","where","bytes","Buffer","isBuffer","base58","encode","toBase58","BN","isBN","toArray","memcmp","whereSize","dataSize","sortUsing","callback","sortCallback","get","accounts","rpc","getProgramAccounts","sort","getAndMap","map","getPublicKeys","account","publicKey","getDataAsPublicKeys","PublicKey","data","getMultipleAccounts","options","cb","GmaBuilder"],"mappings":";;;;;;;AAiBO,MAAMA,UAAN,CAAiB;EACtB;;EAGA;;EAGA;EAMAC,WAAW,CAACC,QAAD,EAAqBC,SAArB,EAA2C;IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EALT,EAKS,CAAA;;IACpD,KAAKD,QAAL,GAAgBA,QAAhB;IACA,KAAKC,SAAL,GAAiBA,SAAjB;EACF;;EAEAC,WAAW,CAACC,MAAD,EAAmC;IAC5C,KAAKA,MAAL,GAAc,EAAE,GAAG,KAAKA,MAAV;MAAkB,GAAGA;IAArB,CAAd;IAEA,OAAO,IAAP;EACF;;EAEAC,KAAK,CAACC,MAAD,EAAiBC,MAAjB,EAAiC;IACpC,KAAKH,MAAL,CAAYI,SAAZ,GAAwB;MAAEF,MAAF;MAAUC;IAAV,CAAxB;IAEA,OAAO,IAAP;EACF;;EAEAE,WAAW,GAAG;IACZ,OAAO,KAAKJ,KAAL,CAAW,CAAX,EAAc,CAAd,CAAP;EACF;;EAEAK,SAAS,GAAyC;IAChD,IAAI,CAAC,KAAKN,MAAL,CAAYO,OAAjB,EAA0B;MACxB,KAAKP,MAAL,CAAYO,OAAZ,GAAsB,EAAtB;IACF;;IAEA,KAAKP,MAAL,CAAYO,OAAZ,CAAoBC,IAApB,CAAyB,YAAzB;IAEA,OAAO,IAAP;EACF;;EAEAC,KAAK,CAACP,MAAD,EAAiBQ,KAAjB,EAAmE;IACtE,IAAIC,MAAM,CAACC,QAAPD,CAAgBD,KAAhBC,CAAJ,EAA4B;MAC1BD,KAAK,GAAGG,MAAM,CAACC,MAAPD,CAAcH,KAAdG,CAARH;IACD,CAFD,MAEO,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,cAAcA,KAA/C,EAAsD;MAC3DA,KAAK,GAAGA,KAAK,CAACK,QAANL,EAARA;IACD,CAFM,MAEA,IAAIM,EAAE,CAACC,IAAHD,CAAQN,KAARM,CAAJ,EAAoB;MACzBN,KAAK,GAAGG,MAAM,CAACC,MAAPD,CAAcH,KAAK,CAACQ,OAANR,EAAdG,CAARH;IACD,CAFM,MAEA,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MACpCA,KAAK,GAAGG,MAAM,CAACC,MAAPD,CAAc,IAAIG,EAAJ,CAAON,KAAP,EAAc,IAAd,EAAoBQ,OAApB,EAAdL,CAARH;IACF;;IAEA,OAAO,KAAKJ,SAAL,CAAe;MAAEa,MAAM,EAAE;QAAEjB,MAAF;QAAUQ;MAAV;IAAV,CAAf,CAAP;EACF;;EAEAU,SAAS,CAACC,QAAD,EAAmB;IAC1B,OAAO,KAAKf,SAAL,CAAe;MAAEe;IAAF,CAAf,CAAP;EACF;;EAEAC,SAAS,CAACC,QAAD,EAA4B;IACnC,KAAKC,YAAL,GAAoBD,QAApB;IAEA,OAAO,IAAP;EACF;;EAES,MAAHE,GAAG,GAA+B;IACtC,MAAMC,QAAQ,GAAG,MAAM,KAAK7B,QAAL,CACpB8B,GADoB,GAEpBC,kBAFoB,CAED,KAAK9B,SAFJ,EAEe,KAAKE,MAFpB,CAAvB;;IAIA,IAAI,KAAKwB,YAAT,EAAuB;MACrBE,QAAQ,CAACG,IAATH,CAAc,KAAKF,YAAnBE;IACF;;IAEA,OAAOA,QAAP;EACF;;EAEe,MAATI,SAAS,CAAIP,QAAJ,EAA6D;IAC1E,OAAO,CAAC,MAAM,KAAKE,GAAL,EAAP,EAAmBM,GAAnB,CAAuBR,QAAvB,CAAP;EACF;;EAEmB,MAAbS,aAAa,GAAyB;IAC1C,OAAO,KAAKF,SAAL,CAAgBG,OAAO,IAAKA,OAAO,CAACC,SAApC,CAAP;EACF;;EAEyB,MAAnBC,mBAAmB,GAAyB;IAChD;IACA,OAAO,KAAKL,SAAL,CAAgBG,OAAO,IAAK,IAAIG,SAAJ,CAAcH,OAAO,CAACI,IAAtB,CAA5B,CAAP;EACF;;EAEyB,MAAnBC,mBAAmB,CACvBf,QADuB,EAEvBgB,OAFuB,EAGF;IACrB;IACA,MAAMC,EAAE,GAAGjB,QAAQ,KAAMU,OAAO,IAAK,IAAIG,SAAJ,CAAcH,OAAO,CAACI,IAAtB,CAAlB,CAAnB;;IAEA,OAAO,IAAII,UAAJ,CAAe,KAAK5C,QAApB,EAA8B,MAAM,KAAKiC,SAAL,CAAeU,EAAf,CAApC,EAAwDD,OAAxD,CAAP;EACF;;AArGsB","sourcesContent":["import { Buffer } from 'buffer';\nimport {\n  GetProgramAccountsConfig,\n  GetProgramAccountsFilter,\n  PublicKey,\n} from '@solana/web3.js';\nimport base58 from 'bs58';\nimport BN from 'bn.js';\nimport { GmaBuilder, GmaBuilderOptions } from './GmaBuilder';\nimport { Metaplex } from '@/Metaplex';\nimport { UnparsedAccount } from '@/types';\n\nexport type GpaSortCallback = (\n  a: UnparsedAccount,\n  b: UnparsedAccount\n) => number;\n\nexport class GpaBuilder {\n  /** The connection instance to use when fetching accounts. */\n  protected readonly metaplex: Metaplex;\n\n  /** The public key of the program we want to retrieve accounts from. */\n  protected readonly programId: PublicKey;\n\n  /** The configs to use when fetching program accounts. */\n  protected config: GetProgramAccountsConfig = {};\n\n  /** When provided, reorder accounts using this callback. */\n  protected sortCallback?: GpaSortCallback;\n\n  constructor(metaplex: Metaplex, programId: PublicKey) {\n    this.metaplex = metaplex;\n    this.programId = programId;\n  }\n\n  mergeConfig(config: GetProgramAccountsConfig) {\n    this.config = { ...this.config, ...config };\n\n    return this;\n  }\n\n  slice(offset: number, length: number) {\n    this.config.dataSlice = { offset, length };\n\n    return this;\n  }\n\n  withoutData() {\n    return this.slice(0, 0);\n  }\n\n  addFilter(...filters: GetProgramAccountsFilter[]) {\n    if (!this.config.filters) {\n      this.config.filters = [];\n    }\n\n    this.config.filters.push(...filters);\n\n    return this;\n  }\n\n  where(offset: number, bytes: string | Buffer | PublicKey | BN | number) {\n    if (Buffer.isBuffer(bytes)) {\n      bytes = base58.encode(bytes);\n    } else if (typeof bytes === 'object' && 'toBase58' in bytes) {\n      bytes = bytes.toBase58();\n    } else if (BN.isBN(bytes)) {\n      bytes = base58.encode(bytes.toArray());\n    } else if (typeof bytes !== 'string') {\n      bytes = base58.encode(new BN(bytes, 'le').toArray());\n    }\n\n    return this.addFilter({ memcmp: { offset, bytes } });\n  }\n\n  whereSize(dataSize: number) {\n    return this.addFilter({ dataSize });\n  }\n\n  sortUsing(callback: GpaSortCallback) {\n    this.sortCallback = callback;\n\n    return this;\n  }\n\n  async get(): Promise<UnparsedAccount[]> {\n    const accounts = await this.metaplex\n      .rpc()\n      .getProgramAccounts(this.programId, this.config);\n\n    if (this.sortCallback) {\n      accounts.sort(this.sortCallback);\n    }\n\n    return accounts;\n  }\n\n  async getAndMap<T>(callback: (account: UnparsedAccount) => T): Promise<T[]> {\n    return (await this.get()).map(callback);\n  }\n\n  async getPublicKeys(): Promise<PublicKey[]> {\n    return this.getAndMap((account) => account.publicKey);\n  }\n\n  async getDataAsPublicKeys(): Promise<PublicKey[]> {\n    // TODO(loris): Throw a custom Metaplex error if the data is not a public key.\n    return this.getAndMap((account) => new PublicKey(account.data));\n  }\n\n  async getMultipleAccounts(\n    callback?: (account: UnparsedAccount) => PublicKey,\n    options?: GmaBuilderOptions\n  ): Promise<GmaBuilder> {\n    // TODO(loris): Throw a custom Metaplex error if the data is not a public key.\n    const cb = callback ?? ((account) => new PublicKey(account.data));\n\n    return new GmaBuilder(this.metaplex, await this.getAndMap(cb), options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}