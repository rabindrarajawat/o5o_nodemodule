{"ast":null,"code":"// import axios from \"axios\";\n// import { sendTransactions } from \"./utility\";\n// import { fetchHashTable } from \"../hooks/use-hash-table\";\n// import { COLLECTION_NAME, COLLECTION_SYMBOL } from \"../constant/contract\";\n// import { NEXT_PUBLIC_SOLANA_NETWORK, NEXT_PUBLIC_SOLANA_COL_CREATOR, NEXT_PUBLIC_SOLANA_NFT_NAME } from '../constant/env';\n// import * as anchor from \"@project-serum/anchor\";\n// import {\n//   resolveToWalletAddress,\n//   getParsedNftAccountsByOwner,\n// } from \"@nfteyez/sol-rayz\";\n// import {\n//   MintLayout,\n//   TOKEN_PROGRAM_ID,\n//   Token,\n// } from \"@solana/spl-token\";\n// import { programs } from '@metaplex/js';\n// import { LAMPORTS_PER_SOL, SystemProgram, PublicKey, Connection, clusterApiUrl } from \"@solana/web3.js\";\n// const { metadata: { Metadata } } = programs\n// // const connection = new anchor.web3.Connection(NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\" ? \"https://metaplex.devnet.rpcpool.com\" : \"https://metaplex.mainnet.rpcpool.com\");\n// const connection = new anchor.web3.Connection(NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\" ? \"https://api.devnet.solana.com\" : \"https://metaplex.mainnet.rpcpool.com\");\n// export const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\n//   \"cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ\"\n// );\n// const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new anchor.web3.PublicKey(\n//   \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\n// );\n// const TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n//   \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n// );\n// const ARWEAVE_PUBKEY = new anchor.web3.PublicKey(\"XCVoVzSUv6nM7zytC1CPk9b2BxsQwXC1sW8wxQRhHBC\");\n// const RENT_STORAGE_PRICE = 0.015;\n// export interface CandyMachine {\n//   id: anchor.web3.PublicKey,\n//   connection: anchor.web3.Connection;\n//   program: anchor.Program;\n// }\n// interface CandyMachineState {\n//   candyMachine: CandyMachine;\n//   itemsAvailable: number;\n//   itemsRedeemed: number;\n//   itemsRemaining: number;\n//   goLiveDate: Date,\n// }\n// export const awaitTransactionSignatureConfirmation = async (\n//   txid: anchor.web3.TransactionSignature,\n//   timeout: number,\n//   connection: anchor.web3.Connection,\n//   commitment: anchor.web3.Commitment = \"recent\",\n//   queryStatus = false\n// ): Promise<anchor.web3.SignatureStatus | null | void> => {\n//   let done = false;\n//   let status: anchor.web3.SignatureStatus | null | void = {\n//     slot: 0,\n//     confirmations: 0,\n//     err: null,\n//   };\n//   let subId = 0;\n//   status = await new Promise(async (resolve, reject) => {\n//     setTimeout(() => {\n//       if (done) {\n//         return;\n//       }\n//       done = true;\n//       console.log(\"Rejecting for timeout...\");\n//       reject({ timeout: true });\n//     }, timeout);\n//     try {\n//       subId = connection.onSignature(\n//         txid,\n//         (result: any, context: any) => {\n//           done = true;\n//           status = {\n//             err: result.err,\n//             slot: context.slot,\n//             confirmations: 0,\n//           };\n//           if (result.err) {\n//             console.log(\"Rejected via websocket\", result.err);\n//             reject(status);\n//           } else {\n//             console.log(\"Resolved via websocket\", result);\n//             resolve(status);\n//           }\n//         },\n//         commitment\n//       );\n//     } catch (e) {\n//       done = true;\n//       console.error(\"WS error in setup\", txid, e);\n//     }\n//     while (!done && queryStatus) {\n//       // eslint-disable-next-line no-loop-func\n//       (async () => {\n//         try {\n//           const signatureStatuses = await connection.getSignatureStatuses([\n//             txid,\n//           ]);\n//           status = signatureStatuses && signatureStatuses.value[0];\n//           if (!done) {\n//             if (!status) {\n//               console.log(\"REST null result for\", txid, status);\n//             } else if (status.err) {\n//               console.log(\"REST error for\", txid, status);\n//               done = true;\n//               reject(status.err);\n//             } else if (!status.confirmations) {\n//               console.log(\"REST no confirmations for\", txid, status);\n//             } else {\n//               console.log(\"REST confirmation for\", txid, status);\n//               done = true;\n//               resolve(status);\n//             }\n//           }\n//         } catch (e) {\n//           if (!done) {\n//             console.log(\"REST connection error: txid\", txid, e);\n//           }\n//         }\n//       })();\n//       await sleep(2000);\n//     }\n//   });\n//   //@ts-ignore\n//   if (connection._signatureSubscriptions[subId]) {\n//     connection.removeSignatureListener(subId);\n//   }\n//   done = true;\n//   console.log(\"Returning status \", status);\n//   return status;\n// }\n// const createAssociatedTokenAccountInstruction = (\n//   associatedTokenAddress: anchor.web3.PublicKey,\n//   payer: anchor.web3.PublicKey,\n//   walletAddress: anchor.web3.PublicKey,\n//   splTokenMintAddress: anchor.web3.PublicKey\n// ) => {\n//   const keys = [\n//     { pubkey: payer, isSigner: true, isWritable: true },\n//     { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n//     { pubkey: walletAddress, isSigner: false, isWritable: false },\n//     { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n//     {\n//       pubkey: anchor.web3.SystemProgram.programId,\n//       isSigner: false,\n//       isWritable: false,\n//     },\n//     { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n//     {\n//       pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n//       isSigner: false,\n//       isWritable: false,\n//     },\n//   ];\n//   return new anchor.web3.TransactionInstruction({\n//     keys,\n//     programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n//     data: Buffer.from([]),\n//   });\n// }\n// export const getCandyMachineState = async (\n//   anchorWallet: anchor.Wallet,\n//   candyMachineId: anchor.web3.PublicKey,\n//   connection: anchor.web3.Connection,\n// ): Promise<CandyMachineState> => {\n//   const provider = new anchor.Provider(connection, anchorWallet, {\n//     preflightCommitment: \"recent\",\n//   });\n//   const idl = await anchor.Program.fetchIdl(\n//     CANDY_MACHINE_PROGRAM,\n//     provider\n//   );\n//   const program = new anchor.Program(idl!, CANDY_MACHINE_PROGRAM, provider);\n//   const candyMachine = {\n//     id: candyMachineId,\n//     connection,\n//     program,\n//   }\n//   const state: any = await program.account.candyMachine.fetch(candyMachineId);\n//   const itemsAvailable = state.data.itemsAvailable.toNumber();\n//   const itemsRedeemed = state.itemsRedeemed.toNumber();\n//   const itemsRemaining = itemsAvailable - itemsRedeemed;\n//   let goLiveDate = state.data.goLiveDate.toNumber();\n//   goLiveDate = new Date(goLiveDate * 1000);\n//   return {\n//     candyMachine,\n//     itemsAvailable,\n//     itemsRedeemed,\n//     itemsRemaining,\n//     goLiveDate,\n//   };\n// }\n// const getMasterEdition = async (\n//   mint: anchor.web3.PublicKey\n// ): Promise<anchor.web3.PublicKey> => {\n//   return (\n//     await anchor.web3.PublicKey.findProgramAddress(\n//       [\n//         Buffer.from(\"metadata\"),\n//         TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n//         mint.toBuffer(),\n//         Buffer.from(\"edition\"),\n//       ],\n//       TOKEN_METADATA_PROGRAM_ID\n//     )\n//   )[0];\n// };\n// const getMetadata = async (\n//   mint: anchor.web3.PublicKey\n// ): Promise<anchor.web3.PublicKey> => {\n//   return (\n//     await anchor.web3.PublicKey.findProgramAddress(\n//       [\n//         Buffer.from(\"metadata\"),\n//         TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n//         mint.toBuffer(),\n//       ],\n//       TOKEN_METADATA_PROGRAM_ID\n//     )\n//   )[0];\n// };\n// const getTokenWallet = async (\n//   wallet: anchor.web3.PublicKey,\n//   mint: anchor.web3.PublicKey\n// ) => {\n//   return (\n//     await anchor.web3.PublicKey.findProgramAddress(\n//       [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n//       SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n//     )\n//   )[0];\n// };\n// export async function getNftsForOwner(\n//   conn: any,\n//   owner: PublicKey\n// ) {\n//   const allTokens: any = []\n//   const tokenAccounts = await conn.getParsedTokenAccountsByOwner(owner, {\n//     programId: TOKEN_PROGRAM_ID\n//   });\n//   for (let index = 0; index < tokenAccounts.value.length; index++) {\n//     try {\n//       const tokenAccount = tokenAccounts.value[index];\n//       const tokenAmount = tokenAccount.account.data.parsed.info.tokenAmount;\n//       if (tokenAmount.amount == \"1\" && tokenAmount.decimals == \"0\") {\n//         let nftMint = new PublicKey(tokenAccount.account.data.parsed.info.mint)\n//         let [pda] = await anchor.web3.PublicKey.findProgramAddress([\n//           Buffer.from(\"metadata\"),\n//           TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n//           nftMint.toBuffer(),\n//         ], TOKEN_METADATA_PROGRAM_ID);\n//         const accountInfo: any = await conn.getParsedAccountInfo(pda);\n//         let metadata: any = new Metadata(owner.toString(), accountInfo.value);\n//         const { data }: any = await axios.get(metadata.data.data.uri)\n//         if (metadata.data.data.symbol == COLLECTION_NAME) {\n//           const entireData = { ...data, id: Number(data.name.replace(/^\\D+/g, '').split(' - ')[0]) }\n//           allTokens.push({ account: tokenAccount.pubkey, address: nftMint, ...entireData })\n//         }\n//       }\n//       allTokens.sort(function (a: any, b: any) {\n//         if (a.name < b.name) { return -1; }\n//         if (a.name > b.name) { return 1; }\n//         return 0;\n//       })\n//     } catch (err) {\n//       continue;\n//     }\n//   }\n//   // console.log('-------', allTokens);\n//   return allTokens\n// }\n// export async function getNftsForOwner1(\n//   owner: PublicKey\n// ) {\n//   const allTokens: any = []\n//   try {\n//     const address = owner.toString();\n//     const publicAddress = await resolveToWalletAddress({\n//       text: address, connection\n//     });\n//     const nftArray = await getParsedNftAccountsByOwner({\n//       publicAddress, connection\n//     });\n//     //console.log(\"nftArray: \", nftArray);\n//     for (let nft of nftArray) {\n//       // if (nft.data.symbol == COLLECTION_NAME) {\n//         //console.log(\"nft: \", nft);\n//         const tokenAccount = await getTokenWallet(owner, new anchor.web3.PublicKey(nft.mint));\n//         const { data }: any = await axios.get(nft.data.uri);\n//         if(data.name){\n//           const entireData = { ...data, id: Number(data.name.replace(/^\\D+/g, '').split(' - ')[0]) };\n//           console.log('mint', nft.mint, 'account', tokenAccount.toString());\n//           allTokens.push({ account: tokenAccount, address: new PublicKey(nft.mint), ...entireData });\n//         }\n//       // }\n//     }\n//   } catch (error: any) {\n//     console.log(\"Error thrown, while fetching NFTs\", error.message);\n//   }\n//   return allTokens\n// }\n// export const mintOneToken = async (\n//   candyMachine: CandyMachine,\n//   config: anchor.web3.PublicKey,\n//   payer: anchor.web3.PublicKey,\n//   treasury: anchor.web3.PublicKey,\n// ): Promise<string> => {\n//   const mint = anchor.web3.Keypair.generate();\n//   const token = await getTokenWallet(payer, mint.publicKey);\n//   const { connection, program } = candyMachine;\n//   const metadata = await getMetadata(mint.publicKey);\n//   const masterEdition = await getMasterEdition(mint.publicKey);\n//   const rent = await connection.getMinimumBalanceForRentExemption(\n//     MintLayout.span\n//   );\n//   return await program.rpc.mintNft({\n//     accounts: {\n//       config,\n//       candyMachine: candyMachine.id,\n//       payer: payer,\n//       wallet: treasury,\n//       mint: mint.publicKey,\n//       metadata,\n//       masterEdition,\n//       mintAuthority: payer,\n//       updateAuthority: payer,\n//       tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n//       tokenProgram: TOKEN_PROGRAM_ID,\n//       systemProgram: anchor.web3.SystemProgram.programId,\n//       rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n//       clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n//     },\n//     signers: [mint],\n//     instructions: [\n//       anchor.web3.SystemProgram.createAccount({\n//         fromPubkey: payer,\n//         newAccountPubkey: mint.publicKey,\n//         space: MintLayout.span,\n//         lamports: rent,\n//         programId: TOKEN_PROGRAM_ID,\n//       }),\n//       Token.createInitMintInstruction(\n//         TOKEN_PROGRAM_ID,\n//         mint.publicKey,\n//         0,\n//         payer,\n//         payer\n//       ),\n//       createAssociatedTokenAccountInstruction(\n//         token,\n//         payer,\n//         payer,\n//         mint.publicKey\n//       ),\n//       Token.createMintToInstruction(\n//         TOKEN_PROGRAM_ID,\n//         mint.publicKey,\n//         token,\n//         payer,\n//         [],\n//         1\n//       ),\n//       SystemProgram.transfer({\n//         fromPubkey: payer,\n//         toPubkey: ARWEAVE_PUBKEY,\n//         lamports: LAMPORTS_PER_SOL * RENT_STORAGE_PRICE,\n//       }),\n//     ],\n//   });\n// }\n// export const shortenAddress = (address: string, chars = 4): string => {\n//   return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n// };\n// const sleep = (ms: number): Promise<void> => {\n//   return new Promise((resolve) => setTimeout(resolve, ms));\n// }\n// export const mintMultipleToken = async (\n//   candyMachine: any,\n//   config: anchor.web3.PublicKey,\n//   payer: anchor.web3.PublicKey,\n//   treasury: anchor.web3.PublicKey,\n//   quantity: number = 2,\n// ) => {\n//   const signersMatrix = []\n//   const instructionsMatrix = []\n//   for (let index = 0; index < quantity; index++) {\n//     const mint = anchor.web3.Keypair.generate();\n//     const token = await getTokenWallet(payer, mint.publicKey);\n//     //const { connection } = candyMachine;\n//     let connection = new Connection(clusterApiUrl(\"devnet\"));\n//     console.log(\"candyMachine: \", candyMachine);\n//     const rent = await connection.getMinimumBalanceForRentExemption(\n//       MintLayout.span\n//     );\n//     console.log(\"rent: \", rent);\n//     const instructions = [\n//       anchor.web3.SystemProgram.createAccount({\n//         fromPubkey: payer,\n//         newAccountPubkey: mint.publicKey,\n//         space: MintLayout.span,\n//         lamports: rent,\n//         programId: TOKEN_PROGRAM_ID,\n//       }),\n//       Token.createInitMintInstruction(\n//         TOKEN_PROGRAM_ID,\n//         mint.publicKey,\n//         0,\n//         payer,\n//         payer\n//       ),\n//       createAssociatedTokenAccountInstruction(\n//         token,\n//         payer,\n//         payer,\n//         mint.publicKey\n//       ),\n//       Token.createMintToInstruction(\n//         TOKEN_PROGRAM_ID,\n//         mint.publicKey,\n//         token,\n//         payer,\n//         [],\n//         1\n//       ),\n//       SystemProgram.transfer({\n//         fromPubkey: payer,\n//         toPubkey: ARWEAVE_PUBKEY,\n//         lamports: LAMPORTS_PER_SOL * RENT_STORAGE_PRICE,\n//       }),\n//     ];\n//     const masterEdition = await getMasterEdition(mint.publicKey);\n//     //console.log(\"masterEdition: \", masterEdition);\n//     const metadata = await getMetadata(mint.publicKey);\n//     //console.log(\"metadata: \", metadata);\n//     instructions.push(\n//       await candyMachine.program.instruction.mintNft({\n//         accounts: {\n//           config,\n//           candyMachine: candyMachine.id,\n//           payer: payer,\n//           wallet: treasury,\n//           mint: mint.publicKey,\n//           metadata,\n//           masterEdition,\n//           mintAuthority: payer,\n//           updateAuthority: payer,\n//           tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n//           tokenProgram: TOKEN_PROGRAM_ID,\n//           systemProgram: anchor.web3.SystemProgram.programId,\n//           rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n//           clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n//         }\n//       }),\n//     );\n//     const signers: anchor.web3.Keypair[] = [mint];\n//     signersMatrix.push(signers)\n//     instructionsMatrix.push(instructions)\n//   }\n//   return await sendTransactions(\n//     candyMachine.program.provider.connection,\n//     candyMachine.program.provider.wallet,\n//     instructionsMatrix,\n//     signersMatrix,\n//   );\n// }\n// export async function getSlimeRevealNfts(\n//   owner: PublicKey\n// ) {\n//   const allTokens: any = []\n//   try {\n//     const address = owner.toString();\n//     const publicAddress = await resolveToWalletAddress({\n//       text: address, connection\n//     });\n//     const nftArray = await getParsedNftAccountsByOwner({\n//       publicAddress, connection\n//     });\n//     //console.log(\"nftArray: \", nftArray);\n//     for (let nft of nftArray) {\n//       // if (nft.data.symbol == COLLECTION_NAME) {        \n//         if(nft.data && nft.data.name && nft.data.name.includes(NEXT_PUBLIC_SOLANA_NFT_NAME)){        \n//           const tokenAccount = await getTokenWallet(owner, new anchor.web3.PublicKey(nft.mint));\n//           //console.log(\"metadata uri:\",nft.data.uri)\n//           const { data }: any = await axios.get(nft.data.uri);\n//           if(data.name){\n//             //console.log(\"data: \", data);\n//             const entireData = { ...data, id: Number(data.name.replace(/^\\D+/g, '').split(' - ')[0]) };\n//             console.log('mint', nft.mint, 'account', tokenAccount.toString());\n//             //console.log(\"slime entiredata: \", entireData);\n//             allTokens.push({ account: tokenAccount, address: new PublicKey(nft.mint), ...entireData });\n//           }\n//       // }\n//         }\n//     }\n//   } catch (error: any) {\n//     console.log(\"Error thrown, while fetching NFTs\", error.message);\n//   }\n//   return allTokens\n// }\n// export async function getSlimeNfts(\n//   owner: PublicKey\n// ) {\n//   const allTokens: any = []\n//   try {\n//     const address = owner.toString();\n//     const publicAddress = await resolveToWalletAddress({\n//       text: address, connection\n//     });\n//     const nftArray = await getParsedNftAccountsByOwner({\n//       publicAddress, connection\n//     });\n//     //console.log(\"nftArray: \", nftArray);\n//     console.log(\"REACT_APP_SOLANA_COL_CREATOR: \", NEXT_PUBLIC_SOLANA_COL_CREATOR);\n//     for (let nft of nftArray) {\n//       // if (nft.data.symbol == COLLECTION_NAME) {        \n//         if(nft.data && nft.data.creators && nft.data.creators[0].address === NEXT_PUBLIC_SOLANA_COL_CREATOR){        \n//           const tokenAccount = await getTokenWallet(owner, new anchor.web3.PublicKey(nft.mint));\n//           //console.log(\"metadata uri:\",nft.data.uri)\n//           const { data }: any = await axios.get(nft.data.uri);\n//           if(data.name){\n//             //console.log(\"data: \", data);\n//             const entireData = { ...data, id: Number(data.name.replace(/^\\D+/g, '').split(' - ')[0]) };\n//             console.log('mint', nft.mint, 'account', tokenAccount.toString());\n//             //console.log(\"slime entiredata: \", entireData);\n//             allTokens.push({ account: tokenAccount, address: new PublicKey(nft.mint), ...entireData });\n//           }\n//       // }\n//         }\n//     }\n//   } catch (error: any) {\n//     console.log(\"Error thrown, while fetching NFTs\", error.message);\n//   }\n//   return allTokens\n// }","map":{"version":3,"names":[],"sources":["D:/software/o5o BNB/o5o-staking-frontend/src/utils/candy-machine.ts"],"sourcesContent":["// import axios from \"axios\";\r\n// import { sendTransactions } from \"./utility\";\r\n// import { fetchHashTable } from \"../hooks/use-hash-table\";\r\n// import { COLLECTION_NAME, COLLECTION_SYMBOL } from \"../constant/contract\";\r\n// import { NEXT_PUBLIC_SOLANA_NETWORK, NEXT_PUBLIC_SOLANA_COL_CREATOR, NEXT_PUBLIC_SOLANA_NFT_NAME } from '../constant/env';\r\n// import * as anchor from \"@project-serum/anchor\";\r\n// import {\r\n//   resolveToWalletAddress,\r\n//   getParsedNftAccountsByOwner,\r\n// } from \"@nfteyez/sol-rayz\";\r\n// import {\r\n//   MintLayout,\r\n//   TOKEN_PROGRAM_ID,\r\n//   Token,\r\n// } from \"@solana/spl-token\";\r\n// import { programs } from '@metaplex/js';\r\n// import { LAMPORTS_PER_SOL, SystemProgram, PublicKey, Connection, clusterApiUrl } from \"@solana/web3.js\";\r\n// const { metadata: { Metadata } } = programs\r\n\r\n\r\n// // const connection = new anchor.web3.Connection(NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\" ? \"https://metaplex.devnet.rpcpool.com\" : \"https://metaplex.mainnet.rpcpool.com\");\r\n// const connection = new anchor.web3.Connection(NEXT_PUBLIC_SOLANA_NETWORK == \"devnet\" ? \"https://api.devnet.solana.com\" : \"https://metaplex.mainnet.rpcpool.com\");\r\n\r\n// export const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\r\n//   \"cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ\"\r\n// );\r\n\r\n// const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new anchor.web3.PublicKey(\r\n//   \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\r\n// );\r\n\r\n// const TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\r\n//   \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\r\n// );\r\n\r\n// const ARWEAVE_PUBKEY = new anchor.web3.PublicKey(\"XCVoVzSUv6nM7zytC1CPk9b2BxsQwXC1sW8wxQRhHBC\");\r\n// const RENT_STORAGE_PRICE = 0.015;\r\n\r\n// export interface CandyMachine {\r\n//   id: anchor.web3.PublicKey,\r\n//   connection: anchor.web3.Connection;\r\n//   program: anchor.Program;\r\n// }\r\n\r\n// interface CandyMachineState {\r\n//   candyMachine: CandyMachine;\r\n//   itemsAvailable: number;\r\n//   itemsRedeemed: number;\r\n//   itemsRemaining: number;\r\n//   goLiveDate: Date,\r\n// }\r\n\r\n// export const awaitTransactionSignatureConfirmation = async (\r\n//   txid: anchor.web3.TransactionSignature,\r\n//   timeout: number,\r\n//   connection: anchor.web3.Connection,\r\n//   commitment: anchor.web3.Commitment = \"recent\",\r\n//   queryStatus = false\r\n// ): Promise<anchor.web3.SignatureStatus | null | void> => {\r\n//   let done = false;\r\n//   let status: anchor.web3.SignatureStatus | null | void = {\r\n//     slot: 0,\r\n//     confirmations: 0,\r\n//     err: null,\r\n//   };\r\n//   let subId = 0;\r\n//   status = await new Promise(async (resolve, reject) => {\r\n//     setTimeout(() => {\r\n//       if (done) {\r\n//         return;\r\n//       }\r\n//       done = true;\r\n//       console.log(\"Rejecting for timeout...\");\r\n//       reject({ timeout: true });\r\n//     }, timeout);\r\n//     try {\r\n//       subId = connection.onSignature(\r\n//         txid,\r\n//         (result: any, context: any) => {\r\n//           done = true;\r\n//           status = {\r\n//             err: result.err,\r\n//             slot: context.slot,\r\n//             confirmations: 0,\r\n//           };\r\n//           if (result.err) {\r\n//             console.log(\"Rejected via websocket\", result.err);\r\n//             reject(status);\r\n//           } else {\r\n//             console.log(\"Resolved via websocket\", result);\r\n//             resolve(status);\r\n//           }\r\n//         },\r\n//         commitment\r\n//       );\r\n//     } catch (e) {\r\n//       done = true;\r\n//       console.error(\"WS error in setup\", txid, e);\r\n//     }\r\n//     while (!done && queryStatus) {\r\n//       // eslint-disable-next-line no-loop-func\r\n//       (async () => {\r\n//         try {\r\n//           const signatureStatuses = await connection.getSignatureStatuses([\r\n//             txid,\r\n//           ]);\r\n//           status = signatureStatuses && signatureStatuses.value[0];\r\n//           if (!done) {\r\n//             if (!status) {\r\n//               console.log(\"REST null result for\", txid, status);\r\n//             } else if (status.err) {\r\n//               console.log(\"REST error for\", txid, status);\r\n//               done = true;\r\n//               reject(status.err);\r\n//             } else if (!status.confirmations) {\r\n//               console.log(\"REST no confirmations for\", txid, status);\r\n//             } else {\r\n//               console.log(\"REST confirmation for\", txid, status);\r\n//               done = true;\r\n//               resolve(status);\r\n//             }\r\n//           }\r\n//         } catch (e) {\r\n//           if (!done) {\r\n//             console.log(\"REST connection error: txid\", txid, e);\r\n//           }\r\n//         }\r\n//       })();\r\n//       await sleep(2000);\r\n//     }\r\n//   });\r\n\r\n//   //@ts-ignore\r\n//   if (connection._signatureSubscriptions[subId]) {\r\n//     connection.removeSignatureListener(subId);\r\n//   }\r\n//   done = true;\r\n//   console.log(\"Returning status \", status);\r\n//   return status;\r\n// }\r\n\r\n// const createAssociatedTokenAccountInstruction = (\r\n//   associatedTokenAddress: anchor.web3.PublicKey,\r\n//   payer: anchor.web3.PublicKey,\r\n//   walletAddress: anchor.web3.PublicKey,\r\n//   splTokenMintAddress: anchor.web3.PublicKey\r\n// ) => {\r\n//   const keys = [\r\n//     { pubkey: payer, isSigner: true, isWritable: true },\r\n//     { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\r\n//     { pubkey: walletAddress, isSigner: false, isWritable: false },\r\n//     { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\r\n//     {\r\n//       pubkey: anchor.web3.SystemProgram.programId,\r\n//       isSigner: false,\r\n//       isWritable: false,\r\n//     },\r\n//     { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\r\n//     {\r\n//       pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n//       isSigner: false,\r\n//       isWritable: false,\r\n//     },\r\n//   ];\r\n//   return new anchor.web3.TransactionInstruction({\r\n//     keys,\r\n//     programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n//     data: Buffer.from([]),\r\n//   });\r\n// }\r\n\r\n// export const getCandyMachineState = async (\r\n//   anchorWallet: anchor.Wallet,\r\n//   candyMachineId: anchor.web3.PublicKey,\r\n//   connection: anchor.web3.Connection,\r\n// ): Promise<CandyMachineState> => {\r\n//   const provider = new anchor.Provider(connection, anchorWallet, {\r\n//     preflightCommitment: \"recent\",\r\n//   });\r\n\r\n//   const idl = await anchor.Program.fetchIdl(\r\n//     CANDY_MACHINE_PROGRAM,\r\n//     provider\r\n//   );\r\n\r\n//   const program = new anchor.Program(idl!, CANDY_MACHINE_PROGRAM, provider);\r\n//   const candyMachine = {\r\n//     id: candyMachineId,\r\n//     connection,\r\n//     program,\r\n//   }\r\n//   const state: any = await program.account.candyMachine.fetch(candyMachineId);\r\n//   const itemsAvailable = state.data.itemsAvailable.toNumber();\r\n//   const itemsRedeemed = state.itemsRedeemed.toNumber();\r\n//   const itemsRemaining = itemsAvailable - itemsRedeemed;\r\n\r\n//   let goLiveDate = state.data.goLiveDate.toNumber();\r\n//   goLiveDate = new Date(goLiveDate * 1000);\r\n\r\n//   return {\r\n//     candyMachine,\r\n//     itemsAvailable,\r\n//     itemsRedeemed,\r\n//     itemsRemaining,\r\n//     goLiveDate,\r\n//   };\r\n// }\r\n\r\n// const getMasterEdition = async (\r\n//   mint: anchor.web3.PublicKey\r\n// ): Promise<anchor.web3.PublicKey> => {\r\n//   return (\r\n//     await anchor.web3.PublicKey.findProgramAddress(\r\n//       [\r\n//         Buffer.from(\"metadata\"),\r\n//         TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n//         mint.toBuffer(),\r\n//         Buffer.from(\"edition\"),\r\n//       ],\r\n//       TOKEN_METADATA_PROGRAM_ID\r\n//     )\r\n//   )[0];\r\n// };\r\n\r\n// const getMetadata = async (\r\n//   mint: anchor.web3.PublicKey\r\n// ): Promise<anchor.web3.PublicKey> => {\r\n//   return (\r\n//     await anchor.web3.PublicKey.findProgramAddress(\r\n//       [\r\n//         Buffer.from(\"metadata\"),\r\n//         TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n//         mint.toBuffer(),\r\n//       ],\r\n//       TOKEN_METADATA_PROGRAM_ID\r\n//     )\r\n//   )[0];\r\n// };\r\n\r\n// const getTokenWallet = async (\r\n//   wallet: anchor.web3.PublicKey,\r\n//   mint: anchor.web3.PublicKey\r\n// ) => {\r\n//   return (\r\n//     await anchor.web3.PublicKey.findProgramAddress(\r\n//       [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\r\n//       SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n//     )\r\n//   )[0];\r\n// };\r\n\r\n// export async function getNftsForOwner(\r\n//   conn: any,\r\n//   owner: PublicKey\r\n// ) {\r\n//   const allTokens: any = []\r\n//   const tokenAccounts = await conn.getParsedTokenAccountsByOwner(owner, {\r\n//     programId: TOKEN_PROGRAM_ID\r\n//   });\r\n\r\n//   for (let index = 0; index < tokenAccounts.value.length; index++) {\r\n//     try {\r\n//       const tokenAccount = tokenAccounts.value[index];\r\n//       const tokenAmount = tokenAccount.account.data.parsed.info.tokenAmount;\r\n\r\n//       if (tokenAmount.amount == \"1\" && tokenAmount.decimals == \"0\") {\r\n//         let nftMint = new PublicKey(tokenAccount.account.data.parsed.info.mint)\r\n//         let [pda] = await anchor.web3.PublicKey.findProgramAddress([\r\n//           Buffer.from(\"metadata\"),\r\n//           TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n//           nftMint.toBuffer(),\r\n//         ], TOKEN_METADATA_PROGRAM_ID);\r\n//         const accountInfo: any = await conn.getParsedAccountInfo(pda);\r\n//         let metadata: any = new Metadata(owner.toString(), accountInfo.value);\r\n//         const { data }: any = await axios.get(metadata.data.data.uri)\r\n//         if (metadata.data.data.symbol == COLLECTION_NAME) {\r\n//           const entireData = { ...data, id: Number(data.name.replace(/^\\D+/g, '').split(' - ')[0]) }\r\n//           allTokens.push({ account: tokenAccount.pubkey, address: nftMint, ...entireData })\r\n//         }\r\n//       }\r\n//       allTokens.sort(function (a: any, b: any) {\r\n//         if (a.name < b.name) { return -1; }\r\n//         if (a.name > b.name) { return 1; }\r\n//         return 0;\r\n//       })\r\n//     } catch (err) {\r\n//       continue;\r\n//     }\r\n//   }\r\n//   // console.log('-------', allTokens);\r\n//   return allTokens\r\n// }\r\n\r\n// export async function getNftsForOwner1(\r\n//   owner: PublicKey\r\n// ) {\r\n//   const allTokens: any = []\r\n//   try {\r\n//     const address = owner.toString();\r\n//     const publicAddress = await resolveToWalletAddress({\r\n//       text: address, connection\r\n//     });\r\n\r\n//     const nftArray = await getParsedNftAccountsByOwner({\r\n//       publicAddress, connection\r\n//     });\r\n//     //console.log(\"nftArray: \", nftArray);\r\n//     for (let nft of nftArray) {\r\n//       // if (nft.data.symbol == COLLECTION_NAME) {\r\n//         //console.log(\"nft: \", nft);\r\n//         const tokenAccount = await getTokenWallet(owner, new anchor.web3.PublicKey(nft.mint));\r\n//         const { data }: any = await axios.get(nft.data.uri);\r\n//         if(data.name){\r\n//           const entireData = { ...data, id: Number(data.name.replace(/^\\D+/g, '').split(' - ')[0]) };\r\n//           console.log('mint', nft.mint, 'account', tokenAccount.toString());\r\n//           allTokens.push({ account: tokenAccount, address: new PublicKey(nft.mint), ...entireData });\r\n//         }\r\n//       // }\r\n//     }\r\n//   } catch (error: any) {\r\n//     console.log(\"Error thrown, while fetching NFTs\", error.message);\r\n//   }\r\n//   return allTokens\r\n// }\r\n\r\n// export const mintOneToken = async (\r\n//   candyMachine: CandyMachine,\r\n//   config: anchor.web3.PublicKey,\r\n//   payer: anchor.web3.PublicKey,\r\n//   treasury: anchor.web3.PublicKey,\r\n// ): Promise<string> => {\r\n//   const mint = anchor.web3.Keypair.generate();\r\n//   const token = await getTokenWallet(payer, mint.publicKey);\r\n//   const { connection, program } = candyMachine;\r\n//   const metadata = await getMetadata(mint.publicKey);\r\n//   const masterEdition = await getMasterEdition(mint.publicKey);\r\n//   const rent = await connection.getMinimumBalanceForRentExemption(\r\n//     MintLayout.span\r\n//   );\r\n\r\n//   return await program.rpc.mintNft({\r\n//     accounts: {\r\n//       config,\r\n//       candyMachine: candyMachine.id,\r\n//       payer: payer,\r\n//       wallet: treasury,\r\n//       mint: mint.publicKey,\r\n//       metadata,\r\n//       masterEdition,\r\n//       mintAuthority: payer,\r\n//       updateAuthority: payer,\r\n//       tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n//       tokenProgram: TOKEN_PROGRAM_ID,\r\n//       systemProgram: anchor.web3.SystemProgram.programId,\r\n//       rent: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n//       clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\r\n//     },\r\n//     signers: [mint],\r\n//     instructions: [\r\n//       anchor.web3.SystemProgram.createAccount({\r\n//         fromPubkey: payer,\r\n//         newAccountPubkey: mint.publicKey,\r\n//         space: MintLayout.span,\r\n//         lamports: rent,\r\n//         programId: TOKEN_PROGRAM_ID,\r\n//       }),\r\n//       Token.createInitMintInstruction(\r\n//         TOKEN_PROGRAM_ID,\r\n//         mint.publicKey,\r\n//         0,\r\n//         payer,\r\n//         payer\r\n//       ),\r\n//       createAssociatedTokenAccountInstruction(\r\n//         token,\r\n//         payer,\r\n//         payer,\r\n//         mint.publicKey\r\n//       ),\r\n//       Token.createMintToInstruction(\r\n//         TOKEN_PROGRAM_ID,\r\n//         mint.publicKey,\r\n//         token,\r\n//         payer,\r\n//         [],\r\n//         1\r\n//       ),\r\n//       SystemProgram.transfer({\r\n//         fromPubkey: payer,\r\n//         toPubkey: ARWEAVE_PUBKEY,\r\n//         lamports: LAMPORTS_PER_SOL * RENT_STORAGE_PRICE,\r\n//       }),\r\n//     ],\r\n//   });\r\n// }\r\n\r\n// export const shortenAddress = (address: string, chars = 4): string => {\r\n//   return `${address.slice(0, chars)}...${address.slice(-chars)}`;\r\n// };\r\n\r\n// const sleep = (ms: number): Promise<void> => {\r\n//   return new Promise((resolve) => setTimeout(resolve, ms));\r\n// }\r\n\r\n// export const mintMultipleToken = async (\r\n//   candyMachine: any,\r\n//   config: anchor.web3.PublicKey,\r\n//   payer: anchor.web3.PublicKey,\r\n//   treasury: anchor.web3.PublicKey,\r\n//   quantity: number = 2,\r\n// ) => {\r\n//   const signersMatrix = []\r\n//   const instructionsMatrix = []\r\n\r\n//   for (let index = 0; index < quantity; index++) {\r\n//     const mint = anchor.web3.Keypair.generate();\r\n//     const token = await getTokenWallet(payer, mint.publicKey);\r\n//     //const { connection } = candyMachine;\r\n//     let connection = new Connection(clusterApiUrl(\"devnet\"));\r\n//     console.log(\"candyMachine: \", candyMachine);\r\n//     const rent = await connection.getMinimumBalanceForRentExemption(\r\n//       MintLayout.span\r\n//     );\r\n//     console.log(\"rent: \", rent);\r\n//     const instructions = [\r\n//       anchor.web3.SystemProgram.createAccount({\r\n//         fromPubkey: payer,\r\n//         newAccountPubkey: mint.publicKey,\r\n//         space: MintLayout.span,\r\n//         lamports: rent,\r\n//         programId: TOKEN_PROGRAM_ID,\r\n//       }),\r\n//       Token.createInitMintInstruction(\r\n//         TOKEN_PROGRAM_ID,\r\n//         mint.publicKey,\r\n//         0,\r\n//         payer,\r\n//         payer\r\n//       ),\r\n//       createAssociatedTokenAccountInstruction(\r\n//         token,\r\n//         payer,\r\n//         payer,\r\n//         mint.publicKey\r\n//       ),\r\n//       Token.createMintToInstruction(\r\n//         TOKEN_PROGRAM_ID,\r\n//         mint.publicKey,\r\n//         token,\r\n//         payer,\r\n//         [],\r\n//         1\r\n//       ),\r\n//       SystemProgram.transfer({\r\n//         fromPubkey: payer,\r\n//         toPubkey: ARWEAVE_PUBKEY,\r\n//         lamports: LAMPORTS_PER_SOL * RENT_STORAGE_PRICE,\r\n//       }),\r\n//     ];\r\n//     const masterEdition = await getMasterEdition(mint.publicKey);\r\n//     //console.log(\"masterEdition: \", masterEdition);\r\n//     const metadata = await getMetadata(mint.publicKey);\r\n//     //console.log(\"metadata: \", metadata);\r\n//     instructions.push(\r\n//       await candyMachine.program.instruction.mintNft({\r\n//         accounts: {\r\n//           config,\r\n//           candyMachine: candyMachine.id,\r\n//           payer: payer,\r\n//           wallet: treasury,\r\n//           mint: mint.publicKey,\r\n//           metadata,\r\n//           masterEdition,\r\n//           mintAuthority: payer,\r\n//           updateAuthority: payer,\r\n//           tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n//           tokenProgram: TOKEN_PROGRAM_ID,\r\n//           systemProgram: anchor.web3.SystemProgram.programId,\r\n//           rent: anchor.web3.SYSVAR_RENT_PUBKEY,\r\n//           clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\r\n//         }\r\n//       }),\r\n//     );\r\n//     const signers: anchor.web3.Keypair[] = [mint];\r\n\r\n//     signersMatrix.push(signers)\r\n//     instructionsMatrix.push(instructions)\r\n//   }\r\n\r\n//   return await sendTransactions(\r\n//     candyMachine.program.provider.connection,\r\n//     candyMachine.program.provider.wallet,\r\n//     instructionsMatrix,\r\n//     signersMatrix,\r\n//   );\r\n// }\r\n\r\n// export async function getSlimeRevealNfts(\r\n//   owner: PublicKey\r\n// ) {\r\n//   const allTokens: any = []\r\n//   try {\r\n//     const address = owner.toString();\r\n//     const publicAddress = await resolveToWalletAddress({\r\n//       text: address, connection\r\n//     });\r\n\r\n//     const nftArray = await getParsedNftAccountsByOwner({\r\n//       publicAddress, connection\r\n//     });\r\n//     //console.log(\"nftArray: \", nftArray);\r\n//     for (let nft of nftArray) {\r\n//       // if (nft.data.symbol == COLLECTION_NAME) {        \r\n//         if(nft.data && nft.data.name && nft.data.name.includes(NEXT_PUBLIC_SOLANA_NFT_NAME)){        \r\n//           const tokenAccount = await getTokenWallet(owner, new anchor.web3.PublicKey(nft.mint));\r\n//           //console.log(\"metadata uri:\",nft.data.uri)\r\n//           const { data }: any = await axios.get(nft.data.uri);\r\n//           if(data.name){\r\n//             //console.log(\"data: \", data);\r\n//             const entireData = { ...data, id: Number(data.name.replace(/^\\D+/g, '').split(' - ')[0]) };\r\n//             console.log('mint', nft.mint, 'account', tokenAccount.toString());\r\n//             //console.log(\"slime entiredata: \", entireData);\r\n//             allTokens.push({ account: tokenAccount, address: new PublicKey(nft.mint), ...entireData });\r\n//           }\r\n//       // }\r\n//         }\r\n//     }\r\n//   } catch (error: any) {\r\n//     console.log(\"Error thrown, while fetching NFTs\", error.message);\r\n//   }\r\n//   return allTokens\r\n// }\r\n\r\n// export async function getSlimeNfts(\r\n//   owner: PublicKey\r\n// ) {\r\n//   const allTokens: any = []\r\n//   try {\r\n//     const address = owner.toString();\r\n//     const publicAddress = await resolveToWalletAddress({\r\n//       text: address, connection\r\n//     });\r\n\r\n//     const nftArray = await getParsedNftAccountsByOwner({\r\n//       publicAddress, connection\r\n//     });\r\n//     //console.log(\"nftArray: \", nftArray);\r\n//     console.log(\"REACT_APP_SOLANA_COL_CREATOR: \", NEXT_PUBLIC_SOLANA_COL_CREATOR);\r\n//     for (let nft of nftArray) {\r\n//       // if (nft.data.symbol == COLLECTION_NAME) {        \r\n//         if(nft.data && nft.data.creators && nft.data.creators[0].address === NEXT_PUBLIC_SOLANA_COL_CREATOR){        \r\n//           const tokenAccount = await getTokenWallet(owner, new anchor.web3.PublicKey(nft.mint));\r\n//           //console.log(\"metadata uri:\",nft.data.uri)\r\n//           const { data }: any = await axios.get(nft.data.uri);\r\n//           if(data.name){\r\n//             //console.log(\"data: \", data);\r\n//             const entireData = { ...data, id: Number(data.name.replace(/^\\D+/g, '').split(' - ')[0]) };\r\n//             console.log('mint', nft.mint, 'account', tokenAccount.toString());\r\n//             //console.log(\"slime entiredata: \", entireData);\r\n//             allTokens.push({ account: tokenAccount, address: new PublicKey(nft.mint), ...entireData });\r\n//           }\r\n//       // }\r\n//         }\r\n//     }\r\n//   } catch (error: any) {\r\n//     console.log(\"Error thrown, while fetching NFTs\", error.message);\r\n//   }\r\n//   return allTokens\r\n// }"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}