{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { Pda } from '../../types/Pda.mjs';\n/**\n * This client allows you to build PDAs related to the Candy Machine module.\n *\n * @see {@link CandyMachineClient}\n * @group Module Pdas\n */\n\nclass CandyMachinePdasClient {\n  constructor(metaplex) {\n    this.metaplex = metaplex;\n  }\n  /** Finds the Authority PDA for the given Candy Machine. */\n\n\n  authority(_ref) {\n    let {\n      candyMachine,\n      programs\n    } = _ref;\n    const program = this.metaplex.programs().getCandyMachine(programs);\n    return Pda.find(program.address, [Buffer.from('candy_machine', 'utf8'), candyMachine.toBuffer()]);\n  }\n  /** Finds the Candy Guard PDA for the given base address it derives from. */\n\n\n  candyGuard(_ref2) {\n    let {\n      base,\n      programs\n    } = _ref2;\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [Buffer.from('candy_guard', 'utf8'), base.toBuffer()]);\n  }\n  /**\n   * Finds the Mint Limit Counter PDA that keeps track of how many\n   * NFTs where minted by a given user on a given Candy Machine.\n   */\n\n\n  mintLimitCounter(_ref3) {\n    let {\n      id,\n      user,\n      candyMachine,\n      candyGuard,\n      programs\n    } = _ref3;\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [Buffer.from('mint_limit', 'utf8'), Buffer.from([id]), user.toBuffer(), candyGuard.toBuffer(), candyMachine.toBuffer()]);\n  }\n  /**\n   * Finds the Allow List Proof PDA that keeps track of whether a user\n   * has provided the correct Merkle Proof for the given Merkle Root.\n   */\n\n\n  merkleProof(_ref4) {\n    let {\n      merkleRoot,\n      user,\n      candyMachine,\n      candyGuard,\n      programs\n    } = _ref4;\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [Buffer.from('allow_list', 'utf8'), merkleRoot, user.toBuffer(), candyGuard.toBuffer(), candyMachine.toBuffer()]);\n  }\n  /**\n   * Finds the Freeze PDA used as an escrow account by\n   * the freezeSolPayment and freezeTokenPayment guards.\n   */\n\n\n  freezeEscrow(_ref5) {\n    let {\n      destination,\n      candyMachine,\n      candyGuard,\n      programs\n    } = _ref5;\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [Buffer.from('freeze_escrow', 'utf8'), destination.toBuffer(), candyGuard.toBuffer(), candyMachine.toBuffer()]);\n  }\n\n}\n\nexport { CandyMachinePdasClient };","map":{"version":3,"sources":["../../../../src/plugins/candyMachineModule/CandyMachinePdasClient.ts"],"names":["CandyMachinePdasClient","constructor","metaplex","authority","candyMachine","programs","program","getCandyMachine","Pda","find","address","Buffer","from","toBuffer","candyGuard","base","getCandyGuard","mintLimitCounter","id","user","merkleProof","merkleRoot","freezeEscrow","destination"],"mappings":";;AAIA;AACA;AACA;AACA;AACA;AACA;;AACO,MAAMA,sBAAN,CAA6B;EAClCC,WAAW,CAAoBC,QAApB,EAAwC;IAApBA,KAAAA,QAAAA,GAAAA,QAAAA;EAAqB;EAEpD;;;EACAC,SAAS,OAQD;IAAA,IARE;MACRC,YADQ;MAERC;IAFQ,CAQF;IACN,MAAMC,OAAO,GAAG,KAAKJ,QAAL,CAAcG,QAAd,GAAyBE,eAAzB,CAAyCF,QAAzC,CAAhB;IACA,OAAOG,GAAG,CAACC,IAAJD,CAASF,OAAO,CAACI,OAAjBF,EAA0B,CAC/BG,MAAM,CAACC,IAAPD,CAAY,eAAZA,EAA6B,MAA7BA,CAD+B,EAE/BP,YAAY,CAACS,QAAbT,EAF+B,CAA1BI,CAAP;EAIF;EAEA;;;EACAM,UAAU,QAQF;IAAA,IARG;MACTC,IADS;MAETV;IAFS,CAQH;IACN,MAAMC,OAAO,GAAG,KAAKJ,QAAL,CAAcG,QAAd,GAAyBW,aAAzB,CAAuCX,QAAvC,CAAhB;IACA,OAAOG,GAAG,CAACC,IAAJD,CAASF,OAAO,CAACI,OAAjBF,EAA0B,CAC/BG,MAAM,CAACC,IAAPD,CAAY,aAAZA,EAA2B,MAA3BA,CAD+B,EAE/BI,IAAI,CAACF,QAALE,EAF+B,CAA1BP,CAAP;EAIF;EAEA;AACF;AACA;AACA;;;EACES,gBAAgB,QAiBR;IAAA,IAjBS;MACfC,EADe;MAEfC,IAFe;MAGff,YAHe;MAIfU,UAJe;MAKfT;IALe,CAiBT;IACN,MAAMC,OAAO,GAAG,KAAKJ,QAAL,CAAcG,QAAd,GAAyBW,aAAzB,CAAuCX,QAAvC,CAAhB;IACA,OAAOG,GAAG,CAACC,IAAJD,CAASF,OAAO,CAACI,OAAjBF,EAA0B,CAC/BG,MAAM,CAACC,IAAPD,CAAY,YAAZA,EAA0B,MAA1BA,CAD+B,EAE/BA,MAAM,CAACC,IAAPD,CAAY,CAACO,EAAD,CAAZP,CAF+B,EAG/BQ,IAAI,CAACN,QAALM,EAH+B,EAI/BL,UAAU,CAACD,QAAXC,EAJ+B,EAK/BV,YAAY,CAACS,QAAbT,EAL+B,CAA1BI,CAAP;EAOF;EAEA;AACF;AACA;AACA;;;EACEY,WAAW,QAiBH;IAAA,IAjBI;MACVC,UADU;MAEVF,IAFU;MAGVf,YAHU;MAIVU,UAJU;MAKVT;IALU,CAiBJ;IACN,MAAMC,OAAO,GAAG,KAAKJ,QAAL,CAAcG,QAAd,GAAyBW,aAAzB,CAAuCX,QAAvC,CAAhB;IACA,OAAOG,GAAG,CAACC,IAAJD,CAASF,OAAO,CAACI,OAAjBF,EAA0B,CAC/BG,MAAM,CAACC,IAAPD,CAAY,YAAZA,EAA0B,MAA1BA,CAD+B,EAE/BU,UAF+B,EAG/BF,IAAI,CAACN,QAALM,EAH+B,EAI/BL,UAAU,CAACD,QAAXC,EAJ+B,EAK/BV,YAAY,CAACS,QAAbT,EAL+B,CAA1BI,CAAP;EAOF;EAEA;AACF;AACA;AACA;;;EACEc,YAAY,QAcJ;IAAA,IAdK;MACXC,WADW;MAEXnB,YAFW;MAGXU,UAHW;MAIXT;IAJW,CAcL;IACN,MAAMC,OAAO,GAAG,KAAKJ,QAAL,CAAcG,QAAd,GAAyBW,aAAzB,CAAuCX,QAAvC,CAAhB;IACA,OAAOG,GAAG,CAACC,IAAJD,CAASF,OAAO,CAACI,OAAjBF,EAA0B,CAC/BG,MAAM,CAACC,IAAPD,CAAY,eAAZA,EAA6B,MAA7BA,CAD+B,EAE/BY,WAAW,CAACV,QAAZU,EAF+B,EAG/BT,UAAU,CAACD,QAAXC,EAH+B,EAI/BV,YAAY,CAACS,QAAbT,EAJ+B,CAA1BI,CAAP;EAMF;;AA/HkC","sourcesContent":["import { Buffer } from 'buffer';\nimport type { Metaplex } from '@/Metaplex';\nimport { Pda, Program, PublicKey } from '@/types';\n\n/**\n * This client allows you to build PDAs related to the Candy Machine module.\n *\n * @see {@link CandyMachineClient}\n * @group Module Pdas\n */\nexport class CandyMachinePdasClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /** Finds the Authority PDA for the given Candy Machine. */\n  authority({\n    candyMachine,\n    programs,\n  }: {\n    /** The Candy Machine address */\n    candyMachine: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyMachine(programs);\n    return Pda.find(program.address, [\n      Buffer.from('candy_machine', 'utf8'),\n      candyMachine.toBuffer(),\n    ]);\n  }\n\n  /** Finds the Candy Guard PDA for the given base address it derives from. */\n  candyGuard({\n    base,\n    programs,\n  }: {\n    /** The base address which the Candy Guard PDA derives from. */\n    base: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [\n      Buffer.from('candy_guard', 'utf8'),\n      base.toBuffer(),\n    ]);\n  }\n\n  /**\n   * Finds the Mint Limit Counter PDA that keeps track of how many\n   * NFTs where minted by a given user on a given Candy Machine.\n   */\n  mintLimitCounter({\n    id,\n    user,\n    candyMachine,\n    candyGuard,\n    programs,\n  }: {\n    /** A unique identifier in the context of a Candy Machine/Candy Guard combo. */\n    id: number;\n    /** The address of the wallet trying to mint. */\n    user: PublicKey;\n    /** The address of the Candy Guard account. */\n    candyGuard: PublicKey;\n    /** The address of the Candy Machine account. */\n    candyMachine: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [\n      Buffer.from('mint_limit', 'utf8'),\n      Buffer.from([id]),\n      user.toBuffer(),\n      candyGuard.toBuffer(),\n      candyMachine.toBuffer(),\n    ]);\n  }\n\n  /**\n   * Finds the Allow List Proof PDA that keeps track of whether a user\n   * has provided the correct Merkle Proof for the given Merkle Root.\n   */\n  merkleProof({\n    merkleRoot,\n    user,\n    candyMachine,\n    candyGuard,\n    programs,\n  }: {\n    /** The Merkle Root used when verifying the user. */\n    merkleRoot: Uint8Array;\n    /** The address of the wallet trying to mint. */\n    user: PublicKey;\n    /** The address of the Candy Guard account. */\n    candyGuard: PublicKey;\n    /** The address of the Candy Machine account. */\n    candyMachine: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [\n      Buffer.from('allow_list', 'utf8'),\n      merkleRoot,\n      user.toBuffer(),\n      candyGuard.toBuffer(),\n      candyMachine.toBuffer(),\n    ]);\n  }\n\n  /**\n   * Finds the Freeze PDA used as an escrow account by\n   * the freezeSolPayment and freezeTokenPayment guards.\n   */\n  freezeEscrow({\n    destination,\n    candyMachine,\n    candyGuard,\n    programs,\n  }: {\n    /** The wallet that will eventually receive the funds. */\n    destination: PublicKey;\n    /** The address of the Candy Guard account. */\n    candyGuard: PublicKey;\n    /** The address of the Candy Machine account. */\n    candyMachine: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const program = this.metaplex.programs().getCandyGuard(programs);\n    return Pda.find(program.address, [\n      Buffer.from('freeze_escrow', 'utf8'),\n      destination.toBuffer(),\n      candyGuard.toBuffer(),\n      candyMachine.toBuffer(),\n    ]);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}