"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const logger_1 = __importDefault(require("../logger"));
const types_1 = require("../types");
const useChain_1 = __importDefault(require("./useChain"));
const useRefresh_1 = __importDefault(require("./useRefresh"));
const useWalletHooks_1 = __importDefault(require("./useWalletHooks"));
const actionCreator_1 = require("../actionCreator");
const usePOWO_1 = __importDefault(require("./usePOWO"));
const useGatekeeper_1 = __importDefault(require("./useGatekeeper"));
const useGatekeeperRecord_1 = __importDefault(require("./useGatekeeperRecord"));
const networkConfig_1 = __importDefault(require("../networkConfig"));
const useCivicPass_1 = __importDefault(require("./useCivicPass"));
const useCivicPassEventListener_1 = __importDefault(require("./useCivicPassEventListener"));
const status_1 = require("../utils/status");
const tokenUtils_1 = require("../utils/tokenUtils");
/**
 * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:
 * 1. the creation of a new gateway token for a new user
 * 2. the refreshing of an existing token for an existing user
 *
 * The orchestrator triggers uses effects to trigger flows for these two scenarios
 *
 * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0
 * @param {Partial<RootState>} state
 * @param {React.Dispatch<Action>} dispatch
 * @returns void
 */
const useOrchestration = ({ wallet, stage, chainImplementation, gatekeeperClient, }, state, dispatch) => {
    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);
    const { gatewayToken, walletToRefresh, civicPass, refreshTokenState, gatewayStatus, gatekeeperNetworkAddress, ownerSigns, renderIframe, refreshTimeoutId, } = state;
    const networkConfig = (0, networkConfig_1.default)({ gatekeeperNetworkAddress, stage });
    // Register our hooks here
    const { waitForConfirmPOWO, waitForPOWO, waitForTransactionConfirm, waitForHandleTransaction } = (0, usePOWO_1.default)({ wallet, chainImplementation }, state, dispatch);
    const gatekeeperEndpoint = chainImplementation.httpConfig.baseUrl;
    const { waitForGatekeeperIssuanceRequest } = (0, useGatekeeper_1.default)({ wallet, stage, gatekeeperClient }, state, dispatch);
    const { checkForRefreshWithTimeout, refreshToken, waitForUnexpiredGatewayToken } = (0, useRefresh_1.default)({ stage, gatekeeperClient, networkConfig }, state, dispatch);
    (0, useCivicPass_1.default)({ wallet }, state, dispatch);
    (0, useCivicPassEventListener_1.default)({ wallet, chainImplementation });
    (0, useChain_1.default)({ wallet, chainImplementation, networkConfig }, state, dispatch);
    (0, useGatekeeperRecord_1.default)({ wallet, gatekeeperClient, httpConfig: chainImplementation.httpConfig, networkConfig }, state, dispatch);
    /**
     * Refresh Flows ----------------------------------------------------------------
     */
    /**
     * wait until we have a payload that has been emitted by the CivicPass iframe
     * then resolve the promise
     */
    const waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(() => {
        expectWalletConnected();
        logger_1.default.debug('waitForCivicPassRefreshResponsePayload');
        const result = new Promise((resolve) => {
            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;
            const refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];
            logger_1.default.debug('Refresh payload...', {
                refreshPayload,
                refreshPayloadState: refreshPayload === undefined,
            });
            if (refreshPayload !== undefined) {
                logger_1.default.debug('Refreshing token...');
                resolve(refreshPayload);
            }
        });
        return result;
    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);
    /**
     * When we have a token start check the next expiration so we can prompt the user to refresh
     */
    (0, react_1.useEffect)(() => {
        logger_1.default.debug('useOrchestration', {
            gatewayStatus: gatewayStatus && (0, status_1.statusDisplayValue)(gatewayStatus),
            refreshTokenState: refreshTokenState && types_1.RefreshTokenState[refreshTokenState],
        });
        if (gatewayStatus === types_1.GatewayStatus.ACTIVE || refreshTokenState === types_1.RefreshTokenState.COMPLETED) {
            logger_1.default.debug('Start polling for the refresh interval');
            checkForRefreshWithTimeout(wallet);
        }
    }, [gatewayStatus, refreshTokenState, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, renderIframe]);
    /**
     * Whenever the iFrame is rendered, clear the timeout
     */
    (0, react_1.useEffect)(() => {
        if (renderIframe && refreshTimeoutId) {
            logger_1.default.debug('useEffect:dispatch refresh_clear_timeout');
            clearTimeout(refreshTimeoutId);
            dispatch({ type: 'refresh_clear_timeout' });
        }
    }, [renderIframe, refreshTimeoutId]);
    /**
     * Issuance Flows ----------------------------------------------------------------
     */
    /**
     * poll until a gatekeeper record is found, once active check the chain for a token
     * then dispatch a tokenChange event that will result in the token getting saved to state
     * start token refresh polling once a valid token is set
     */
    const waitForOnChainToken = (0, react_1.useCallback)(async () => {
        if (wallet) {
            logger_1.default.debug('waitForOnChainToken');
            const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({
                wallet,
                chainImplementation,
                gatekeeperClient,
                dispatch,
                networkConfig,
                ownerSigns,
            });
            await actionCreator.waitForGatewayToken();
        }
        return null;
    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);
    /**
     * wait until a presentation request id has been emitted by the CivicPass iframe
     * then resolve the promise
     */
    const waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(() => {
        expectWalletConnected();
        logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');
        const result = new Promise((resolve) => {
            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;
            const issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];
            logger_1.default.debug('Issuance payload...', issuancePayload);
            if (issuancePayload !== undefined) {
                resolve(issuancePayload);
            }
        });
        return result;
    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);
    /**
     * wait until the user has requested a gateway token before resolving the promise
     */
    const checkForRequiredProof = (0, react_1.useCallback)(async ({ requiresProofOfWalletOwnership, payload, }) => {
        logger_1.default.debug('Checking for required proof', { requiresProofOfWalletOwnership, payload });
        if (requiresProofOfWalletOwnership) {
            const result = await waitForConfirmPOWO(payload).then(waitForPOWO);
            return result;
        }
        return { payload };
    }, [waitForConfirmPOWO, waitForPOWO]);
    /**
     * New token request flow !ownerSigns:
     * wait for the user to request a new token
     * wait for the iframe to return a payload
     * wait for the user to confirm they've read the proof of ownership dialogue
     * wait for the user to provide proof of ownership
     * wait for a call to the gatekeeper to request a new token issuance
     * wait for a gatekeeper record to be created
     * once this flow is complete a new Gatekeeper token should be available and set in state
     */
    (0, react_1.useEffect)(() => {
        if (!ownerSigns) {
            logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload !ownerSigns');
            waitForCivicPassIssuanceResponsePayload()
                .then(checkForRequiredProof)
                .then(waitForGatekeeperIssuanceRequest)
                .then(waitForOnChainToken)
                .then(() => checkForRefreshWithTimeout(wallet))
                .catch((error) => {
                dispatch({ type: 'civicPass_issuance_failure' });
                logger_1.default.error('ERROR newTokenRequestFlow', error);
            });
        }
    }, [
        waitForCivicPassIssuanceResponsePayload,
        checkForRequiredProof,
        waitForGatekeeperIssuanceRequest,
        waitForOnChainToken,
        ownerSigns,
    ]);
    /** Wrapper to pass through expected parameters when waiting for owner signs confirmation */
    const confirmOwnerTransaction = (0, react_1.useCallback)(async ({ payload }) => {
        await waitForTransactionConfirm();
        return { payload };
    }, [waitForTransactionConfirm]);
    /**
     * Trigger the waiting for owner transaction state
     * this function is a promise so it can be thenable
     */
    const showAwaitingOwnerTransaction = async () => {
        logger_1.default.debug('showAwaitingOwnerTransaction');
        dispatch({ type: 'civicPass_awaiting_owner_transaction' });
        return Promise.resolve();
    };
    /**
     * New token request flow ownerSigns:
     * wait for the user to request a new token
     * wait for the iframe to return a payload
     * wait for the user to confirm the transaction that they need to sign
     * wait for a call to the gatekeeper to request a new token issuance
     * wait for the handle transaction callback
     * wait for a gatekeeper record to be created on chain
     * once this flow is complete a new Gatekeeper token should be available and set in state
     */
    (0, react_1.useEffect)(() => {
        if (ownerSigns) {
            logger_1.default.debug('useEffect: waitForCivicPassIssuanceResponsePayload ownerSigns');
            waitForCivicPassIssuanceResponsePayload()
                .then(confirmOwnerTransaction)
                .then(waitForGatekeeperIssuanceRequest)
                .then(waitForHandleTransaction)
                .then(showAwaitingOwnerTransaction)
                .then(waitForOnChainToken)
                .then(() => checkForRefreshWithTimeout(wallet))
                .catch((error) => {
                // chain transaction errors will be handled using a different flow and dispatch event
                if (!(error instanceof types_1.ChainTransactionError)) {
                    dispatch({ type: 'civicPass_issuance_failure' });
                }
                logger_1.default.error('ERROR newTokenRequestFlow', error);
            });
        }
    }, [
        waitForCivicPassIssuanceResponsePayload,
        confirmOwnerTransaction,
        waitForGatekeeperIssuanceRequest,
        waitForHandleTransaction,
        waitForOnChainToken,
        ownerSigns,
    ]);
    /**
     * Refresh start flow !ownerSigns:
     * Triggered when we have a refreshResponse payload
     * wait refresh to be triggered from the iFrame
     * wait for the iframe to return a payload
     * wait for the user to confirm they've read the proof of ownership dialogue
     * wait for the user to provide proof of ownership
     * wait for a call to the gatekeeper to refresh the token
     * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below
     */
    (0, react_1.useEffect)(() => {
        if (!ownerSigns) {
            logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload !ownerSigns');
            const useWallet = walletToRefresh || wallet;
            waitForCivicPassRefreshResponsePayload()
                .then(checkForRequiredProof)
                .then(refreshToken(useWallet))
                .then(() => dispatch({ type: 'refresh_token_success' }))
                .catch((error) => {
                logger_1.default.error('refreshFlow', error);
                dispatch({ type: 'civicPass_refresh_failure' });
            });
        }
    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, ownerSigns]);
    /**
     * Refresh start flow ownerSigns:
     * Triggered when we have a refreshResponse payload
     * wait refresh to be triggered from the iFrame
     * wait for the iframe to return a payload
     * wait for the handle transaction callback
     * the rest of the flow is handled by the WAIT_FOR_ON_CHAIN useEffect below
     */
    (0, react_1.useEffect)(() => {
        if (ownerSigns) {
            logger_1.default.debug('useEffect: waitForCivicPassRefreshResponsePayload ownerSigns');
            const useWallet = walletToRefresh || wallet;
            waitForCivicPassRefreshResponsePayload()
                .then(refreshToken(useWallet))
                .then(waitForHandleTransaction)
                .then(() => dispatch({ type: 'refresh_token_success' }))
                .catch((error) => {
                // chain transaction errors will be handled using a different flow and dispatch event
                if (!(error instanceof types_1.ChainTransactionError)) {
                    dispatch({ type: 'civicPass_refresh_failure' });
                }
                logger_1.default.error('ERROR tokenRefreshFlow ownerSigns', error);
            });
        }
    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, ownerSigns]);
    /**
     * Refresh complete flow:
     * Triggered by token change event triggered from a call to the gatekeeper to refresh the token
     * for owner signs case, dispatch an event to show the iframe chain-transaction confirming screen
     * wait until the token is unexpired and clear timeout if token is not expired
     * Complete the refresh event and clear the refresh response payload
     */
    (0, react_1.useEffect)(() => {
        const useWallet = walletToRefresh || wallet;
        if (refreshTokenState === types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN) {
            logger_1.default.debug('useEffect: Refresh complete flow', {
                expiryTime: gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime,
                hasExpired: (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) ? (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime) : 'unknown',
            });
            // if the dApp handles the transaction we shouldn't assume that the final state is 'unexpired' token
            const optionalCheckUnexpired = chainImplementation.dAppHandlesTransactions && ownerSigns
                ? () => Promise.resolve()
                : waitForUnexpiredGatewayToken;
            optionalCheckUnexpired()
                .then(() => checkForRefreshWithTimeout(useWallet))
                .then(() => {
                dispatch({ type: 'refresh_complete' });
                dispatch({ type: 'civicPass_check_token_status' });
            })
                .catch((error) => {
                logger_1.default.error('refreshFlow', error);
                dispatch({ type: 'civicPass_refresh_failure' });
            });
        }
    }, [
        gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.identifier,
        gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime,
        refreshTokenState,
        walletToRefresh === null || walletToRefresh === void 0 ? void 0 : walletToRefresh.publicKey,
        wallet === null || wallet === void 0 ? void 0 : wallet.publicKey,
        ownerSigns,
    ]);
};
exports.default = useOrchestration;
