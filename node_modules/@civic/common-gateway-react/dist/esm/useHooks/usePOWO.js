"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const types_1 = require("../types");
const logger_1 = __importDefault(require("../logger"));
const useWalletHooks_1 = __importDefault(require("./useWalletHooks"));
const usePowo = ({ wallet, chainImplementation }, state, dispatch) => {
    const { powoFinished, walletPowoInProgress, refreshInProgress, ownerTransactionConfirmed } = state;
    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);
    /**
     * wait until the user has confirmed they want to continue the proof of wallet ownership flow
     * then resolve the promise
     */
    const waitForConfirmPOWO = (0, react_1.useCallback)(
    // eslint-disable-next-line @typescript-eslint/no-shadow
    async (payload) => {
        logger_1.default.debug('usePowo waitForConfirmPOWO before expectWalletConnected', {
            payload,
        });
        expectWalletConnected();
        return new Promise((resolve) => {
            logger_1.default.debug('usePowo waitForConfirmPOWO', { powoFinished });
            if (powoFinished) {
                resolve(payload);
            }
        });
    }, [powoFinished, expectWalletConnected]);
    /**
     * wait until the user has provided proof of wallet ownership using their connected wallet
     * if this was triggered from the refresh flow, dispatch events to indicate progress
     * if not, resolve a promise when the proof is ready
     */
    const waitForPOWO = (0, react_1.useCallback)(async (
    // eslint-disable-next-line @typescript-eslint/no-shadow
    payload) => {
        logger_1.default.debug('usePowo waitForPOWO before expectWalletConnected');
        const connectedWallet = expectWalletConnected();
        if (connectedWallet) {
            logger_1.default.debug('usePowo waitForPOWO', {
                payload,
                publicKey: connectedWallet.publicKey,
            });
            return new Promise((resolve) => {
                logger_1.default.debug('usePowo waitForPOWO walletPowoInProgress', {
                    walletPowoInProgress,
                    refreshInProgress,
                });
                chainImplementation
                    .proveWalletOwnership()
                    .then((proof) => {
                    resolve({ proof, payload });
                    dispatch({ type: 'walletPowoComplete' });
                    dispatch({ type: 'civicPass_check_token_status' });
                })
                    .catch((error) => {
                    logger_1.default.error('Proof of wallet ownership error: ', error);
                    dispatch({ type: 'walletPowoIncomplete' });
                });
            });
        }
        return {};
    }, [expectWalletConnected, walletPowoInProgress, chainImplementation]);
    /**
     * wait until the user has confirmed they want to continue the sign transaction flow
     * then resolve the promise
     */
    const waitForTransactionConfirm = (0, react_1.useCallback)(async () => {
        expectWalletConnected();
        return new Promise((resolve) => {
            logger_1.default.debug('usePowo waitForTransactionConfirm', { ownerTransactionConfirmed });
            if (ownerTransactionConfirmed) {
                resolve();
            }
        });
    }, [ownerTransactionConfirmed, expectWalletConnected]);
    /**
     * wait for the user sign transaction callback and then dispatch awaiting owner transaction
     * to set the correct status while waiting for the token on chain
     */
    const waitForHandleTransaction = (0, react_1.useCallback)(async (transaction) => {
        logger_1.default.debug('waitForHandleTransaction', transaction);
        try {
            await chainImplementation.handleUserSignedTransaction(transaction);
            dispatch({ type: 'walletPowoComplete' });
        }
        catch (error) {
            const errorMessage = error && error instanceof Error ? error.message : 'ChainTransaction error';
            const errorCode = error === null || error === void 0 ? void 0 : error.errorCode;
            logger_1.default.error('waitForHandleTransaction error', { errorCode });
            const payload = Object.assign({}, (errorCode ? { errorCode } : {}));
            logger_1.default.error('waitForHandleTransaction (error instanceof ChainError)', errorCode);
            dispatch({ type: 'civicPass_owner_sends_chainTransactionError', payload });
            throw new types_1.ChainTransactionError(errorMessage);
        }
    }, [chainImplementation]);
    return {
        waitForConfirmPOWO,
        waitForTransactionConfirm,
        waitForHandleTransaction,
        waitForPOWO,
    };
};
exports.default = usePowo;
