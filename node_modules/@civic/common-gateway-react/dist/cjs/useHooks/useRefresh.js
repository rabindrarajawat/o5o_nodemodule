"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reducer = void 0;
const R = __importStar(require("ramda"));
const react_1 = require("react");
const utils_1 = require("../useReducer/utils");
const logger_1 = __importDefault(require("../logger"));
const types_1 = require("../types");
const tokenUtils_1 = require("../utils/tokenUtils");
const reducer = (state, action) => {
    switch (action.type) {
        case 'refresh_start': {
            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED });
        }
        case 'refresh_status_check': {
            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });
        }
        case 'refresh_complete': {
            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), refreshTimeoutId: undefined, civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });
        }
        case 'refresh_with_powo_in_progress': {
            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.CHECKING });
        }
        case 'refresh_clear_timeout':
            return Object.assign(Object.assign({}, state), { refreshTimeoutId: undefined });
        case 'refresh_set_timeout':
            return Object.assign(Object.assign({}, state), { refreshTimeoutId: action.refreshTimeoutId });
        case 'refresh_token_success':
            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN });
        default:
            return state;
    }
};
exports.reducer = reducer;
const useRefresh = ({ stage, gatekeeperClient, networkConfig, }, state, dispatch) => {
    const { refreshTimeoutId, gatewayToken, gatekeeperNetworkAddress, ownerSigns, walletAddress } = state;
    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);
    const setTimeoutForRefresh = (0, react_1.useRef)(null);
    /**
     * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed
     * event, triggering the refreshFlow
     */
    const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {
        logDebug('Checking if refresh required', refreshTimeoutId);
        dispatch({ type: 'refresh_status_check' });
        if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {
            const { tokenExpirationMarginSeconds } = networkConfig;
            const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);
            const timeoutId = setTimeout(() => {
                const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({ gatewayToken, tokenExpirationMarginSeconds });
                if (shouldRefresh) {
                    logDebug('Refreshing Gateway Token');
                    dispatch({ type: 'refresh_start' });
                    dispatch({ type: 'civicPass_check_token_status' });
                    return;
                }
                logDebug('Skipping refresh', { gatewayToken, tokenExpirationMarginSeconds });
                dispatch({ type: 'refresh_complete' });
            }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion
            logDebug('Setting token refresh timeout', {
                expiring: gatewayToken.expiryTime,
                checkForExpirationIntervalMilliseconds,
                margin: tokenExpirationMarginSeconds,
            });
            dispatch({
                type: 'refresh_set_timeout',
                refreshTimeoutId: timeoutId,
            });
        }
    }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);
    /**
     * use the passed proof of wallet ownership string to call the gatekeeper refresh token
     * endpoint.
     * On server error (5xx), retry with backoff.
     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.
     */
    const refreshToken = (0, react_1.useCallback)((useWallet) => async ({ proof, payload }) => {
        logDebug('Refresh token', { payload, proof });
        dispatch({ type: 'refresh_with_powo_in_progress' });
        const refreshResult = await gatekeeperClient().refreshToken({
            wallet: useWallet,
            payload,
            proof,
            ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false,
        });
        // fail for 4XX errors
        if (refreshResult.status >= 400 && refreshResult.status < 500) {
            throw new Error(`Error ${refreshResult.status} from refresh gatekeeper token request`);
        }
        // Fail if client sends and no transaction is returned
        if (ownerSigns && (R.isNil(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction) || R.isEmpty(refreshResult === null || refreshResult === void 0 ? void 0 : refreshResult.transaction))) {
            throw new Error(`Error ${refreshResult.status} no transaction returned from owner signs gatekeeper refresh request`);
        }
        return refreshResult.transaction;
    }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);
    /**
     * wait until a gateway token exists in state before resolving the promise
     */
    const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {
        return new Promise((resolve, reject) => {
            const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);
            logDebug('waitForUnexpiredGatewayToken: Waiting for unexpired token', {
                gatewayToken,
                currentRefreshTimeoutId: setTimeoutForRefresh.current,
                isExpired,
            });
            if (setTimeoutForRefresh.current) {
                logDebug('waitForUnexpiredGatewayToken: Clearing interval for gatewayToken', setTimeoutForRefresh.current);
                clearTimeout(setTimeoutForRefresh.current);
                setTimeoutForRefresh.current = null;
            }
            if (!isExpired) {
                logDebug('waitForUnexpiredGatewayToken: Gateway token is unexpired', gatewayToken);
                resolve();
                return;
            }
            setTimeoutForRefresh.current = setTimeout(() => {
                reject(new Error('Gateway token refresh has not been updated onChain'));
            }, networkConfig.waitForTokenRefreshTimoutMilliseconds);
            logDebug('waitForUnexpiredGatewayToken: Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);
            if (ownerSigns) {
                logDebug('waitForUnexpiredGatewayToken: emitting awaiting owner transaction');
                // show the awaiting owner transaction UI if this is ownersigns
                dispatch({ type: 'civicPass_awaiting_owner_transaction' });
            }
        });
    }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, gatekeeperNetworkAddress]);
    return {
        checkForRefreshWithTimeout,
        refreshToken,
        waitForUnexpiredGatewayToken,
    };
};
exports.default = useRefresh;
